

## 2. const关键字的使用场景有哪些？

const关键字在C++中非常常用，它的作用是将某些变量、指针、函数参数、成员函数等标记为不可修改的。使用const可以提高代码的安全性和可读性，避免不必要的修改。以下是const关键字的常见使用场景：

1. 修饰变量：
全局变量或局部变量： 如果变量的值不应该被修改，可以将其声明为const。

2. 修饰指针：
指针和指向的数据都可以用const来修饰，这里有四种常见情况
```cpp
//指针指向的对象是常量（对象不可变）：
const int* ptr; // 指向const int的指针，不能通过ptr修改指向的对象的值

//指针本身是常量（指针不可变）：
int* const ptr = &var; // 常量指针，ptr本身不能修改，但可以通过它修改指向的对象

//指针和指向的对象都是常量：
const int* const ptr = &var; // 指针和指向的对象都不可修改

//指针指向的数据为const，但指针可以改变：
int const* ptr = &var; // 与第一种情况相同，指针可变，指向的数据不可变
```

3. 修饰函数参数：
传递指针或引用时，防止函数修改参数：
```cpp
void printData(const int* data) {
    // 不能修改data指向的内容
}
```
传递对象时，防止不必要的拷贝：

传递对象时，使用const引用避免拷贝，提高效率，同时确保函数不修改对象。
```cpp
void display(const std::string& str) {
    // str是const引用，不能被修改
}
```
4. 修饰成员函数：
常量成员函数： 当成员函数不会修改类的成员变量时，可以将其声明为const。这样做可以确保该函数不会意外地修改对象的状态，并且允许在const对象上调用该函数。
```cpp
class MyClass {
public:
    int getValue() const { return value; } // 常量成员函数
private:
    int value;
};

```

## 3. C++中的深拷贝和浅拷贝有什么区别？
1. 浅拷贝（Shallow Copy）：
浅拷贝是指对对象进行复制时，仅仅复制对象的非指针成员变量，以及指针变量的地址（指针的值），而不复制指针所指向的实际数据。

行为：浅拷贝会复制对象的成员变量，包括指针变量，但不会为指针指向的数据分配新的内存空间。换句话说，两个对象会共享同一块内存空间中的数据。

问题：浅拷贝容易导致问题，尤其是在删除或修改指针指向的数据时。例如，当一个对象被销毁时，它会释放指针指向的内存。如果两个对象共享同一块内存，一个对象释放了内存后，另一个对象的指针将成为悬空指针（dangling pointer），这会导致程序崩溃或不确定的行为。
```cpp
class Shallow {
public:
    int* data;
    Shallow(int val) {
        data = new int(val);
    }
    ~Shallow() {
        delete data;
    }
};

Shallow obj1(5);
Shallow obj2 = obj1; // 浅拷贝，obj2.data 指向同一块内存

```
在上面的示例中，obj1和obj2中的data指针指向同一块内存。这种情况下，当其中一个对象被销毁时，另一个对象的指针将成为悬空指针。

2. 深拷贝（Deep Copy）：
深拷贝是指对对象进行复制时，不仅复制对象的成员变量，还会为指针指向的内容分配新的内存空间，并复制指针指向的实际数据。

行为：深拷贝会创建一个独立的副本，包括为指针指向的数据分配新的内存空间。这样，每个对象都有自己独立的数据拷贝，修改或销毁其中一个对象不会影响另一个对象。

优点：深拷贝避免了共享内存带来的问题，可以安全地对每个对象进行操作而不影响其他对象。

示例：
```cpp
class Deep {
public:
    int* data;
    Deep(int val) {
        data = new int(val);
    }
    
    // 深拷贝构造函数
    Deep(const Deep& other) {
        data = new int(*(other.data)); // 分配新内存并复制数据
    }
    
    ~Deep() {
        delete data;
    }
};

Deep obj1(5);
Deep obj2 = obj1; // 深拷贝，obj2.data 指向新分配的内存
```
在这个例子中，obj2是obj1的深拷贝。obj2中的data指针指向了一个新分配的内存空间，因此即使obj1被销毁，obj2的数据依然安全。

## 4.C++中的引用和指针有什么区别？
1. 定义和语法
指针：指针是一个变量，它存储另一个变量的内存地址。通过指针，可以访问或修改它指向的变量。
  
  语法：指针变量的声明使用*符号。
  ```cpp
    int x = 10;
    int* ptr = &x;  // ptr是指向x的指针
  ```
引用：引用是一个变量的别名，它是另一个变量的直接引用，必须在定义时初始化，之后不能改变其绑定的对象。

  语法：引用的声明使用&符号。
  ```cpp
    int x = 10;
    int& ref = x;  // ref是x的引用
  ```
2. 初始化和绑定
指针：指针可以在声明时未初始化，或者可以指向不同的对象。指针还可以是nullptr，即它指向空地址。
```cpp
int* ptr = nullptr;  // 空指针
int y = 20;
ptr = &y;  // 现在ptr指向y

```
引用：引用必须在声明时初始化，且一旦绑定到某个对象，就不能再改变其引用的对象。引用不能为nullptr
```cpp
int z = 30;
int& ref = z;  // ref必须在声明时绑定到z

```

3. 内存和大小
指针：指针本质上是一个变量，它占用内存来存储地址。在大多数系统中，指针的大小是固定的（如32位或64位），与其指向的对象的类型无关。

引用：引用并不直接占用内存，它是一个别名，在实现上可能被编译器优化掉。引用本身没有独立的存储空间。

## 5. 解释一下C++中的多重继承及其问题。

## 6. C++中的虚函数表（vtable）是什么？

## 7. 解释一下C++中的命名空间

## 8. 什么是函数重载和运算符重载？有什么注意事项？

## 9.  C++中的类型推导（auto）是什么？

## 10. 解释一下C++中的内联函数（inline）。

## 11 解释一下C++中的友元函数和友元类

## 12. 锁的可重入性是什么意思？
锁的可重入性（reentrant lock，也叫递归锁）是指一个线程可以多次获得同一个锁，而不会引起死锁。简单来说，当一个线程已经持有了某个锁时，它可以在不释放该锁的情况下再次申请该锁。这种锁允许同一线程在进入临界区之后再次进入临界区，而不被阻塞。

非可重入锁的问题
  对于非可重入锁，如果同一线程在已经持有该锁的情况下再次尝试获取它，系统会认为该线程已经进入了临界区并且锁还没有被释放，因此会产生死锁。

可重入锁的工作原理
  可重入锁通常会维护一个计数器和所有者线程的标识。当一个线程第一次获得锁时，锁的计数器从 0 增加到 1，并且记录当前持有该锁的线程。如果该线程再次尝试获取该锁，计数器会再次增加，但锁不会被真正阻塞，直到线程完全释放该锁（计数器降为 0）。

可重入锁的优点
 + 避免死锁：如果某个线程在持有锁的情况下递归调用自己或调用其他需要同一锁的函数，可重入锁可以避免死锁。
 + 简化设计：可重入锁允许线程在多个互相调用的同步函数之间共享锁，不需要在每次调用函数时释放和重新获取锁。

非可重入锁的死锁问题：
```cpp
std::mutex mtx;

void func() {
    mtx.lock();  // 第一次加锁
    // 如果再次调用此函数，会尝试加锁，导致死锁
    func();  
    mtx.unlock();
}
```
上述代码中，func() 函数在递归调用时再次尝试加锁 mtx，导致死锁。

可重入锁解决死锁：
```cpp
std::recursive_mutex rmtx;

void func() {
    rmtx.lock();  // 第一次加锁
    func();       // 第二次加锁，不会死锁
    rmtx.unlock();  // 第二次解锁
    rmtx.unlock();  // 第一次解锁
}
```
在这个例子中，使用 std::recursive_mutex（递归锁）来替代普通的 std::mutex，可以使得 func() 在递归调用时不会死锁




15. C++中的析构函数有什么作用？什么时候会被调用？
16. 解释一下C++中的友元函数和友元类。
17. 什么是动态多态？如何实现？
18. C++中的静态成员变量和静态成员函数有什么特点？
19. 什么是析构函数的虚函数？有什么意义？
20. C++中的编译期和运行期是什么？
21. C++中的类型转换有哪些方式？
22. 什么是C++中的“移动语义”？
23. 解释一下C++中的std::function和std::bind。
24. C++中的std::shared_ptr和std::unique_ptr有什么区别？
25. C++中的std::vector和std::list的区别是什么？
26. C++中如何实现单例模式？
27. C++中的多态是如何实现的？
28. 什么是C++中的“模板特化”？
29. volatile关键字有什么作用？
30. static_cast、dynamic_cast、const_cast、reinterpret_cast的区别是什么？
31. lambda表达式与函数对象的区别是什么？
32. std::map和std::set的底层实现是什么？
33. std::thread如何使用，线程的创建和管理是怎样的？
34.如何实现接口（interface）？
35. 如何处理内存泄露，使用哪些工具和方法？

1.介绍项目，详细说一下实习期间参与的项目的具体工作，个人担任的角色
2.go协程和线程的区别
3.左值和右值的区别，衍生到左值引用右值引用
4.右值经过资源转移过后是否被销毁？
5.转移过后得到的值还是右值吗？它的生命周期是怎样的？
6.模板函数在哪个阶段实例化?
7.vector实现原理
8.vector什么时候动态增长
9.空vector有大小吗，大概是多少？
10.内存对齐
11.全局静态变量的内存怎么确保内存对齐
12.静态函数能虚函数吗
13.源文件编译成可执行文件的步骤
14.代码转成机器码是在哪个步骤？
15.编译优化是在哪个阶段
16.具体讲一下编译优化，举个例子
17.给一个switch判断条件，想一下编译器会做什么样的优化来加快其执行速度
18.new和malloc的区别
19.malloc能否做到跟new得到的指针一样的效果？
20.malloc出来的内存里的值是怎样的？
21.malloc和calloc的区别
22.这种在线面试系统可能用到哪些网络协议？
23.设计一个在线聊天消息即时发送的系统，你可能会怎么实现
24.git rebase

看你写了协程，说说cpp20协程，有栈无栈协程的差别，分别有什么优劣
cpp新特性？说了11 17一些
你觉得auto好用么？要不要经常用auto
STL里面，map和unordered_map有啥差别，底层实现？
你存一个无序的东西用哪个快？我说哈希。说说哈希如何实现，怎么解决哈希冲突？链表。还有别的么？布谷鸟哈希。那你觉得链表和搜索哈希谁的性能好，从插入删除说说。
排序算法sort底层用的啥？答混合。快排和堆排序、桶排序都是logn，那为啥快排叫快排？如何优化快排？数据量很大时为啥sort不用快排？


1. 析构函数为什么要设置成虚函数
2.  实现一个锁要怎么实现？
3.  锁的可重入性是什么意思？
   
4.  C++里面的原子变量是如何实现的？
5.  线程间的同步机制有哪些？
6.  进程和线程、协程的区别
7.  数据库的ACID是什么？
8.  隔离级别有哪些？
9.  分布式的CAP分别是什么？

10. 析构函数为什么要设置成虚函数
11. 实现一个锁要怎么实现？





12. C++里面的原子变量是如何实现的？
13. 线程间的同步机制有哪些？
14. 进程和线程、协程的区别
15. 数据库的ACID是什么？
16. 隔离级别有哪些？
17. 分布式的CAP分别是什么？

18. 内存泄漏碰到过吗？如何处理？
19. 智能指针的优势是什么？
20. 虚函数和纯虚函数的区别是什么？
21. mysql索引的建立需要注意什么？
22. 事务一般是什么时候使用的？
23. linux查看一个端口是否被占用是什么命令？


3.你知道网络编程服务端建立连接的流程吗?把用到的api说出来(connect，bind，accept这些)
服务端需要设置端口号吗?客户端呢?端口号在哪个api中自动绑定的?端口号有什么作用?如果两个程序使用同一个端口号会怎么样?端口号的范围是多少?哪里限制了端口号的范围?你知道linux用什么命令查找端口号吗?(懵了已经)
4.UDP和TCP你了解吗，TCP头部有哪些内容?TCP怎么保证可靠连接的?现在知道哪里限制了端口号大小了吗?说一说网络的TCP/IP四层模型的作用?TCP是那一层的，IP呢，说一说DNS的工作流程是怎么样的?
5.有没有用过动态库
6.你能介绍一下什么是重载吗?你知道重载和重写的区别吗?
7.你了解虚拟内存吗？进程间的通信方式有哪些你了解吗？用户态和内核态的区别是什么，用户态怎么转到内核态，是自动转换的吗？
8.C++与C相比有什么好处?
9.C++11有哪些新特性?10.你了解智能指针吗?
11.类的缺省函数有哪些?给了几个例子，说一下分别调用的是哪个构造函数，Demo a=b调用=还是拷贝构造?Demo c (a) 呢，Demo d，d=a呢?12.构造函数是先执行基类构造还是子类构造?析构函数呢?
13.Windows创建线程的函数是什么，创建进程的呢?pthread_create有哪些参数，分别有哪些作用?父线程的pthread_create返回值是什么，pthread_detach()函数的作用?如果子线程退出，父线程没有捕捉子线程的信息会有什么影响?那如果父线程先退出呢，子线程会怎么样?

3、项目中模块挨个问
        - 线程池：线程池中怎么判断线程是否空闲
        - HTTP：http请求怎么解析的 平时常用的正则表示式
        - 日志：日志模块为什么用单例 你对单例模式的理解 用到哪些场景 日志有没有划分等级 具体怎么实现的
        - 数据库连接池：登录注册怎么实现的 有没有实现拦截 用户的登录状态怎么保存的
4、C11新特性 智能指针 右值引用








