## 1. wxg 一面

1.https和http区别，加密怎么做
2.左值引用和右值引用
3.讲讲知道的c++新特性
4.互斥锁、自旋锁、还知道哪些锁
5.内存泄漏怎么检测
6.mysql和redis都是关系型数据库吗
7.redis为什么快
8.mysql索引底层数据结构，为什么用b+树
9.http位于7层模型哪一层，讲讲tcp三次握手
10.分布式redis用过吗
11.线程间通信方式
12.qps测试工具了解哪些

### 解答

#### 1. https和http区别，加密怎么做

HTTP（超文本传输协议）和 HTTPS（超文本传输安全协议）主要有以下区别：

+ 安全性
    + HTTP：以明文形式传输数据，不提供加密机制，数据在传输过程中容易被窃取、篡改或监听，安全性较低。
    + 是在 HTTP 的基础上，通过 SSL/TLS 协议进行加密传输和身份认证，确保数据传输的保密性、完整性和身份验证，安全性较高。

> 明文形式传输数据，指的是数据在网络中传输时，没有经过任何加密处理，以原始的、可读的形式进行传送 。
>数据内容直观呈现：以用户登录网站为例，当用户在登录框输入账号 “testuser” 和密码 “123456”，若网站使用 HTTP 协议以明文形式传输数据，那么在网络传输过程中，数据就像写在明信片上的文字一样，直接以 “账号：testuser，密码：123456” 这样的形式进行传递。无论是网络中的路由器、交换机，还是中间存在的恶意攻击者，只要有能力截取这段数据，都能直接看到其中的内容。
> 传输过程无加密转换：在数据传输过程中，HTTP 协议不会对数据进行额外的编码或加密处理。

+ 连接方式
    + HTTP： 使用80端口，建立明文连接，过程简单
    + HTTPS: 使用 443 端口，在建立连接前需要进行 SSL/TLS 握手，协商加密算法和密钥等，连接过程更为复杂。
+ 证书
    + HTTP：无需证书，网站部署成本较低。
    + HTTPS：需要向 CA（证书颁发机构）申请 SSL/TLS 证书，以验证服务器的身份。

> SSL/TLS : SSL/TLS 位于应用层和传输层之间，为应用层数据在网络传输过程中提供加密、身份认证和数据完整性保护。它在客户端（如浏览器）和服务器之间建立一条安全通道，使得数据在这条通道上传输时不易被窃取或篡改。

#### 12.qps测试工具了解哪些

QPS（Queries Per Second）即每秒查询率，是衡量系统性能的一个重要指标。以下为你介绍几种常用的 QPS 测试工具：

ab（Apache Benchmark）
+ 简介：ab 是 Apache HTTP 服务器自带的一个简单的性能测试工具，用于对 HTTP 服务进行基准测试。
+ 特点
    + 简单快速：使用方便，只需一个命令即可开始测试，能快速得到基本的性能指标。
    + 轻量级：对系统资源的消耗较小，适合在资源有限的环境中进行简单的性能测试。
+ 使用场景：适合对 HTTP 服务进行初步的性能评估，快速了解服务器的基本处理能力。


## 2. 

### 1. 在 MySQL 中，普通索引、唯一索引和主键索引对 NULL 值的支持情况各不相同:

普通索引是最基本的索引类型，它的作用仅仅是加快对数据的访问速度，不限制索引列的值是否唯一，也不限制是否为 NULL。所以，普通索引的字段可以为 NULL，而且可以有多个 NULL 值。

```sql
-- 创建一个名为 users 的表，并为 name 字段创建普通索引
CREATE TABLE users (
    id INT,
    name VARCHAR(50),
    age INT,
    -- 使用 INDEX 关键字创建普通索引
    INDEX idx_name (name)
);

-- 为已存在的 users 表的 age 字段创建普通索引
CREATE INDEX idx_age ON users (age);
```

唯一索引要求索引列的值必须唯一，但它允许有一个 NULL 值。这是因为在 SQL 标准里，NULL 代表未知值，两个 NULL 值被认为是不相等的，所以可以在唯一索引列中有多个 NULL 值。

```sql
-- 创建一个名为 employees 的表，并为 email 字段创建唯一索引
CREATE TABLE employees (
    id INT,
    email VARCHAR(100),
    salary DECIMAL(10, 2),
    -- 使用 UNIQUE INDEX 关键字创建唯一索引
    UNIQUE INDEX idx_email (email)
);

-- 为已存在的 employees 表的 salary 字段创建唯一索引
CREATE UNIQUE INDEX idx_salary ON employees (salary);
```

主键用于唯一标识表中的每一行记录，它不允许取 NULL 值。这是因为主键的主要作用是确保记录的唯一性和完整性，如果允许 NULL 值，就无法保证能唯一标识每一行数据。

```cpp
-- 创建一个名为 products 的表，并将 id 字段设置为主键
CREATE TABLE products (
    id INT PRIMARY KEY,
    product_name VARCHAR(200),
    price DECIMAL(10, 2)
);

-- 为已存在的表添加主键索引
ALTER TABLE existing_table ADD PRIMARY KEY (column_name);
```

### 2. sql数组分组用什么命令？group by, join, order by, limit 的优先级

在 SQL 中，若要对数组（一般是指表中的行数据集合）进行分组操作，主要使用 GROUP BY 子句。
GROUP BY 子句的作用 : GROUP BY 用于将结果集按照一个或多个列进行分组，结合聚合函数（如 SUM、COUNT、AVG、MAX、MIN 等）可以对每个分组进行统计计算。

总结一下，这些子句的执行顺序（优先级）为：JOIN > GROUP BY > ORDER BY > LIMIT 。

1. 首先执行 JOIN 操作，它会根据指定的连接条件将多个表组合成一个临时结果集。
2. 对 JOIN 操作后的临时结果集按照 GROUP BY 指定的列进行分组。分组后可以使用聚合函数对每个分组进行计算。例如：
3. ORDER BY 用于对分组后的结果集进行排序，可以按照一个或多个列进行升序（ASC，默认）或降序（DESC）排序。
4. LIMIT 用于限制查询结果返回的行数，通常在排序之后使用，以获取排序后结果集的前几行。
5. 


### 3. 进程，线程，协程区别？一个进程能开多少个协程？

1.  概念
+ 进程（Process）
    + 进程是程序在操作系统中的一次执行过程，是系统进行资源分配和调度的基本单位。每个进程都有自己独立的内存空间、系统资源（如文件描述符等）和执行上下文。例如，当你打开一个浏览器，操作系统就会为浏览器程序创建一个进程。
+ 线程（Thread）
    + 线程是进程中的一个执行单元，是 CPU 调度和分派的基本单位。一个进程可以包含多个线程，这些线程共享进程的内存空间和系统资源，但每个线程有自己独立的栈空间和程序计数器，用于保存线程的执行状态。比如在浏览器进程中，可以有负责渲染页面的线程、处理网络请求的线程等。 
+ 协程（Coroutine）
    + 协程是一种比线程更加轻量级的并发编程模型，也被称为用户态线程。它由程序自身控制调度，而不是由操作系统内核进行调度。协程可以在一个线程中实现多个任务的并发执行，通过在任务之间主动让出执行权，实现上下文的切换。例如，在 Python 中使用 asyncio 库就可以实现协程编程。

2. 资源开销
    + 进程：进程的创建和销毁需要操作系统进行大量的资源分配和回收操作，包括内存空间的分配、文件描述符的分配等，因此进程的创建和切换开销较大。
    + 线程：线程的创建和销毁开销相对较小，因为线程共享进程的资源，不需要重新分配大量的系统资源。但线程的切换仍然需要操作系统内核进行调度，会有一定的开销。
    + 协程：协程的创建和切换开销非常小，因为协程的调度是在用户态完成的，不需要操作系统内核的干预，只需要保存和恢复协程的上下文信息即可。

3. 并发性
    + 进程：进程之间可以实现真正的并行执行，因为不同的进程可以在不同的 CPU 核心上同时运行。但进程间的通信和同步比较复杂，需要使用特定的进程间通信（IPC）机制，如管道、消息队列、共享内存等。
    + 线程：线程之间也可以实现并行执行，前提是在多核 CPU 系统中，不同的线程可以分配到不同的 CPU 核心上运行。线程间的通信和同步相对简单，可以通过共享内存的方式进行数据交换，但需要注意线程安全问题。
    + 协程：协程在单个线程中实现并发执行，通过在协程之间主动让出执行权，实现多个任务的交替执行。协程之间的通信和同步更加简单，因为它们共享同一个线程的上下文。但协程只能实现并发，不能实现真正的并行（除非使用多线程结合协程）。

4. 调度方式
    + 进程：进程的调度由操作系统内核负责，操作系统根据进程的优先级、资源使用情况等因素进行调度。进程的切换需要进行上下文切换，包括保存和恢复进程的寄存器状态、内存映射等信息。
    + 线程：线程的调度也由操作系统内核负责，操作系统会根据线程的优先级和调度算法进行线程的切换。线程的切换同样需要进行上下文切换，但由于线程共享进程的资源，切换开销相对较小。
    + 协程：协程的调度由程序自身控制，在协程中可以通过 yield、await 等关键字主动让出执行权，将执行权交给其他协程。协程的切换只需要保存和恢复协程的栈信息，开销非常小。

一个进程能开多少个协程
一个进程能开启的协程数量没有一个固定的上限，它受到多种因素的影响：

1. 内存限制
虽然协程的内存开销相对较小，但大量的协程仍然会占用一定的内存空间。每个协程都需要保存自己的上下文信息（如栈信息），如果系统内存不足，就无法创建更多的协程。例如，在 Python 的 asyncio 中，每个协程都有自己的栈，当创建大量协程时，栈空间的占用会逐渐增加。

2. CPU 处理能力
虽然协程本身不会占用太多的 CPU 资源，但大量协程的调度和切换也会消耗一定的 CPU 时间。如果 CPU 处理能力有限，过多的协程会导致系统性能下降。例如，在单核 CPU 系统中，过多的协程会导致频繁的上下文切换，增加 CPU 的负担。

3. 操作系统限制
操作系统对进程的资源使用有一定的限制，如最大文件描述符数量、最大线程数等。虽然协程不直接受这些限制的影响，但如果协程需要使用系统资源（如网络连接、文件操作等），这些限制可能会间接影响协程的创建数量。

### 4. c++有没有Gc垃圾回收

C++11 引入了智能指针，包括 std::unique_ptr、std::shared_ptr 和 std::weak_ptr，它们可以自动管理动态分配的内存，避免手动管理内存带来的问题，在一定程度上起到了类似垃圾回收的作用。

第三方垃圾回收库
除了智能指针，也有一些第三方库可以为 C++ 提供垃圾回收功能，例如 Boehm-Demers-Weiser 保守式垃圾回收器（Boehm GC）。

Boehm GC (“贝姆吉西”)
Boehm GC 是一个广泛使用的 C 和 C++ 垃圾回收库，它可以自动检测和回收不再使用的内存。使用 Boehm GC 时，开发者不需要手动调用 new 和 delete，而是使用 GC 提供的内存分配函数。

```cpp
#include <iostream>
#include <gc/gc.h>

int main() {
    // 使用 Boehm GC 分配内存
    int* ptr = (int*)GC_MALLOC(sizeof(int));
    *ptr = 40;
    std::cout << *ptr << std::endl;
    // 不需要手动释放内存，Boehm GC 会自动回收
    return 0;
}
```

底层原理：

Boehm GC 采用的是保守式垃圾回收策略，这意味着它并不精确地知道哪些内存区域是指针，而是通过扫描内存中的值，猜测哪些可能是指针。与之相对的是精确式垃圾回收，精确式垃圾回收器明确知道哪些内存位置是指针。


1. 标记阶段

+ 根集合扫描：垃圾回收的第一步是确定根集合（Root Set），根集合包含了程序中直接可访问的对象，例如全局变量、栈上的变量等。Boehm GC 会从根集合开始，扫描这些根对象所指向的内存地址。
+ 指针猜测与标记：在扫描过程中，Boehm GC 会检查内存中的每个值，猜测它是否是一个指针。由于采用保守式策略，它会把所有可能是指针的值都当作指针处理。对于被认为是指针的值，它会标记该指针所指向的对象为 “存活” 状态。然后，递归地对这些存活对象所指向的其他对象进行同样的标记操作，直到所有可达对象都被标记。

2. 清除阶段
+ 遍历堆内存：标记阶段完成后，Boehm GC 会遍历整个堆内存，检查每个对象的标记状态。
+ 回收未标记对象：那些未被标记为 “存活” 的对象被认为是不可达对象，也就是垃圾对象。Boehm GC 会回收这些垃圾对象所占用的内存空间，将其标记为可用，以便后续的内存分配使用。

关键技术与机制
1. 内存分配
Boehm GC 有自己的内存分配器，当程序需要分配内存时，会调用 Boehm GC 的内存分配函数。它会从预先分配的内存池中分配内存给程序使用。如果内存池中的内存不足，它会向操作系统请求更多的内存。
2. 内存对齐与块管理
为了提高内存访问效率和便于管理，Boehm GC 会对内存进行对齐处理。它将堆内存划分为不同大小的块，每个块可以包含一个或多个对象。在标记和清除过程中，以块为单位进行操作，这样可以减少扫描的粒度，提高回收效率。


### 5. 内存泄漏？怎么检测？如果开发阶段没有问题，但是运行的时候内存泄漏怎么排查定位？

内存泄漏指的是程序在运行过程中，由于某些原因导致已经不再使用的内存没有被及时释放，从而使得可用内存逐渐减少。随着程序的持续运行，内存泄漏可能会导致系统性能下降，甚至引发程序崩溃。在像 C 和 C++ 这类需要手动管理内存的语言中，内存泄漏是比较常见的问题。

使用静态代码分析工具
+ 原理：静态代码分析工具会在不运行代码的情况下，对代码进行语法和语义分析，检查代码中可能存在的内存泄漏问题。
+ 工具示例：
    + Cppcheck：是一个开源的 C/C++ 静态代码分析工具，它可以检查代码中的内存泄漏、未初始化变量等问题。
    + PVS-Studio：商业的静态代码分析工具，功能强大，能够检测出多种复杂的内存泄漏情况。

运行阶段排查定位内存泄漏的方法：

1. 使用内存分析工具
+ Valgrind（适用于 Linux 系统）
    + 原理：Valgrind 是一个强大的内存调试和分析工具，它会在程序运行时对内存的使用情况进行监控。当程序进行内存分配和释放操作时，Valgrind 会记录相关信息，并在程序结束后生成详细的报告，指出可能存在的内存泄漏问题。
    + 使用示例：假设你有一个 C++ 程序 test.cpp，编译生成可执行文件 test 后，可以使用以下命令运行程序并进行内存分析：

```bash
valgrind --leak-check=full ./test
```

报告解读：Valgrind 的报告中会显示哪些内存块没有被正确释放，以及这些内存块是在哪个函数中分配的，帮助你定位问题代码。


> Cppcheck 的使用方法
> cppcheck file1.cpp file2.cpp file3.cpp
> 

### 6.输入url发生什么？

1. DNS 解析
+ 作用：URL 中的域名（如 www.example.com）是方便用户记忆的，但计算机网络通信需要使用 IP 地址。DNS（Domain Name System，域名系统）解析的目的就是将域名转换为对应的 IP 地址。
+ 过程
    + 浏览器缓存：浏览器会先检查自身的 DNS 缓存，看是否已经有该域名对应的 IP 地址。如果有且未过期，就直接使用该 IP 地址。
    + 操作系统缓存：若浏览器缓存中没有，浏览器会向操作系统查询其 DNS 缓存。不同操作系统有不同的 DNS 缓存机制，例如 Windows 可以通过 ipconfig /displaydns 命令查看。
    + 本地 DNS 服务器：如果操作系统缓存中也没有，请求会被发送到本地 DNS 服务器（通常由网络服务提供商提供）。本地 DNS 服务器会检查自己的缓存，如果有则返回结果；如果没有，它会进行递归或迭代查询。
    + 根 DNS 服务器等：本地 DNS 服务器会向根 DNS 服务器、顶级域名 DNS 服务器、权威 DNS 服务器依次查询，最终获取到域名对应的 IP 地址，并将结果返回给浏览器。


2. TCP 连接
+ 作用：HTTP 协议是基于 TCP（Transmission Control Protocol，传输控制协议）的，在进行 HTTP 数据传输之前，需要先建立 TCP 连接。TCP 提供可靠的、面向连接的通信，确保数据在传输过程中不会丢失、乱序。
+ 过程：使用三次握手来建立连接。
    + 客户端发送 SYN 包：客户端向服务器发送一个 SYN（Synchronize Sequence Numbers）包，包含客户端的初始序列号，表明请求建立连接。
    + 服务器发送 SYN + ACK 包：服务器收到 SYN 包后，向客户端发送一个 SYN + ACK 包，包含服务器的初始序列号和对客户端 SYN 包的确认号。
    + 客户端发送 ACK 包：客户端收到 SYN + ACK 包后，向服务器发送一个 ACK（Acknowledgment）包，包含对服务器 SYN 包的确认号，至此 TCP 连接建立成功。

3. HTTP 请求
+ 作用：在 TCP 连接建立后，浏览器会根据输入的 URL 构造 HTTP 请求消息，并发送给服务器。
+ 请求格式：HTTP 请求由请求行、请求头和请求体组成。
    + 请求行：包含请求方法（如 GET、POST 等）、请求的资源路径和 HTTP 版本，例如 GET /index.html HTTP/1.1。
    + 请求头：包含一些附加信息，如用户代理（浏览器类型和版本）、接受的文件类型、缓存控制等。
    + 请求体：对于 GET 请求，请求体通常为空；对于 POST 请求，请求体可以包含要提交的数据，如表单数据。


4. 服务器处理请求
+ 作用：服务器接收到 HTTP 请求后，会对请求进行解析和处理。
+ 过程
    + Web 服务器软件接收请求：常见的 Web 服务器软件有 Apache、Nginx 等，它们负责接收客户端的请求，并将请求转发给相应的应用程序。
    + 应用程序处理请求：服务器端的应用程序（如基于 PHP、Python 的 Django 或 Flask 框架等）会根据请求的内容进行逻辑处理，可能会查询数据库、调用其他服务等。
    + 生成响应：应用程序处理完请求后，会生成一个 HTTP 响应消息。

5. HTTP 响应
+ 作用：服务器将处理结果封装成 HTTP 响应消息，并通过已建立的 TCP 连接发送给客户端。
+ 响应格式：HTTP 响应由状态行、响应头和响应体组成。
    + 状态行：包含 HTTP 版本、状态码和状态消息，例如 HTTP/1.1 200 OK，表示请求成功。
    + 响应头：包含一些附加信息，如响应内容的类型、长度、缓存策略等。
    + 响应体：包含服务器返回的实际数据，如 HTML 页面、图片、JSON 数据等。

6. 浏览器解析渲染页面
+ 作用：浏览器接收到 HTTP 响应后，会根据响应内容进行解析和渲染，将页面呈现给用户。
+ 过程
    + 解析 HTML：浏览器会解析 HTML 文件，构建 DOM（Document Object Model，文档对象模型）树。    
    + 解析 CSS：同时解析 CSS 文件，构建 CSSOM（CSS Object Model，CSS 对象模型）树。
    + 合并渲染树：将 DOM 树和 CSSOM 树合并成渲染树，渲染树只包含需要显示的元素及其样式信息。
    + 布局和绘制：根据渲染树进行布局（确定元素的位置和大小）和绘制（将元素绘制到屏幕上），最终呈现出完整的页面。

7. TCP 连接关闭
+ 作用：当页面资源加载完成后，浏览器和服务器之间的 TCP 连接会关闭，释放系统资源。
+ 过程：使用四次挥手来关闭连接。
    + 客户端发送 FIN 包：客户端向服务器发送一个 FIN（Finish）包，表示请求关闭连接。
    + 服务器发送 ACK 包：服务器收到 FIN 包后，向客户端发送一个 ACK 包，表示确认收到关闭请求。
    + 服务器发送 FIN 包：服务器也向客户端发送一个 FIN 包，表示自己也请求关闭连接。
    + 客户端发送 ACK 包：客户端收到 FIN 包后，向服务器发送一个 ACK 包，表示确认收到服务器的关闭请求，至此 TCP 连接关闭。


