# TCP

TCP基本认识：
  + TCP头格式
  + 为什么需要TCP协议？TCP工作在那一层
  + 什么是TCP
  + TCP连接
  + 如何唯一确定一个TCP连接
  + 有一个IP的服务器监听一个端口，它的TCP最大连接数是多少
  + UDP和TCP有什么区别？分别应用那些场景
  + 为什么UDP头部有包长度字段，而TCP头没有包长度字段

TCP连接建立
  + TCP三次握手过程和状态变迁
  + 如何在linux系统中查看TCP状态
  + 为什么是三次握手？不是两次，四次
  + 为什么每次建立TCP连接时，初始化序列都不一样
  + 初始序列号ISN是如何随机产生的
  + 既然ip层会分片，为什么TCP层还需要MSS
  + 第一次握手丢失了，会发生什么
  + 第二次握手丢失，会发生什么
  + 第三次握手丢失，会发生什么
  + 什么是SYN攻击？如何避免SYN攻击

TCP连接断开
  + TCP四次握手过程和状态变迁
  + 为什么挥手需要四次
  + 第一次挥手丢失了，会发生什么
  + 第二次握手丢失，会发生什么
  + 第三次挥手丢失，会发生什么
  + 第四次挥手丢失，会发生什么
  + 为什么time_wait等待的时间是2msl
  + 为什么需要time_wait状态
  + time_wait过多有什么危害
  + 如何优化time_wait+
  + 如果已经建立了连接，但是客户端突然出现故障怎么办
  + 如果已经建立连接，但是客户端进程崩溃会发生什么

socket编程
  + 针对TCP应该如何Socket编程
  + listen时候参数backlog的含义
  + accept发生在三次握手的那一步
  + 客户端调用close，连接是断开的流程是什么

## Tcp 

> 什么是tcp

TCP 是面向连接的、可靠的、基于字节流的传输层通信协议。

> 如何唯一确定一个tcp连接呢？
四元组：源地址、源端口、目标地址、目标端口

源地址和目标地址（32位）在ip头部，作用是通过 ip 协议发送报文给对方主机；
源端口和目标端口（16位）在TCP头部，作用是告诉TCP协议应该把报文发送给哪个进程；

> 有一个 IP 的服务端监听了一个端口，它的 TCP 的最大连接数是多少？

最大tcp连接数=客户端 ip*客户端端口；

> udp和tcp的区别？应用场景

udp不提供复杂的控制机制，利用ip提高面向无连接的通信服务。

udp协议头部只有8字节：源端口，目标端口，包长度，校验和

> 为什么 UDP 头部没有「首部长度」字段，而 TCP 头部有「首部长度」字段呢？
因为TCP有可变长的选项字段，而UDP头部长度是不会变化的；

> tcp 可以和 udp使用同一个端口吗？

可以的。
在数据链路层中，通过MAC地址来寻找局域网中的主机。在网际层中，通过P地址来寻找网络中互连的
主机或路由器。在传输层中，需要通过端口进行寻址，来识别同一计算机中同时通信的不同应用程序。

所以，传输层的「端口号」的作用，是为了区分同一个主机上不同应用程序的数据包。

传输层有两个传输协议分别是 TCP 和 UDP，在内核中是两个完全独立的软件模块。

> 多个 tcp 服务进程可以绑定同一个端口吗？
如果两个TCP服务进程同时绑定的 ip 地址和端口都相同，那么执行 bind() 时候就会出错，错误是“Address already in use”。

> 为什么是三次握手？不是两次，四次握手？

三次握手才能保证双方具有接收和发送的能力

三次握手的原因：
+ 三次握手可以阻止重复历史连接的初始化（主要原因）
+ 三次握手才可以同步双方的初始序列号
+ 三次握手才可以避免资源浪费


> 为什么每次建立tcp连接时，初始化的序列号都要求不一样？

+ 为了防止历史报文被下一个相同四元组的连接接收

过程：
+ 客户端和服务端建立一个tcp连接，在客户端发送数据包被网络阻塞了，然后超时重传这个数据包，而此时服务端设备断电重启了，之前与客户端建立的连接就消失了，于是在收到客户端的数据包的时候就会发送 rst；
+ 紧接着，客户端又与服务端建立了与上一个连接相同的四元组连接；
+ 在新连接建立完成后，上一个连接中被网络阻塞的数据正好抵达了服务端，刚好该数据包的序列号正好是在服务端的接收窗口内，所以该数据包会被服务端正常接收，就会造成数据错乱。

所以。如果每次建立连接，客户端和和服务端的初始化序列号都是一样的话，很容易出现历史报文被下一个相同四元组的连接接收的问题。

> 什么是 syn攻击？如何避免syn攻击？

我们都知道 TCP 连接建立是需要三次握手，假设攻击者短时间伪造不同 IP 地址的 SYN 报文，服务端每接收到一个 SYN 报文，就进入SYN_RCVD 状态，但服务端发送出去的 ACK + SYN 报文，无法得到未知 IP 主机的 ACK 应答，久而久之就会占满服务端的半连接队列，使得服务端不能为正常用户服务。













