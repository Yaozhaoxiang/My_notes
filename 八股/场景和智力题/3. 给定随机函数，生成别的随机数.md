
> 给定生成1到5的随机数Rand5(),如何得到生产1到7的随机函数Rand7();

思路：

rand5() 它能够等概率生成 1-5 之间的整数。所谓等概率就是1,2,3,4,5 生产的概率均为 0.2 。现在利用rand5(), 构造一个能够等概率生成 1- 7 的方法。

这里有两个特别重要的点，一是 如果 rand5() + rand5(), 我们能够产生一个均匀分布的 1 - 10 吗？ 答案是否定的。比如对于 6来讲（4+2， 2+4， 3+3），它被生成的概率比1 （1+0，0+1）要大。

第二个点就是我们不可能用rand5()直接产生 1- 7 的数，不管你用加减乘除都不行。所以，我们要构造一个更大的范围，使得范围里每一个值被生成的概率是一样的，而且这个范围是7的倍数。

先产生一个均匀分布的 0， 5， 10， 15， 20的数，再产生一个均匀分布的 0， 1， 2， 3，4 的数。相加以后，会产生一个 0到24的数，而且每个数（除0外）生成的概率是一样的。我们只取 1 - 21 这一段，和7 取余以后+1就能得到完全均匀分布的1-7的随机数了。

```cpp
#include <iostream>
#include <cstdlib>
#include <ctime>

// 生成 1 到 5 的随机数
int Rand5() {
    return rand() % 5 + 1;
}

// 生成 1 到 7 的随机数
int Rand7() {
    int num;
    do {
        // 生成 1 到 25 的随机数
        num = (Rand5() - 1) * 5 + Rand5();
    } while (num > 21);  // 只保留 1 到 21 的随机数

    // 将 1 到 21 的随机数映射到 1 到 7 的范围
    return (num - 1) % 7 + 1;
}

int main() {
    // 初始化随机数种子
    srand(static_cast<unsigned int>(time(nullptr)));

    // 测试 Rand7() 函数
    for (int i = 0; i < 10; ++i) {
        std::cout << Rand7() << std::endl;
    }

    return 0;
}
```

为什么要用(rand5() - 1) * 5 + rand5()这个式子来计算，以及用这个式子计算的结果能保证概率相等。 (rand5() - 1) * 5 + rand5(): 当第一个rand5() = 1时，可以产生1，2，3，4，5，每个数产生的概率相等。 当第一个rand5() = 2时，可以产生6，7，8，9，10 每个数产生的概率相等。 当第一个rand5() = 3时，可以产生11，12，13，14，15，每个数产生的概率相等。 当第一个rand5() = 4时，可以产生16，17，18，19，20，每个数产生的概率相等。 当第一个rand5() = 5时，可以产生21，22，23，24，25，每个数产生的概率相等。 第一个rand5()为1，2，3，4，5的概率相等，所以产生的1到25这25个数概率相等，去掉22，23，24，25，剩下的数产生的概率仍然相等。

> 若有rand3（）如何求rand7（）那？

同样的rand3()生成，1，2，3 按3倍数算生成，3，6，9，这时3倍的rand3（）是能生成1…9的数字，即(rand3()-1)*3+rand3(),舍弃大于7的部分就能构造1-7的随机数

第一个rand3()=1时，可以产生1，2，3
第一个rand3()=2时，可以产生4，5，6
第一个rand3()=3时，可以产生7，8，9


> 如果以大的生成器生成更小的生成器那？

当你拥有一个生成范围较大随机数的函数（例如 RandN()，能生成 1 到 N 的随机数），要实现一个生成范围较小随机数的函数（例如 RandM()，能生成 1 到 M 的随机数，其中 M < N）

取模运算：
+ 首先尝试对 RandN() 的结果进行取模操作。将 RandN() 生成的随机数对 M 取模，然后加 1，这样能得到 1 到 M 范围内的一个随机数。不过这种方法存在问题，因为当 N 不是 M 的整数倍时，取模后得到的每个数的概率可能不相等。

+ 筛选合适的结果：
为了保证生成的 1 到 M 每个数的概率相等，需要选取 N 中是 M 整数倍的最大范围。即找到一个最大的 k，使得 k * M <= N。只保留 RandN() 生成结果在 1 到 k * M 范围内的数，对于超出这个范围的数，重新调用 RandN() 生成新的随机数，直到得到符合要求的数。

+ 映射到目标范围：
对于在 1 到 k * M 范围内的随机数，对 M 取模并加 1，就可以等概率地得到 1 到 M 的随机数。

```cpp
#include <iostream>
#include <cstdlib>
#include <ctime>

// 生成 1 到 10 的随机数
int Rand10() {
    return rand() % 10 + 1;
}

// 生成 1 到 7 的随机数
int Rand7() {
    int num;
    do {
        // 生成 1 到 10 的随机数
        num = Rand10();
    } while (num > 7);  // 只保留 1 到 7 的随机数

    return 1+n%7;
}

int main() {
    // 初始化随机数种子
    srand(static_cast<unsigned int>(time(nullptr)));

    // 测试 Rand7() 函数
    for (int i = 0; i < 10; ++i) {
        std::cout << Rand7() << std::endl;
    }

    return 0;
}
```

