# 进程 线程 协程
1.什么是进程，什么是线程？
进程就是应用程序的启动实例。比如我们运行一个游戏，打开一个软件，就是开启了一个进程。
线程从属于进程，是程序的实际执行者。一个进程至少包含一个主线程，也可以有更多的子线程。

进程是资源分配的基本单位，线程是操作系统调度的基本单位。
而无论是进程还是线程，都是由操作系统所管理的

进程和线程：
把内存划分为多块，不同程序使用各自的内存空间互不干扰，这里单独的程序就是一个进程，CPU 可以在多个进程之间切换执行，让 CPU 的利用率变高。

为了实现 CPU 在多个进程之间切换，需要保存进程的上下文（如程序计数器、栈、内核数据结构等等），以便下次切换回来可以恢复执行。还需要一种调度算法，Linux 中采用了基于时间片和优先级的完全公平调度算法。

多进程的出现是为了解决 CPU 利用率的问题，那为什么还需要线程？答案是为了减少上下文切换时的开销

进程和线程在 Linux 中没有本质区别，他们最大的不同就是进程有自己独立的内存空间，而线程（同进程中）是共享内存空间。

在进程切换时需要转换内存地址空间，而线程切换没有这个动作，所以线程切换比进程切换代价更小。

**进程和线程的区别**
**根本区别**区别**：进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位

**在开销方面**：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。

**所处环境**：在操作系统中能同时运行多个进程（程序）；而在同一个进程（程序）中有多个线程同时执行（通过CPU调度，在每个时间片中只有一个线程执行）

**内存分配方面**：系统在运行的时候会为每个进程分配不同的内存空间；而对线程而言，除了CPU外，系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源），线程组之间只能共享资源。

**包含关系**：没有线程的进程可以看做是单线程的，如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。


2.进程和线程的痛点
线程之间是如何进行协作的呢？

最经典的例子就是生产者/消费者模式。若干个生产者线程向队列中写入数据，若干个消费者线程从队列中消费数据。

但上面虽然正确实现了生产者/消费者模式，但并不是一个高性能的实现。为什么性能不高呢？

+ 涉及到同步锁；
+ 涉及到线程阻塞状态和可运行状态之间的切换；
+ 涉及线程的上下文切换；
+ 以上涉及到的任何一点，都是非常耗费性能的操作的。

3.什么是协程呢
协程，是一种比线程更加轻量级的存在。正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程。

最重要的是，协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态中执行）。

这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。

既然协程这么好，它到底是怎么来使用的呢？

协程是一种用户态的轻量级线程。协程的调度完全由用户控制，协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其它地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。


## 
既然协程这么优秀，为什么不彻底替代线程呢？事实上协程和线程完全不是两个相同层面的东西，完全谈不上替代一说，协程可以说是一个独立于线程的功能，它是在线程的基础上，针对某些应用场景进一步发展出来的功能。我们知道，线程在多核的环境下是能做到真正意义上的并行执行的，注意，是并行，不是并发，而协程是为并发而生的。


想象一下业务场景，你需要执行两个互不依赖的sql查询，为了减少等待时间，常规的操作肯定主线程执行sqlB的同时另起一个线程执行sqlA，使两个sql并行执行。然而你会发现，执行两个sql的线程大多数时间只是在等待数据库服务器的响应，线程只是处于阻塞等待状态，而不是疯狂运转，而线程的创建、切换又很消耗系统资源，显然这很浪费。这个时候就该协程大展身手了，你可以在主线程中创建一个协程用于执行sqlB，然后再在主线程中执行sqlA，协程和线程一样，不会阻塞主线程，所以sqlB得到结果后，你可以通过语言的api去看看在协程中的sql执行完毕了没有，如果没有则等待，如果执行完毕了就拿结果，和线程操作几乎一摸一样。至于sqlA和sqlB是否真正在并行执行根本无所谓。为什么呢？ 我们假设执行一个sql需要三步，提交sql、等待、获得结果 ，其中第一步和第三步极省时，只要1毫秒一步，而第二步却要1000毫秒，那么使用并行的多线程执行两个sql，你只要花掉1002毫秒，而使用并发的协程你要花掉1004毫秒，但是线程比协程多消耗一个线程的资源，请问你会为了这2毫秒而选择多线程吗，显然不可能，创建线程的开销都要大于节省下来的时间，这就是协程存在的理由。

而服务器端开发中，大多数时候都是要花大量等待时间的场景，也就是所谓的IO密集，协程极为适合这种场景，而go又主打协程，直接从语法层面支持，切中了以往开发高性能程序太过于复杂的痛点，因此广受程序员们的欢迎。java其实也可以模拟出协程的效果，比如用nio和多线程，也能假装goroutines的效果，但实际操作起来太过于麻烦，还要掌握一大堆枯涩的概念，完全没有goroutines的优雅。所以在并发性能上，go完胜java。换言之，go比java更适应高并发场景，能更优雅方便的写出高并发程序。



