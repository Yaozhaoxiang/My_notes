# 调度算法

+ 进程调度算法
    + 先来先服务调度算法
    + 最短作业优先调度算法
    + 高响应比优先调度算法
    + 时间片轮转调度
    + 最高优先级调度算法
    + 多级反馈队列调度算法

+ 页面调度算法 
    + 最佳页面置换算法（OPT）
    + 先进先出置换算法
    + 最近最久未使用的置换算法LRU
    + 时钟页面置换算法 
    + 最不常用算法 LFU


+ 磁盘调度算法
    + 先来先服务
    + 最短寻道时间优先
    + 扫描算法
    + 循环扫描算法
    + LOOK 与 C-LOOK算法


## 进程调度算法

进程调度算法也称 CPU 调度算法，因为进程是由 CPU 调度的。

什么时候发生CPU调度？
+ 进程从运行状态到等待状态
+ 进程从运行状态到就绪状态
+ 进程从等待状态到就绪状态
+ 进程从运行状态到终止状态

**先来先服务调度算法**：每次从就绪队列中选择最先进入队列的进程，然后一直运行，直到进程退出或被阻塞，才会继续从队列中选择第一个进程；

**最短作业优先调度算法**：优先选择运行时间最短的进程运行，有助于提高系统吞吐量；

**高响应比优先调度算法中**：通过计算每个等待进程的响应比，然后选择响应比最高的进程来执行。 r=1+w/s;
W 是进程在就绪队列中已经等待的时间。S 是进程的服务时间（即该进程需要的 CPU 时间）。

**时间片轮转调度**：每个进程被分配一个时间片，即允许该进程在该时间段中运行；
+ 如果时间片用完，进程还在运行，那么就会把此进程从GPU中释放，并把 CPU 分配另外一个进程；
+ 如果该进程在时间片结束前阻塞或结束，则 CPU 立即进行切换；

时间片通常： 20~50ms

**最高优先级调度算法**：从就绪队列中选择最高优先级的进程进行运行；
进程的优先级分为，静态优先级和动态优先级：
+ 静态优先级：创建进程时候，就已经确定了优先级，然后整个运行时间优先级都不会变化
+ 动态优先级：根据进程的动态变化调整优先级，比如如果进程运行时间增加，则降低其优先级，如果进程等待时间（就绪队列的等待时间）增加，则升高其优先级，也就是随着时间的推移增加等待进程的优先级。

两种处理优先级高的方法，抢占式和非抢占式：
+ 非抢占式：当就绪队列中出现优先级高的进程，运行完当前进程后，再选择优先级高的进程
+ 抢占式：当就绪队列出现优先级高的进程，当前进程挂起，调度优先级高的进程运行

缺点：优先级低的进程永远不会运行

**多级反馈队列调度算法**：是「时间片轮转算法」和「最高优先级算法」的综合和发展。
+ 「多级」表示有多个队列，每个队列优先级从高到低，同时优先级越高时间片越短。
+ 「反馈」表示如果有新的进程加入优先级高的队列时，立刻停止当前正在运行的进程，转而去运行优先级高的队列；

多级反馈队列的基本思想是将就绪队列分成多个不同优先级的队列，每个队列有自己的时间片大小，通常越上面的队列**优先级越高，时间片越小**。当一个新进程到达时，它被放置在最高优先级的队列中；如果一个进程用完了它的时间片而未完成，则被移到下一个较低优先级的队列中；如果较高优先级的队列为空，那么调度器会从较低优先级的队列选择进程执行。

具体实现步骤如下：
+ 创建多个队列：每个队列都有不同的优先级，并且一般情况下，高优先级队列具有较小的时间片。
+ 进程加入最高优先级队列：所有新到的进程首先被放入最高优先级的队列。
+ 按优先级顺序调度：只有当前面所有高优先级队列都空了，才会调度低一级队列中的进程。
+ 时间片到期处理：如果一个进程用完了一个队列的时间片但还未完成，它会被移动到下一个较低优先级的队列中继续执行。
+ 可选的提升机制：一些变种的多级反馈队列可能允许进程由于某些条件（例如长时间等待）而被提升回较高优先级队列。
+ 饥饿预防：为了防止低优先级进程长期得不到CPU时间（即发生饥饿），可以设置一个机制确保它们最终能得到执行的机会。

可以发现，对于短作业可能可以在第一级队列很快被处理完。对于长作业，如果在第一级队列处理不完，可以移入下次队列等待被执行，虽然等待的时间变长了，但是运行时间也会更长了，所以该算法很好的兼顾了长短作业，同时有较好的响应时间。

## 页面调度算法

缺页中断与一般中断的区别：
+ 缺页中断在指令执行期间产生和处理中断信号，而一般中断在一条指令执行完成后检查和处理中断信号；
+ 缺页中断返回该指令的开始重新执行该指令，而一般中断返回回到该指令的下一个指令执行；

缺页中断处理流程：
1. 在cpu里访问一条Load M指令，然后CPU回去找M所对应的页表项
2. 如果该页表项的状态位是有效的，那CPU就可以直接去访问物理内存了，如果状态位是无效的，则cpu会发送缺页中断请求
3. 操作系统收到了缺页中断，则会执行缺页中断处理函数，先会查找该页面在磁盘中的页面位置
4. 找到磁盘中对应的页面后，需要把该页面换入物理内存中，但是在换入前，需要在物理内存中找空闲页，如果找到空闲页，就把页面换入物理内存中
5. 页面从磁盘换入到物理内存完成后，则把页表中的状态修改为有效

页表项通常有如下图的字段：页号，物理页号，状态位，访问字段，修改位，硬盘地址

+ 状态位：用于表示该页是否有效，也就是说是否在物理内存中，供程序访问时参考。
+ 访问字段：用于记录该页在一段时间被访问的次数，供页面置换算法选择出页面时参考。
+ 修改位：表示该页在调入内存后是否有被修改过，由于内存中的每一页都在磁盘上保留一份副本，因此，如果没有修改，在置换该页时就不需要将该页写回到磁盘上，以减少系统的开销；如果已经被修改，则将该页重写到磁盘上，以保证磁盘中所保留的始终是最新的副本。
+ 硬盘地址：用于指出该页在硬盘上的地址，通常是物理块号，供调入该页时使用。

页面置换算法的功能是，当出现缺页异常，需调入新页面而内存已满时，选择被置换的物理页面，

**最佳页面置换算法（OPT）**：置换在「未来」最长时间不访问的页面。最佳页面置换算法作用是为了衡量你的算法的效率，你的算法效率越接近该算法的效率；
**先进先出置换算法**：选择在内存驻留时间很长的页面进行中置换，这个就是「先进先出置换」算法的思想。
**LRU**：选择最长时间没有被访问的页面进行置换；
虽然 LRU 在理论上是可以实现的，但代价很高。为了完全实现 LRU，需要在内存中维护一个所有页面的链表，最近最多使用的页面在表头，最近最少使用的页面在表尾。

困难的是，在每次访问内存时都必须要更新「整个链表」。在链表中找到一个页面，删除它，然后把它移动到表头是一个非常费时的操作。

**时钟页面置换算法（NRU）**：钟页面置换算法就可以两者兼得，它跟 LRU 近似，又是对 FIFO 的一种改进。即能优化置换的次数，也能方便实现的算法

把所有的页面都保存在一个类似钟面的「环形链表」中，一个表针指向最老的页面。

当发生缺页中断时，算法首先检查表针指向的页面：
+ 如果它的访问位位是 0 就淘汰该页面，并把新的页面插入这个位置，然后把表针前移一个位置；
+ 如果访问位是 1 就清除访问位，并把表针前移一个位置，重复这个过程直到找到了一个访问位为 0 的页面为止；

基本步骤如下：

+ 初始化：每个页面都有两个标志位——引用位（R）和修改位（M）。初始时，这两个位通常都被设置为0。
    + 引用位（R）：表示该页面是否在最近一段时间内被访问过。如果页面被访问，则将其置为1。
    + 修改位（M）：表示该页面自上次加载以来是否被修改过。如果页面被写入，则将其置为1。
+ 时钟指针：维护一个指向当前检查页面的指针，称为时钟指针。这个指针会在每次发生页面故障时移动到下一个页面。
+ 页面替换过程：
    + 当发生页面错误且没有空闲帧时，算法从时钟指针所指的位置开始扫描。
    + 如果找到一个引用位为0的页面，则选择该页面作为牺牲页面；否则，将引用位重置为0并继续扫描直到找到合适的页面。
    + 一旦选择了牺牲页面，它会被新的页面替换，并更新相应的状态信息（如引用位和修改位）。
    + 如果牺牲页面被修改过（即修改位为1），则需要将它的内容写回磁盘。
+ 周期性清除引用位：为了防止所有的页面都保持高引用率而无法找到可替换的页面，操作系统可能会定期清除所有页面的引用位，以确保算法能够正常工作。

扩展与改进
+ 二次机会算法（Second Chance）：这是对基础时钟算法的一个简单扩展，其中不仅考虑了引用位，还考虑了页面是否被修改过。如果页面未被修改，则优先选择这些页面进行替换，因为它们不需要写回磁盘，从而减少了I/O操作。

**最不常用算法 LFU**: 当发生缺页中断时，选择「访问次数」最少的那个页面，并将其淘汰。

要增加一个计数器来实现，这个硬件成本是比较高的，另外如果要对这个计数器查找哪个页面访问次数最小，查找链表本身，如果链表长度很大，是非常耗时的，效率不高。

LFU 算法只考虑了频率问题，没考虑时间的问题，比如有些页面在过去时间里访问的频率很高，但是现在已经没有访问了，而当前频繁访问的页面由于没有这些页面访问的次数高，在发生缺页中断时，就会可能会误伤当前刚开始频繁访问，但访问次数还不高的页面。

解决的办法:可以定期减少访问的次数，比如当发生时间中断时，把过去时间访问的页面的访问次数除以 2，也就说，随着时间的流失，以前的高访问次数的页面会慢慢减少，相当于加大了被置换的概率。


## 磁盘调度算法

磁盘调度算法的目的很简单，就是为了提高磁盘的访问性能，一般是通过优化磁盘的访问请求顺序来做到的。

寻道的时间是磁盘访问最耗时的部分;

**先来先服务**：

**最短寻道时间优先算法**：优先选择从当前磁头位置所需寻道时间最短的请求
但这个算法可能存在某些请求的饥饿，假设是一个动态的请求，如果后续来的请求都是小于 183 磁道的，那么 183 磁道可能永远不会被响应，于是就产生了饥饿现象，这里产生饥饿的原因是磁头在一小块区域来回移动。

**扫描算法**：最短寻道时间优先算法会产生饥饿的原因在于：磁头有可能再一个小区域内来回得移动。

为了防止这个问题，可以规定：磁头在一个方向上移动，访问所有未完成的请求，直到磁头到达该方向上的最后磁道，才调换方向。

不会产生饥饿现象，但是存在这样的问题，中间部分的磁道会比较占便宜，中间部分相比其他部分响应的频率会比较多，也就是说每个磁道的响应频率存在差异。
**循环扫描算法**：扫描算法使得每个磁道响应的频率存在差异，那么要优化这个问题的话，可以总是按相同的方向进行扫描，使得每个磁道的响应频率基本一致。

循环扫描（Circular Scan, CSCAN ）规定：只有磁头朝某个特定方向移动时，才处理磁道访问请求，而返回时直接快速移动至最靠边缘的磁道，也就是复位磁头，这个过程是很快的，并且返回中途不处理任何请求，该算法的特点，就是磁道只响应一个方向上的请求。

循环扫描算法相比于扫描算法，对于各个位置磁道响应频率相对比较平均。

**LOOK与C-LOOK算法**：磁头在移动到「最远的请求」位置，然后立即反向移动。
LOOK 算法，它的工作方式，磁头在每个方向上仅仅移动到最远的请求位置，然后立即反向移动，而不需要移动到磁盘的最始端或最末端，反向移动的途中会响应请求。

C-LOOK，它的工作方式，磁头在每个方向上仅仅移动到最远的请求位置，然后立即反向移动，而不需要移动到磁盘的最始端或最末端，反向移动的途中不会响应请求。

























