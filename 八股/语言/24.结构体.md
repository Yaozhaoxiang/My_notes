# 结构体大小
C++中，结构体（struct）的大小不仅仅取决于其成员变量的大小，还受到数据对齐（data alignment）、填充（padding）和编译器优化的影响。

由于存储变量地址对齐的问题，计算结构体大小的3条规则：
1、结构体变量的首地址，必须是结构体变量中的“最大基本数据类型成员所占字节数”的整数倍。（对齐）
2、结构体变量中的**每个成员相对于结构体首地址的偏移量**，都是该成员基本数据类型所占字节的整数倍。（对齐）
3、结构体变量的总大小，为结构体变量中“最大基本数据类型成员所占字节数”的整数倍（补齐）

```cpp
struct Test1
{
	int b;
	double c;	
	long d;
}Test1;
int main()
{
	printf("size = %d\n", sizeof(Test1));
	return 0;
}
```


计算流程:当计算结构体大小时，为了方便计算,初始地址假设为0，int占了4个字节，总开辟的空间为4，因为要和下面的double类型对齐,double的起始地址必须为8，所以绿色部分为因对齐而另开辟的空间，double占了8个字节，所以现在总开辟的是16个字节，long的字 节为4, 16是4的倍数，所以long的起始地址为16，long占了4个字节，此时共开辟了20个字节大小的空间。因为最后面没有类型了，结构体变量的总大小要根据结构体变量中最大基本数据类型对齐，20要跟8对齐，但是20不是8的整数倍，所以在long的后面再开辟4个字节，所以最后一共开辟了24个字节。

## 计算含有数组的结构体大小

计算含有数组的结构体大小时，需要注意的是，如果下一个成员是数组，只有基本元素是char或uchar占一个字节的数组才不需要对齐，但基本元素是int或short等类型的数组是需要对齐的。

```cpp
typedef struct Test2
{
	char c[10];
	char ca[5];
	int a;

}Test2;

int main()
{
	printf("size = %d\n", sizeof(Test2));

	return 0;
}

```

计算流程:起始地址为0，char c[9]占了9个字节的空间，因为下一个成员也是数组，所以不用对齐，直接在地址9这里开辟一个数组char ca[5],占了5个字节，此时是占了14个字节，但是下一个成员是int类型，14不是4的整数倍，所以要从16地址开始存放int a，int占了4个字节，所以总开辟了20个字节，随后，结构体的总大小必须是结构体里最大**基本类型的整数倍**，这里为int 4个字节，20是4的整数倍，不用补齐，所以此结构体最总开辟了20个字节。


## 计算嵌套结构体的大小

```cpp
typedef struct Test3
{
	short a;
	struct
	{
		int b; 
		double c;
		long d;
	};
	int e; 
}Test2;

int main()
{
	printf("size = %d\n", sizeof(Test3));

	return 0;
}

```

计算流程：起始地址位置为0，short类型占了2个字节，下面的一个成员类型为结构体，此时要与嵌套的结构体里**最大的基本类型**，也就是和double 8字节对齐，所以另开辟空间6个，此时地址8是8的倍数，可以存放结构体，这里计算里面的结构体的大小为24，所以8+24=32，所以此时一共占了32个字节空间的大小，最后一个int类型，32是4的整数倍，所以int就直接存在结构体类型的后面，32+4=36，最后要和结构体最大的基本数据类型补齐，里面的结构体的类型也算。所以要与double 8补齐，36不是8的倍数，随后另开辟4个字节空间。所以最后结构体的总大小为40.


## 空结构体

在C++，对于结构体和空类，它们的大小是1

为什么C++中的大小会是1？
C++标准中规定，任何不同的对象不能拥有相同的内存地址。 如果空类大小为0，当我们声明一个这个类的对象数组，那么数组中的每个对象都拥有了相同的地址，这显然是违背标准的。

那么，为什么C++标准中会有这个规定呢？
假设C++中有一个类型T，我们声明一个类型T的数组array,进行如下的运算：
```cpp
T array[5];
int len = &array[4] - &array[0];//输出4
```
面的代码是一种指针运算，将两个指针相减，编译器作出如下面式子所示的动作：
```cpp
len= ((char *)&array[4] - (char *)&array[0]) / sizeof T;
```

如果允许C++对象大小为0，那么这里的运算将产生两个问题：

（1）不能通过指针区分不同的数组对象；
（2）sizeof T为0导致非法的除0操作。

这样一来，编译器还需要用一些复杂的代码来处理这些异常情况信息。


