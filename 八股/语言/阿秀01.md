# 阿秀基础语法 1-21

## 2.结构体内存对齐

+ 结构体内成员按照声明顺序存储，第一个成员地址和整个结构体地址相同。
+ 未特殊说明时，按结构体中size最大的成员对齐（double 按8字节对齐）

## 3. 指针和引用的区别

+ 指针是一个变量，存储的是一个地址，引用跟原来的变量实质是同一个东西，是原变量的别名
+ 指针可以多级，引用只有一级
+ 指针可以为空，引用不能为 null 且在定义时必须初始化
+ 指针在初始化后可以改变指向，而引用在初始化之后不可再改变
+ sizeof指针得到的是本指针的大小，sizeof引用得到的引用所指向的变量大小
+ 当指针作为参数进行传递时，也是将实参的一个拷贝传递给形参，两者指向的地址相同，但不是同一个变量，在函数中改变这个变量的指向不影响实参，而引用可以
+ 在汇编层面，一些编译器将引用当成指针操作，因此引用会占用空间。是否占用空间，应该结合编译分析
+ 引用在声明时必须初始化为另一个变量。引用一旦初始化之后就不可以再改变。

## 4.在传递函数参数时，什么时候该使用指针，什么时候该使用引用

+ 需要返回函数内部局部变量的内存时候用指针。使用指针传参需要开辟内存，用完要释放内存。返回局部变量的引用没有意义
+ 对栈空间大小比较敏感（比如递归）的时候使用引用。使用引用传递不需要创建临时变量，开销小
+ 类对象作为参数的时候使用引用

## 5. 堆和栈的区别

申请方式不同： 栈时由系统自动分配，堆是自己申请和释放
申请效率不同：栈由系统分配，速度快，不会有碎片；堆由程序分配，速度慢，且会有碎片。

## 6. 堆快还是栈快

栈快；
因为操作系统会在底层堆栈提供支持，会分配专门的寄存器存放栈的地址，栈的入栈出栈操作有专门的指令执行，所以栈的效率比较高也快；
而堆的操作由库函数提供的，在分配堆内存的时候需要一定的算法寻找合适大小的内存。并且获取堆的内容需要两次访问，第一次访问指针，第二次根据指针保存的地址访问内存，因此堆比较慢。

## 7. 指针类型

```cpp
int *p[10]
int (*p)[10]
int *p(int)
int (*p)(int)
```

1. `int *p[10]`:
   - 这定义了一个包含10个元素的数组，每个元素都是指向`int`类型的指针。
   - 每个数组元素可以存储一个地址，这个地址指向一个整数。

2. `int (*p)[10]`:
   - 这定义了一个指针，该指针指向一个含有10个`int`类型元素的数组。
   - 指针`p`本身只存储一个地址，这个地址指向一个整数数组的起始位置。

3. `int *p(int)`:
   - 这定义了一个函数原型，说明存在一个名为`p`的函数，它接受一个`int`参数，并返回一个指向`int`类型的指针。
   - 函数调用后返回的是一个指向整数的指针。

4. `int (*p)(int)`:
   - 这定义了一个指向函数的指针，该函数接受一个`int`参数并返回一个`int`值。
   - 指针`p`可以用来存储函数的地址，这样通过`p`就可以调用这个函数。

理解这些声明的关键在于了解操作符的优先级以及括号的作用。例如，在`int *p[10]`中，数组操作符`[]`的优先级高于指针操作符`*`，因此它是先创建一个数组，然后每个元素是指向`int`的指针。而在`int (*p)[10]`中，由于使用了括号`(*)`，它改变了优先级，使得`p`首先被视为一个指针，之后才是指向一个数组。

对于函数指针来说，如`int (*p)(int)`，圆括号`(*)`同样改变了优先级，确保`p`被解析为一个指针，而不仅仅是函数名。如果去掉括号，如`int *p(int)`，则会被解析为一个函数，该函数接受一个`int`参数并返回一个指向`int`的指针。

数组下标操作符 [] 和函数调用操作符 () 的优先级高于指针操作符 *。
括号 ( ) 可以改变优先级，使 * 与左边的操作数结合。

## 8. new/elete 与 malloc/free 

都可以用于内存的动态申请和释放；

不同：
+ 前者是c++运算符，后者是c\c++语言标准库函数
+ new自动计算要分配的空间大小，malloc需要手工计算
+ new是类型安全的，malloc不是

+ new调用 operator new的标准库函数分配足够空间并调用相关对象的构造函数，delete对指针所指对象运行适当的析构函数；然后通过调用名为 operator delete的标准库函数来释放该对象所用内存
+ new是封装了malloc，直接free不会报错，但是这只是释放内存，而不会析构对象

## 9. new和delete是如何实现的

+ new ：首先调用名为 operator new的标准库函数，分配足够大的原始为类型的内存，以保存指定类型的一个对象；接下来运行该类型的一个构造函数，用指定初始化构造对象；最后返回指向新分配并构造后的对象的指针
+ delete：对指针指向的对象运行适当的析构函数；然后通过调用名为operator delete的函数


## 13 宏定义和函数有何区别

+ 宏在预处理阶段完成替换，之后被替换的文本参与编译，相当于直接插入了代码，运行时不存在函数调用，执行起来更快；函数调用在运行时需要跳转到具体的调用函数
+ 宏定义属于在结构中插入代码，没有返回值；函数调用具有返回值
+ 宏定义参数没有类型，不进行类型检查；函数参数具有类型，需要检查类型
+ 宏定义不要在最后加分号

## 14 宏定义 和  typedef区别

+ 宏定义用于定义常量及书写复杂的内容；typedef主要用于定义类型别名
+ 宏替换发生在编译阶段之前，属于文本插入替换；typedef是编译的一部分
+ 宏不检查类型；tupedef会检查数据类型
+ 宏不是语句，不在最后加分号；typedef是语句，要加分号标识结束

## 15. 变量声明和定义

+ 声明仅仅是把变量的声明的位置及类型提供给编译器，并不分配内存空间；定义要在定义的地方为其分配存储空间
+ 相同变量可以在多处声明（外部变量extern），但只能在一处定义

## 16 strlen sizeof区别

+ sizeof是运算符，并不是函数，结果在编译时得到而非运行中获取；strlen是字符处理的库函数
+ sizeof参数可以是任何数据的类型或数据；strlen的参数只能是字符指针且结尾 '\0'的字符串
+ 因为sizeof值在编译时确定，所以不能用来得到动态分配（运行时分配）存储空间

> 指针站多少字节
32位：4字节
64位：8字节

一个指针占用内存的大小跟编译环境有关，而与机器的位数无关；










