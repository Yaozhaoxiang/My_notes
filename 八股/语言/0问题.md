## 内存对齐
一个struct的sizeof的大小由什么决定 : 变量本身和字节对齐；
一个struct中char，int，double类型变量各一个，sizeof是多少: 16；
如果有三个char呢： 3
如果是空的struct，里面什么也没有呢：1


## 继承与虚函数
讲讲虚函数:
虚函数是如何实现的:
虚函数表里有什么:
虚表指针的大小是多少:4
父类和子类的构造和析构函数的调用顺序是怎么样的:构造先夫后子，析构先子后父
### 如果在构造函数中调用虚函数会怎么样：

在C++中，在构造函数或析构函数中调用虚函数的行为有一些特殊的规则。具体来说，当一个对象正在构造或者析构时，虚函数调用不会像平常那样动态绑定到派生类的实现，而是会**绑定到当前构造或析构的对象的类的实现**。这被称为“构造/析构期间的静态绑定”。

构造函数中的虚函数调用
当你在一个基类的构造函数中调用虚函数时，即使该函数在派生类中被重写，这个调用仍然会**调用基类版本的函数**，而不是派生类版本的函数。这是因为在这个时候，派生部分还没有被构造，所以不能访问派生类的成员或虚函数。

```cpp
#include <iostream>

class Base {
public:
    Base() {
        callShow(); // Will call Base::show, not Derived::show
    }
    virtual void show() {
        std::cout << "Base class" << std::endl;
    }
};

class Derived : public Base {
public:
    Derived() {}
    void show() override {
        std::cout << "Derived class" << std::endl;
    }
};

int main() {
    Derived d; // Calls Base constructor, which calls Base::show
    return 0;
}
```


析构函数中的虚函数调用
同样的规则也适用于析构函数。当一个对象被销毁时，它的析构函数按照从派生类到基类的顺序依次调用。因此，在基类的析构函数中调用虚函数时，它只会调用基类版本的函数，因为此时派生类的部分已经被销毁了。


### 如果子类完全没有重写父类的虚函数，那么有几张虚函数表：

在C++中，即使子类没有重写（override）父类的任何虚函数，只要它或者它的任何一个基类定义了至少一个虚函数，那么该子类也会拥有自己的虚拟表（vtable）。

虚函数表的数量
+ 每个类一张虚函数表：每个含有虚函数的类都有自己的虚函数表，这张表包含了指向该类所有虚函数的指针。如果派生类没有重写任何虚函数，它的虚函数表将包含与基类相同的函数指针。

+ 子类继承父类的虚函数表结构：当一个类从另一个类继承时，它会继承基类的虚函数表结构，并且如果它不重写任何虚函数，那么它的虚函数表将与基类的非常相似，只是可能包含额外的成员函数或虚函数（如果有）

独立的虚函数表的重要性
即使 Derived 的虚函数表和 Base 的虚函数表内容相同，它们仍然是两个独立的表。这保证了如果将来 Derived 类添加或重写了新的虚函数，其虚函数表可以正确地反映这些变化，而不会影响到 Base 类的虚函数表。

### 构造函数可以是虚函数吗？析构函数呢

构造函数不能被声明为虚函数。这是因为虚函数的主要目的是支持运行时多态，即通过基类的指针或引用来调用适当的派生类版本的方法。然而，构造函数是在对象创建时调用的，用于初始化对象的状态，在这时尚未完全构建对象的内存模型，因此无法实现虚函数机制所依赖的动态绑定。

析构函数可以并且经常被声明为虚函数，尤其是在你有一个基类和多个派生类，并且你打算通过基类指针或引用删除派生类的对象时。虚析构函数确保了当使用基类指针删除派生类对象时，会正确调用派生类的析构函数，然后才是基类的析构函数，从而保证资源得到正确的清理。



## STL
讲讲vector
vector扩容时，什么情况下不会发生元素的复制？
讲讲map和unordered map的底层实现
算法
A*有什么缺点？什么场景不适合用A*？
什么算法才能求出最短路径？
讲讲迪杰斯特拉的步骤

## OS
进程和线程的区别
线程的通信方式（不会，问能不能说进程的）
进程的通信方式
共享内存是如何实现的
共享内存下，进程是如何做同步的

场景：如何在游戏中实现一个人一边走一边打拳的动画
场景：场景里有很多需要倒计时的东西，如何设计实现倒计时
场景里有上千个倒计时，每帧都需要全部遍历？
如果很多都是短时间的，难以按时间长短区分？






子类的构造函数可以调虚函数吗
内联函数可以是虚函数吗
static 和 const 的区别
new 出来的对象可以用 free 释放吗，会报错吗
面向对象三大特性
线程间通信
锁和信号量的区别
了解优先级反转吗
自旋锁的隐患
线程切换做了什么
挂起和 sleep 的区别

怎么解决内存碎片
页合并怎么做
了解过缓存的实现吗



1.左值右值
2.为什么要有左值右值
3.Move的底层实现
4.智能指针
5.sharedptr的计数是原子量吗
6.原子量怎么实现的
7.讲一下硬中断软中断
8.多核CPU关中断可以保证原子性吗
9.Lambda函数怎么实现的
10.Lambda和bind有什么区别吗
11.sort底层实现
12.什么时候用插入排序
13.长度是多少的时候用插入排序
14.讲一下Map
15.Map为什么不用其他的数据结构实现
16.讲一下内存管理
17.虚拟内存有什么用
18.虚拟内存大于可用的物理内存会发生什么
19.禁止换出到磁盘会发生什么
20.内核的地址是什么
21.用户态可以访问内核吗，为什么
22.讲一下TCP
23.TCP的序号为什么要随机初始化
24.TCP超时重传的是什么，是一个tcp段，还是滑动窗口内的所有tcp段
25.随机初始化能保证可靠传输吗

写一个线程安全的list，
优化锁的粒度，
应该是用手锁来做优化，当时没写出来



