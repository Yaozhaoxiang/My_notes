# 锁

全局锁，表锁，行锁

全局锁： FTWRL
表级锁：
 + 表锁
 + 元数据锁
 + 意向锁
 + AUTO-INC锁
行级锁：
 + Record lock
 + Gap lock
 + next-key lock

## 全局锁

全局锁（Global Lock）是指对整个数据库实例进行锁定，以防止所有表的读写操作。

```sql
FLUSH TABLES WITH READ LOCK;
UNLOCK TABLES;
```

全局锁主要应用于做全库逻辑备份，这样在备份数据库期间，不会因为数据或表结构的更新，而出现备份文件的数据与预期的不一样。

> 全局锁的缺点

全局锁会显著降低数据库的可用性，因为它阻止了所有的写入操作。

> 使用全局锁会影响业务，那有什么其他方式可以避免？

如果数据库支持的事务支持 可重复读的隔离级别， 那么在备份数据之前开启事务，就会创建 read view，然后整个事务执行期间利用mvcc，不影响其他事务的更新操作。

备份数据库的工具是 mysqldump，在使用 mysqldump 时加上 –single-transaction参数的时候，就会在备份数据库之前先开启事务。

## 表级锁

MySQL 里面表级别的锁有这几种：
 + 表锁
 + 元数据锁
 + 意向锁
 + AUTO-INC锁

### 表锁

主要用于防止多个会话同时修改同一张表的数据，从而确保数据的一致性和完整性。

读锁: 允许其他事务读取表中的数据，但阻止它们对该表进行写入操作。
写锁: 不仅阻止其他事务对该表进行写入操作，还阻止它们读取该表的数据。这意味着在同一时间只有一个事务可以持有对某个表的写锁。

```sql
LOCK TABLES t_stu READ;
-- 执行读操作
UNLOCK TABLES;

LOCK TABLES t_stu WRITE;
-- 执行写操作
UNLOCK TABLES;
```

当会话退出后，也会释放所有表锁。

### 元数据锁（Metadata Lock，MDL）

+ 对一张表进行 CRUD 操作时，加的是 MDL 读锁；
+ 对一张表做结构变更操作的时候，加的是 MDL 写锁；

MDL 是在事务提交后才会释放，这意味着事务执行期间，MDL 是一直持有的。


> MDL 不需要显示调用，那它是在什么时候释放的?

MDL 是在事务提交后才会释放，这意味着事务执行期间，MDL 是一直持有的。

当一个长事务申请 mdl读锁，且事务未提交；此时有c事务修改申请 mdl写锁，会阻塞；
那么在线程c阻塞后，后续有对该表的select时，都将会阻塞，如果有大量该表的select语句的请求到来，就会有大量的线程阻塞；

> 为什么线程 C 因为申请不到 MDL 写锁，而导致后续的申请读锁的查询操作也会被阻塞？

这是因为申请 MDL 锁的操作会形成一个队列，队列中写锁获取优先级高于读锁，一旦出现 MDL 写锁等待，会阻塞后续该表的所有 CRUD 操作。

### 意向锁

+ 加锁之前先加上意向锁；


而普通的 select 是不会加行级锁的，普通的 select 语句是利用 MVCC 实现一致性读，是无锁的。

意向共享锁和意向独占锁是表级锁，不会和行级的共享锁和独占锁发生冲突，而且意向锁之间也不会发生冲突，只会和共享表锁（lock tables ... read）和独占表锁（lock tables ... write）发生冲突。

表锁和行锁是满足读读共享、读写互斥、写写互斥的。

意向锁的目的是为了快速判断表里是否有记录被加锁。

### AUTO-INC 锁

表里的主键通常都会设置成自增的，这是通过对主键字段声明 AUTO_INCREMENT 属性实现的。

AUTO-INC 锁是特殊的表锁机制，锁不是再一个事务提交后才释放，而是再执行完插入语句后就会立即释放。





