# 锁

全局锁，表锁，行锁

全局锁： FTWRL
表级锁：
 + 表锁
 + 元数据锁
 + 意向锁
 + AUTO-INC锁
行级锁：
 + Record lock
 + Gap lock
 + next-key lock

## 全局锁

全局锁（Global Lock）是指对整个数据库实例进行锁定，以防止所有表的读写操作。

```sql
FLUSH TABLES WITH READ LOCK;
UNLOCK TABLES;
```

全局锁主要应用于做全库逻辑备份，这样在备份数据库期间，不会因为数据或表结构的更新，而出现备份文件的数据与预期的不一样。

> 全局锁的缺点

全局锁会显著降低数据库的可用性，因为它阻止了所有的写入操作。

> 使用全局锁会影响业务，那有什么其他方式可以避免？

如果数据库支持的事务支持 可重复读的隔离级别， 那么在备份数据之前开启事务，就会创建 read view，然后整个事务执行期间利用mvcc，不影响其他事务的更新操作。

备份数据库的工具是 mysqldump，在使用 mysqldump 时加上 –single-transaction参数的时候，就会在备份数据库之前先开启事务。

## 表级锁

MySQL 里面表级别的锁有这几种：
 + 表锁
 + 元数据锁
 + 意向锁
 + AUTO-INC锁

### 表锁

主要用于防止多个会话同时修改同一张表的数据，从而确保数据的一致性和完整性。

读锁: 允许其他事务读取表中的数据，但阻止它们对该表进行写入操作。
写锁: 不仅阻止其他事务对该表进行写入操作，还阻止它们读取该表的数据。这意味着在同一时间只有一个事务可以持有对某个表的写锁。

```sql
LOCK TABLES t_stu READ;
-- 执行读操作
UNLOCK TABLES;

LOCK TABLES t_stu WRITE;
-- 执行写操作
UNLOCK TABLES;
```

当会话退出后，也会释放所有表锁。

### 元数据锁（Metadata Lock，MDL）

+ 对一张表进行 CRUD 操作时，加的是 MDL 读锁；
+ 对一张表做结构变更操作的时候，加的是 MDL 写锁；

MDL 是在事务提交后才会释放，这意味着事务执行期间，MDL 是一直持有的。


> MDL 不需要显示调用，那它是在什么时候释放的?

MDL 是在事务提交后才会释放，这意味着事务执行期间，MDL 是一直持有的。

当一个长事务申请 mdl读锁，且事务未提交；此时有c事务修改申请 mdl写锁，会阻塞；
那么在线程c阻塞后，后续有对该表的select时，都将会阻塞，如果有大量该表的select语句的请求到来，就会有大量的线程阻塞；

> 为什么线程 C 因为申请不到 MDL 写锁，而导致后续的申请读锁的查询操作也会被阻塞？

这是因为申请 MDL 锁的操作会形成一个队列，队列中写锁获取优先级高于读锁，一旦出现 MDL 写锁等待，会阻塞后续该表的所有 CRUD 操作。

### 意向锁

+ 加锁之前先加上意向锁；


而普通的 select 是不会加行级锁的，普通的 select 语句是利用 MVCC 实现一致性读，是无锁的。

意向共享锁和意向独占锁是表级锁，不会和行级的共享锁和独占锁发生冲突，而且意向锁之间也不会发生冲突，只会和共享表锁（lock tables ... read）和独占表锁（lock tables ... write）发生冲突。

表锁和行锁是满足读读共享、读写互斥、写写互斥的。

意向锁的目的是为了快速判断表里是否有记录被加锁。

### AUTO-INC 锁

表里的主键通常都会设置成自增的，这是通过对主键字段声明 AUTO_INCREMENT 属性实现的。

AUTO-INC 锁是特殊的表锁机制，锁不是再一个事务提交后才释放，而是再执行完插入语句后就会立即释放。


## 乐观锁和悲观锁实现

### 乐观锁

+ 一般通过版本号（Version）机制或时间戳（Timestamp）机制来实现。
+ 版本号机制：在数据库表中增加一个版本号字段，当数据被读取时，同时读取版本号。在更新数据时，将当前读取的版本号与数据库中的版本号进行比较，如果两者相同，则说明数据在读取后没有被其他线程修改过，可以进行更新操作，并将版本号加 1；如果版本号不一致，则说明数据已被其他线程修改，更新操作失败，需要重新读取数据并进行重试。
+ 时间戳机制：与版本号机制类似，不过使用时间戳来记录数据的修改时间。在更新数据时，比较当前时间戳与数据库中记录的时间戳，以判断数据是否被修改。


### 悲观锁：
+ 在数据库层面，通常使用 SELECT... FOR UPDATE 语句来实现。例如在 MySQL 中，执行 SELECT * FROM table_name WHERE id = 1 FOR UPDATE; 语句，此时会锁定满足条件的行数据，其他事务如果要对这些行进行修改或加锁操作，必须等待当前事务释放锁。
+ 在编程语言层面，如 Java 中，可以使用 synchronized 关键字或 ReentrantLock 类来实现悲观锁。synchronized 可以修饰方法或代码块，当一个线程进入被 synchronized 修饰的代码块时，会自动获取锁，其他线程无法同时进入。ReentrantLock 则提供了更灵活的锁控制，如可中断的锁获取、公平锁等特性。











