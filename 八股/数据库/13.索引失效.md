# 索引失效，主要针对联合索引

联合索引排序：先按照第一个索引排序，然后如果相等的再安装第二个索引进行排序；

## 1. 不满足最左匹配原则

在创建联合索引的时候，如： 
 KEY `idx_code_age_name` (`code`,`age`,`name`),

只要在查询的时候有 code 字段，它是索引字段中的第一个字段，也就是最左边的字段。只要有这个字段在，该sql已经就能走索引。

因为在创建索引的时候是按照第一个索引进行排序的。也就是说如果不使用第一个索引，那么后面的索引其实是无序的。

比如，如下将会是无效的,下面会进行扫表
```sql
explain select * from user
 
where age=21;
 
 
explain select * from user
 
where name='周星驰';
 
 
explain select * from user
 
where age=21 and name='周星驰';
```
明以上3种情况不满足最左匹配原则，说白了是因为查询条件中，没有包含给定字段最左边的索引字段，即字段code。

## 2. 使用了select *

如果select语句中的查询列，都是索引列，那么这些列被称为覆盖索引。这种情况下，查询的相关字段都能走索引，索引查询效率相对来说更高一些。

而使用select *查询所有列的数据，大概率会查询非索引列的数据，非索引列不会走索引，查询效率非常低。

## 3. 索引上有计算

## 4. 索引列用了函数

## 5. 字段类型不同

## 7 模糊查询 %

当like语句中的%，出现在查询条件的左边时，索引会失效。

其实很好理解，索引就像字典中的目录。一般目录是按字母或者拼音从小到大，从左到右排序，是有顺序的。

我们在查目录时，通常会先从左边第一个字母进行匹对，如果相同，再匹对左边第二个字母，如果再相同匹对其他的字母，以此类推。

通过这种方式我们能快速锁定一个具体的目录，或者缩小目录的范围。

## 使用or关键字

如果使用了or关键字，那么它前面和后面的字段都要加索引，不然所有的索引都会失效，这是一个大坑。

## 3. 范围查找的右边会失效

`select * from t where a > 1 and b=1`
因为通过查询a后，b是无序的；

但是：
`select * from t_table where a >= 1 and b = 2`

虽然在符合 a>= 1 条件的二级索引记录的范围里，b 字段的值是「无序」的,但是对于符合 a = 1 的二级索引记录的范围里，b 字段的值是「有序」的（因为对于联合索引，是先按照 a 字段的值排序，然后在 a 字段的值相同的情况下，再按照 b 字段的值进行排序）。

于是，在确定需要扫描的二级索引的范围时，当二级索引记录的 a 字段值为 1 时，可以通过 b = 2 条件减少需要扫描的二级索引记录范围（b 字段可以利用联合索引进行索引查询的意思）。
。也就是说，从符合 a = 1 and b = 2 条件的第一条记录开始扫描，而不需要从第一个 a 字段值为 1 的记录开始扫描。

所以，Q2 这条查询语句 a 和 b 字段都用到了联合索引进行索引查询。

https://blog.csdn.net/weixin_46224056/article/details/137597431
