# cmu15445 project0

## Copy-on-Write Trie的整体实现流程。

Trie：
 + 特别适合前缀搜索，能够高效地找到具有相同前缀的所有字符串。
 + 插入和删除操作相对简单，时间复杂度为 O(m)，其中 m 是字符串的长度。

自动完成功能
拼写检查
前缀匹配
词频统计
模糊查询

为什么使用 cow?
对于 Trie 结构来说，如果多个数据结构需要共享相同的前缀或子树，那么通过写时复制技术可以在这些结构之间共享这部分数据，直到某个结构需要修改这部分数据为止。这样可以显著减少内存的使用量。


实现流程：
三个操作：get put delete

要实现：并发键值存储应该能够同时服务多个读者和一个写者。也就是说，当有人在修改 Trie 时，仍然可以对旧根节点执行读取操作。当有人在读取时，也可以执行写入操作，而不需要等待读取完成。

get: 首先获取跟锁，拿到一个root的复制，然后释放，然后根据这个new_root进行查询；因为是拿到一个new_root,所以不影响其他get请求访问；

put: 要确保只有一个线程可以访问，所以执行过程在锁中；首先克隆一个新的root，然后根据键值进行扫描，当不包含一个孩子节点时，则创建；如果这个孩子节点已经存在，则clone这个节点。这样就创建一条新的路径。和原来的路径就不一样了。

remove和put一样；remove通过递归删除；

cow体现在哪里：当多个线程共享这一块数据。如果一个数据修改了，比如说put，那么将创建一个新的root节点，然后插入key和value。而在插入过程中，是在原来的root基础上，进行修改，也就是说插入key那么就重新创建这个key路上的节点，其他的节点不改变。


## 多线程同时修改根节点会发生什么？

多线程同时修改 Copy-on-Write Trie 时首先获取写锁，在整个修改过程中持有写锁。在修改根时会持有 "根" 锁，根锁在修改完根时立即释放。读取时需要获取根锁，读取根后立即释放，不需要申请读锁。

为什么需要持有根锁？
读操作从根开始索引，因此读操作应该从何处开始应该被保护。换言之，根锁保护的不是根，而是指向根的变量。

Copy-on-Write 的优势体现在哪里？ 
Copy-on-Write 保证了每个节点在创建后就不会被修改，这里不考虑根锁的开销，这样做读操作不再需要持有任何锁，它与写操作可以并行。换言之，传统的读写锁策略保证读与读之间是互容的，其余操作都是互斥的；而在 Copy-on-Write 中，它又允许读与写操作之间是互容的。 在整个 Copy-on-Write Trie 中只有写操作之间和获取根是串行的。

传统的读写锁版本需要持有根锁吗？ 
不需要，根的保护可以被包含在整个读写锁版本中。事实上，Copy-on-Write 中的根锁可以是读写锁，但我采用的是互斥锁，两者产生的性能差异不大。






