MVCC就是多版本并发控制。MVCC 是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问。

## 解释下MVCC

innodb默认级别是可重复读，但是不能解决幻读，而mvcc就可以解决幻读。事务管理负责创建事务，每创建一个事务都会给一个读时间戳，其实这个时间戳就是最后一个事务提交的时间戳，可以通过这个时间戳来检查每个事务可以看到那些事务；这样就能确保每个事务在整个生命周期内看到的数据快照是一致的，这意味着即使其他事务对数据进行了修改，也不会影响当前事务所看到的数据。



多版本并发控制，其实指的是一条记录会有多个版本，每次修改记录都会存储这条记录被修改之前的版本，多版本之间串联起来就形成了一条版本链，这样不同时刻启动的事务可以无锁地获得不同版本的数据(普通读)。此时读(普通读)写操作不会阻塞，写操作可以继续写，无非就是多加了一个版本，历史版本记录可供已经启动的事务读取。




## 为什么需要MVCC呢？

数据库通常使用锁来实现隔离性。最原生的锁，锁住一个资源后会禁止其他任何线程访问同一个资源。但是很多应用的一个特点都是读多写少的场景，很多数据的读取次数远大于修改的次数，而读取数据间互相排斥显得不是很必要。所以就使用了一种读写锁的方法，读锁和读锁之间不互斥，而写锁和写锁、读锁都互斥。这样就很大提升了系统的并发能力。之后人们发现并发读还是不够，又提出了能不能让**读写之间也不冲突的方法**，就是读取数据时通过一种类似快照的方式将数据保存下来，这样读锁就和写锁不冲突了，不同的事务session会看到自己特定版本的数据。当然快照是一种概念模型，不同的数据库可能用不同的方式来实现这种功能。

## 事务四种隔离级别?
读未提交、读已提交、可重复读、可串行化

## 什么是读已提交
它只提供了两个保证：不脏读、不脏写。
设想一个事务已经将一些数据写入数据库，但还没有提交。另一个事务可以看到未提交的数据吗？如果是的话，这就叫做脏读。
如果两个事务尝试更新数据库中的相同数据，会发生什么情况？通常后面的写入会覆盖前面的写入。但是，如果先前的写入尚未提交，后面的写入又覆盖了这个尚未提交的值，会怎么样呢？这就叫做脏写。

再总结一次读已提交这种最弱的隔离级别：

从数据库读取时，只能看到已提交的数据（不脏读）。
写入数据库时，只会覆盖已经提交的写入数据（不脏写）

为了防止脏读，每次写入前，数据库都会记住旧值。 当前事务尚未提交时，其他事务的读取都会拿到旧值。当前事务提交后，其他事务才能读取到新值。

为了防止脏写，数据库一般用行锁。当事务想要修改特定的行时，必须先获得该行的锁。一次只有一个事务可持有任何给定行的锁。如果另一个事务要写入同一行，就必须等到第一个事务提交或回滚后。

                       

## MVCC 用来实现哪几个隔离级别？
用来实现**读已提交**和**可重复读**。首先隔离级别如果是读未提交的话，直接读最新版本的数据就行了，压根就不需要保存以前的版本。可串行化隔离级别事务都串行执行了，所以也不需要多版本，因此 MVCC 是用来实现读已提交和可重复读的。

## 那为什么需要 MVCC ？如果没有 MVCC 会怎样？
mvcc就是解决读写冲突的，之前使用读写锁来解决读读冲突，但是不能解决读写冲突。
如果没有 MVCC **读写操作之间就会冲突**。想象一下有一个事务1正在执行，此时一个事务2修改了记录A，还未提交，此时事务1要读取记录A，因为事务2还未提交，所以事务1无法读取最新的记录A，不然就是发生脏读的情况，所以应该读记录A被事务2修改之前的数据，但是记录A已经被事务2改了呀，所以事务1咋办？只能用锁阻塞等待事务2的提交，这种实现叫 LBCC(Lock-Based Concurrent Control)。

如果有多版本的话，就不一样了。事务2修改的记录 A，还未提交，但是记录 A 被修改之前的版本还在，此时事务1就可以读取之前的版本数据，这样读写之间就不会阻塞啦，所以说 MVCC 提高了事务的并发度，提升数据库的性能。


## 对多版本有没有别的理解
实际上 InnoDB 不会真的存储了多个版本的数据，而只是维护一个增量，只是借助 undolog 记录每次写操作的反向操作，所以索引上对应的记录只会有一个版本，即最新版本。只不过可以根据 undolog 中的记录反向操作得到数据的历史版本，所以看起来是多个版本。


## MVCC怎么实现？
为每个事务将被分配两个时间戳：读取时间戳和提交时间戳。

**读取时间戳**决定了当前事务可以看到的版本。例如，如果一个事务的读取时间戳为 3，它将看到 A3、B3、C2 和 D3。如果读取时间戳为 2，它将看到 A2、B1 和 C2。当一个事务开始时，**读取时间戳将是最新提交事务的时间戳**，这样事务就能看到在其开始之前提交的所有内容。

**提交时间戳**是事务提交的时间。它是一个 逻辑计数器 ，每次事务提交时增加 1。数据库管理系统（DBMS）在修改数据库中的元组时将使用事务的提交时间戳。例如，D3 元组是由提交时间戳为 3 的事务写入的。

在三个地方存储事务数据：表堆、事务管理器和每个事务内部。表堆始终包含**最新的数据**，事务管理器的“页面版本信息”**存储指向下一个修改的指针**，而在每个事务内部，我们以称为**撤消日志的格式存储事务修改的元组**。要检索给定读取时间戳的元组，你需要 (1) 获取所有在给定时间戳之后发生的修改（即撤消日志），并 (2) 将这些修改（“撤消”撤消日志）应用于元组的最新版本，以恢复元组的过去版本。

然后根据元组重建算法进行重建；

比如说 insert和delete，update算子；
insert：就是 表堆中的**时间戳应设置为事务的临时时间戳**。你不需要修改版本链接，该元组的下一个版本链接应为 nullopt，表示该元组没有先前的版本。


其中**更新执行器将元组的新版本放入表堆，而删除执行器在表堆中设置 is_delete 标志**。
在更新或删除元组之前，你需要**检查写-写冲突**。如果一个元组正在被未提交的事务修改，其他事务不允许修改它，如果它们这样做，就会发生写-写冲突，与前一个事务冲突的事务应被中止。另一种写-写冲突的情况是，事务 A 删除一个元组并提交，而另一个在 A 之前开始的事务 B 删除同一个元组（写入的时间戳大于读取时间戳）。当检测到写-写冲突时，事务状态应设置为 **TAINTED**，并且你需要抛出 ExecutionException 以标记 SQL 语句执行失败（ExecuteSqlTxn 返回 false 如果有执行异常）


当所有的事务停止时，将自动触发GC垃圾收集。我们需要根据Task1实现的Watermark获取最小read ts. 接着遍历table heap, 获取tuple的RID. 通过RID获取tuple的VersionLink(GetUndoLink()), 你需要遍历tuple的undo log, 如果undo log ts < watermark, 将undo log的is_delete置为true.
最后通过txn_map_遍历所有txn，如果txn的所有undo log被删除，则将txn从txn_map_中移除. 但是你不能删除未提交(COMMITTED)的txn


##  undolog 算是热点资源，多个事务不就会争抢 undolog 了吗？
对呀，所以为了提高 undolog 的写入性能，每个事务都有属于自己的 undolog 页面链表，这样就提高了写入并发度啦，再细一点就是 insert 类型的 undolog 和 update 类型的 undolog 属于不同的链表。

## 对了，你上面说 insert 和 update ，那 delete 呢？
delete 其实是属于 update 的，不过分了好几种情况，反正 delete 只会给记录上打个标记，表明这条记录被删除了，不会马上删除这条记录，因为记录还得存着给别的事务作为版本链访问呢。

## 那这条被删除的记录就永远存在了？
不会的，后台有一个 purge 线程，如果探测出当前没有事务会访问这个记录了，就会把它真正的删除。
垃圾回收；




