## 聚簇索引和非聚簇索引

MySQL的InnoDB索引数据结构是B+树，**主键索引叶子节点的值存储的就是MySQL的数据行**，普通索引的叶子节点的值存储的是**主键值**，这是了解聚簇索引和非聚簇索引的前提

什么是聚簇索引？
很简单记住一句话：找到了索引就找到了需要的数据，那么这个索引就是聚簇索引，所以主键就是聚簇索引，修改聚簇索引其实就是修改主键。

什么是非聚簇索引？
**索引的存储和数据的存储是分离**的，也就是说找到了索引但没找到数据，需要根据索引上的值(主键)再次回表查询,非聚簇索引也叫做辅助索引。

聚集索引⼀个表只能有⼀个，⽽⾮聚集索引⼀个表可以存在多个。聚集索引存储记录是物理上连续存在，⽽⾮聚集索引是逻辑上的连续，物理存储并不连续。

**辅助索引**访问数据总是需要二次查找，第一次找到主键值，第二次根据主键值找到行数据：
+ 辅助索引叶子节点存储的不再是行的物理位置，**而是主键值**。
+ 通过辅助索引首先找到的是主键值，再通过主键值找到数据行的数据页，再通过数据页中的Page Directory找到数据行。

### 一个例子
```sql
create table student (
    id bigint,
    no varchar(20) ,
    name varchar(20) ,
    address varchar(20) ,
    PRIMARY KEY (`branch_id`) USING BTREE,
    UNIQUE KEY `idx_no` (`no`) USING BTREE
)ENGINE=InnoDB DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC;
```

第一种，直接根据主键查询获取所有字段数据，此时主键是聚簇索引，因为主键对应的索引叶子节点存储了id=1的所有字段的值。

`select * from student where id = 1`

第二种，根据编号查询编号和名称，编号本身是一个唯一索引，但查询的列包含了学生编号和学生名称，当命中编号索引时，该索引的节点的数据存储的是主键ID，需要根据主键ID重新查询一次，所以这种查询下no不是聚簇索引

`select no,name from student where no = 'test'`

第三种，我们**根据编号查询编号**（有人会问知道编号了还要查询？要，你可能需要验证该编号在数据库中是否存在），这种查询命中编号索引时，直接返回编号，因为所需要的数据就是该索引，不需要回表查询，这种场景下no是聚簇索引

`select no from student where no = 'test'`

主键一定是聚簇索引，MySQL的InnoDB中一定有主键，即便研发人员不手动设置，则会使用unique索引，没有unique索引，则会使用数据库内部的一个行的id来当作主键索引,其它普通索引需要区分SQL场景，当SQL查询的列就是索引本身时，我们称这种场景下该普通索引也可以叫做聚簇索引，MyisAM引擎没有聚簇索引。

### 聚簇索引的优势

**数据访问更快**：
+ 由于行数据和叶子节点存储在一起，同一页中会有多条数据，访问同一数据的不同行记录时，已经把也加载到了Buffer中，再次访问的时候，会在内存中完成访问，不必访问磁盘.这样由于主键和行数据时一起被载入磁盘的，找到叶子节点就可以立即将行数据返回了，如果按照主键ID来组织数据，获得数据更快

+ 聚簇索引适合用在排序的场合，非聚簇索引不适合：
聚簇索引中，数据是按照索引键的顺序物理存储的。这意味着，如果按照聚簇索引的键进行排序查询，数据库不需要额外的排序操作，因为数据本身已经是有序的。

例如，有一个订单表，按照订单号建立了聚簇索引。当需要按照订单号升序或降序获取订单信息时，数据库可以直接按照存储顺序读取数据，效率很高。

而非聚簇索引中，索引的叶子节点存储的是指向数据的指针，**数据本身的存储顺序与索引键的顺序无关**。当基于非聚簇索引进行排序查询时，数据库首先需要通过索引找到数据的指针，然后再根据指针获取数据，并在内存中进行排序操作。这增加了额外的开销，效率相对较低。

假设一个客户表，以客户 ID 建立了非聚簇索引，而数据按照注册时间存储。如果要按照客户 ID 排序获取客户信息，数据库需要先通过非聚簇索引找到数据指针，再获取数据并排序

+ 可以把相关数据保存在一起：
以电子邮箱为例，如果按照用户 ID 建立了聚簇索引，那么属于同一个用户的所有邮件数据在物理存储上会靠在一起。当您要获取某个用户的全部邮件时，只需要从磁盘读取相对较少的数据页就行。

但如果没有使用聚簇索引，每个邮件可能在磁盘上随机分布，那么获取每一封邮件都可能需要单独从磁盘读取一次，这会大大增加磁盘操作的次数，降低效率。

### 非聚簇索引的优势

如果辅助索引使用地址值作为指针，会存在一些问题。当数据库中的行发生移动，比如由于插入或删除操作导致 B+树节点分裂，或者数据页分裂时，原来存储的地址值就可能变得无效或者不准确。为了保持辅助索引的正确性，数据库就需要花费额外的资源和时间去更新这些地址指针，这就增加了辅助索引的维护工作，会影响数据库的性能。

然而，如果辅助索引使用**主键作为“指针”，**情况就有所不同（实际就是这个）。虽然这样做会使得辅助索引占用更多的空间，因为主键通常比地址值占用更多字节。但换来的好处是显著的。

在 InnoDB 存储引擎中，行的位置实际上是通过 16K 的 Page 来定位的。随着数据库中数据的不断修改，比如频繁的插入、删除操作，可能会导致前面提到的 B+树节点分裂以及 Page 的分裂。这就会使得行的实际存储位置发生变化。

但因为辅助索引使用的是主键值作为指针，只要主键值本身不变，无论主键所在的 B+树节点如何变化，辅助索引都无需更新这个“指针”。

再进一步说，当使用聚簇索引时，由于聚簇索引决定了数据的物理存储顺序，并且主键是聚簇索引的一部分。所以，即使聚簇索引中的主键 B+树节点发生了变化，只要主键值不变，辅助索引树就能够保持稳定，不受这些变化的影响。



