什么是火山模型

火山模型是数据库界已经很成熟的解释计算模型，该计算模型将关系代数中每一种操作抽象为一个 Operator，将整个 SQL 构建成一个 Operator 树，从根节点到叶子结点自上而下地递归调用 next() 函数。

每个算子都有 Init() 和 Next() 两个方法。Init() 对算子进行初始化工作。Next() 则是向下层算子请求下一条数据。当 Next() 返回 false 时，则代表下层算子已经没有剩余数据，迭代结束。可以看到，火山模型一次调用请求一条数据，占用内存较小，但函数调用开销大，特别是**虚函数调用造成** cache miss 等问题。


火山模型的优缺点

可以看出火山模型的优点在于：简单，每个 Operator 可以单独抽象实现、不需要关心其他 Operator 的逻辑。

那么缺点呢？也够明显吧？每次都是计算一个 tuple（Tuple-at-a-time），这样会造成多次调用 next ，也就是造成大量的**虚函数调用**，这样会造成 CPU 的利用率不高。

虚函数调用开销：
在火山模型中，每个操作符都是一个对象，通常继承自一个基类（如 Iterator）。基类定义了一个虚函数 next()，每个具体的操作符类实现了这个虚函数。
每次调用 next() 方法时，都需要进行虚函数调用，这涉及到动态绑定和间接跳转，增加了运行时开销。
对于大规模数据处理和高并发查询，这些额外的开销可能会显著影响性能。

### 虚函数调用开销

内存消耗
每个包含虚函数的类都会有一个指向虚函数表（vtable）的指针，通常称为 vptr。这个指针在每个对象实例中都占用一定的内存空间。此外，虚函数表本身也需要占用一些内存来存储类的所有虚函数的地址。

时间消耗
当调用虚函数时，程序需要通过 vptr 查找并调用正确的函数版本。这个查找过程涉及到两次间接寻址：
1. 通过对象的 vptr 访问其对应的虚函数表。
2. 在虚函数表中找到相应的函数地址。

### 虚函数调用可能导致缓存未命中（cache miss）

虚函数调用可能导致缓存未命中（cache miss）是因为C++的虚函数机制依赖于虚函数表（vtable），这是一种**运行时多态性的实现方式**。当一个对象通过指针或引用调用其虚函数时，编译器不能在编译时确定确切要调用哪个函数版本，因此它必须在运行时通过对象的虚函数表来查找正确的函数地址。

缓存未命中（Cache Miss）
计算机的CPU为了提高访问内存的速度，使用了多级缓存（如L1, L2, L3）。这些缓存存储了最近使用的数据和指令副本，以便快速访问。当CPU请求的数据或指令已经在缓存中时，这称为缓存命中（cache hit），可以快速获取。而如果不在缓存中，则需要从更慢的主存中读取，这就是缓存未命中（cache miss），会导致性能下降，因为需要等待更长时间才能得到所需的数据或指令。

虚函数与缓存
对于虚函数调用来说，每次调用都会涉及到两次间接寻址：
1. 通过对象的 vptr 访问虚函数表。
2. 在虚函数表中找到相应的函数地址。
这两个步骤中的任何一个都可能导致缓存未命中，尤其是当**不同的对象实例分散在内存的不同位置时**，它们的虚函数表可能也会分布在不同的地方，从而增加了缓存失效的概率。此外，如果程序频繁地调用不同的虚函数，那么虚函数表本身也可能不会很好地驻留在缓存中，进一步增加缓存未命中的可能性。






## 优化方向

火山模型中一次只取一条数据，如果每次取多条数据呢？貌似可行啊，因为可以将每次 next 带来的 CPU 开销被一组数据给分摊。这样当 CPU 访问元组中的某个列时会将该元组加载到 CPU Cache（如果该元组大小小于 CPU Cache 缓存行的大小）, 访问后继的列将直接从 CPU Cache 中获取，从而具有较高的 CPU Cache 命中率，然而如果只访问一个列或者少数几个列时 CPU 命中率仍然不理想。另外，我们再想想什么时候可以做到取多条数据同时计算呢？当然是同一列的时候，所以针对的是列存的场景，因为输入是同列的一组数据，面对的是相同的操作，这正是向量寄存器干的事情，这是 CPU 层面计算性能的优化，因此称为向量化。并且如果每次只取一列的部分数据，返回一个可以放到 CPU Cache 的向量，那么又可以利用到 CPU Cache。

向量化计算就是将一个循环处理一个数组的时候每次处理 1 个数据共处理 N 次，转化为向量化——每次同时处理 8 个数据共处理 N/8 次，其中依赖的技术就是 SIMD（Single Instruction Multiple Data，单指令流多数据流），SIMD 可以在一条 CPU 指令上处理 2、4、8 或者更多份的数据。







