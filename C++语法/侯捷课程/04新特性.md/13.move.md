# 13. std::move

1. std::move
<utility>

std::move 是 C++11 引入的一个标准库函数，用于**将对象显式地转换为右值引用，以便触发移动语义，而不是拷贝语义**。它不会实际地移动对象，而是通过类型转换让编译器知道你希望使用移动构造函数或移动赋值运算符。从实现上讲，std::move基本等同于一个类型转换：static_cast<T&&>(lvalue);

std::move 的作用
  1. 启用移动语义: std::move 将一个左值（可被赋值的对象）转换为右值引用，从而触发移动语义。移动语义允许资源的所有权从一个对象转移到另一个对象，而不是复制资源。

  2. 避免不必要的复制: 当你想要避免对象的拷贝操作并希望直接转移资源时，使用 std::move 可以显著提高性能。例如，将一个对象从一个容器移动到另一个容器时，可以避免复制所有元素的开销。

1. C++ 标准库使用比如vector::push_back 等这类函数时,会对参数的对象进行复制,连数据也会复制.这就会造成对象内存的额外创建, 本来原意是想把参数push_back进去就行了,通过std::move，可以避免不必要的拷贝操作。
2. std::move是将对象的状态或者所有权从一个对象转移到另一个对象，只是转移，没有内存的搬迁或者内存拷贝所以可以提高利用效率,改善性能.。
3. 对指针类型的标准库对象并不需要这么做.

### std::move 的使用场景

1. 传递函数参数: 当你将一个对象传递给一个接受右值引用的函数时，可以使用 std::move 将对象转换为右值引用，从而触发移动构造函数。
```cpp
void process(std::string&& str) {
    // 处理字符串
}

std::string s = "Hello, World!";
process(std::move(s));  // 触发移动构造，避免拷贝
```
2. 返回局部对象: 当函数返回一个局部对象时，你可以使用 std::move 将对象转换为右值，以触发移动语义，避免对象的拷贝。
```cpp
std::vector<int> createVector() {
    std::vector<int> v = {1, 2, 3, 4};
    return std::move(v);  // 触发移动构造，避免拷贝
}
```
3. 在容器中移动对象: 当你从容器中移除元素并希望避免拷贝时，可以使用 std::move。
```cpp
std::vector<std::string> v1 = {"one", "two", "three"};
std::vector<std::string> v2;
v2.push_back(std::move(v1[0]));  // 将元素从 v1 移动到 v2，避免拷贝

```

std::move 的注意事项
  1. 被移动对象不可再用: 在调用 std::move 之后，源对象进入一种“被移动”的状态，通常不应再使用这个对象，除非你知道它的状态并加以处理。

  2. 不要滥用 std::move: std::move 不会真正移动对象，而是告诉编译器这个对象可以被移动。只有在明确需要移动语义时才使用它，不要随便将所有对象都转换为右值引用，否则可能导致不期望的行为。



std::move 的函数原型定义
```cpp
template <typename T>
typename remove_reference<T>::type&& move(T&& t)
{
	return static_cast<typename remove_reference<T>::type&&>(t);
```


## 2. 引用折叠：
引用折叠（Reference Collapsing）是C++11引入的一种规则，它决定了当多个引用类型组合在一起时，最终的引用类型会是什么。

### 2.1 引用折叠规则

引用折叠规则描述了当我们把引用的引用组合在一起时，最终的引用类型是如何确定的。具体规则如下：

 1. T& & 折叠为 T&
 2. T& && 折叠为 T&
 3. T&& & 折叠为 T&
 4. T&& && 折叠为 T&&

### 2.2. 具体解释:
  左值引用（&）在组合时具有优先权，因此无论是左值引用叠加左值引用、右值引用叠加左值引用，还是反过来，结果都是左值引用。

  只有当两个右值引用组合在一起时，结果才会是右值引用。

示例：
在模板编程中，引用折叠经常出现在通过模板参数转发的场景中。例如
```cpp
template<typename T>
void foo(T&& arg) {
    bar(std::forward<T>(arg));
}
```
这里，T&&是一个万能引用（也称为转发引用），它可以是左值引用或右值引用。在这种情况下，引用折叠决定了T&&与传递的实际参数类型如何结合。
  
  如果T是int&，那么T&&折叠为int&（根据规则2）。
  如果T是int&&，那么T&&保持为int&&（根据规则4）。

### 2.3 为什么引用折叠重要？
  
  引用折叠在模板编程中是至关重要的，特别是实现高效的泛型代码时。它使得通过模板实现的代码能够自动处理不同类型的引用（左值引用、右值引用），从而避免不必要的拷贝并保持代码的高效性。

### 2.4 为什么不会直接写 T& &？

在实际的C++代码中，你不会显式地写出T& &这种形式，因为C++标准明确规定了引用不能引用另一个引用。然而，在模板编程或类型推导的过程中，可能会间接生成类似T& &的情况。

举例说明
假设有一个模板函数：
```cpp
template<typename T>
void foo(T& t) {
    // ...
}

int x = 5;
int& ref = x;
foo(ref);

```
在这个例子中，T被推导为int&，因此函数签名变成了void foo(int& & t)。根据引用折叠规则，int& &会折叠为int&。

为什么不会直接写 T& &？
  
  因为C++不允许创建引用的引用（即T& &或T&& &等形式），编译器在遇到这种情况时会自动应用引用折叠规则。因此，你无法直接声明这样的类型，编译器会在需要时为你折叠成合法的引用类型。


## 3. 万能引用
### 3.1. 万能引用的定义
  万能引用是一种模板参数推导时，形如T&&的引用类型。在这种情况下，T&&可以匹配传入的左值或者右值，成为一个左值引用或右值引用

```cpp
template <typename T>
void foo(T&& arg) {
    // arg 是万能引用
}

```
### 3.2. 万能引用的工作机制
  如果传入的是左值：T会被推导为左值引用类型（T&），因此T&&会折叠为T& &，根据引用折叠规则，T& &会折叠为T&。这意味着函数参数会变成左值引用。

  如果传入的是右值：T会被推导为右值引用类型，T&&保持为右值引用。这意味着函数参数会变成右值引用  
```cpp
int x = 10;
foo(x);  // 传入左值，T被推导为int&，foo(int& arg)
foo(10); // 传入右值，T被推导为int，foo(int&& arg)

```

### 3.3. 万能引用的作用
  完美转发（Perfect Forwarding）：这是万能引用的主要用途。完美转发指的是将函数参数以其原本的左值或右值属性转发给另一个函数，而不改变它的值类别。
```cpp
template <typename T>
void wrapper(T&& arg) {
    foo(std::forward<T>(arg));  // 完美转发
}

```
std::forward<T>(arg)会根据T的类型决定是使用std::move（转发右值）还是保持左值属性，从而实现完美转发。

### 3.4. 万能引用与右值引用的区别

右值引用：当你显式地使用T&&作为函数参数，而不是模板参数推导时，它只接受右值。例如：
```cpp
void bar(int&& arg);  // 只能接受右值

```
万能引用：当T&&出现在模板函数中且T是由模板参数推导得到的，它才可能是万能引用。此时，它既能接受左值，也能接受右值

### 3.5如何识别万能引用

万能引用通常符合以下条件：

  模板参数推导：T是模板参数，并且T&&是通过模板推导得到的。
  出现形式：函数参数形式为T&&。

如果满足这两个条件，那么你可以把T&&看作是万能引用。





