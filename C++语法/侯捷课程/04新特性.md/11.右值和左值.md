## 1. 左值和右值
1. 左值（lvalue） : local value
左值 是指能够在程序的整个生命周期中持有或引用一个对象的内存地址的表达式。换句话说，左值是指向某个内存位置的表达式，通常可以用在赋值语句的左侧。

特点：
  可以获取它的地址（通过 & 运算符）。
  可以被赋值或修改。
  左值在内存中有明确的存储位置。

2. 右值（rvalue） : read value
右值 是指不具有持久地址的临时对象或表达式，通常出现在赋值语句的右侧。右值不能直接获取其地址，也不能被赋值或修改。

特点：
  右值是临时的，没有明确的存储位置。
  通常是表达式的计算结果，生命周期很短。
  右值不能作为左值引用的目标。

3. 左值和右值的区别
  左值 表示可以持续存在的对象，能够取地址，并且通常能被赋值。
  右值 是临时的，通常不能取地址，也不能被赋值。

4. 左值引用和右值引用
C++ 中有两种引用类型：
  左值引用（lvalue reference）：用 T& 声明，可以绑定到左值。
  右值引用（rvalue reference）：用 T&& 声明，可以绑定到右值。

1、左值和右值的概念
    左值是可以放在赋值号左边可以被赋值的值；左值必须要在内存中有实体；
    右值当在赋值号右边取出值赋给其他变量的值；右值可以在内存也可以在CPU寄存器。
    一个对象被用作右值时，使用的是它的内容(值)，被当作左值时，使用的是它的地址。
2、引用

    引用是C++语法做的优化，引用的本质还是靠指针来实现的。引用相当于变量的别名。

    引用可以改变指针的指向，还可以改变指针所指向的值。

    引用的基本规则：

    声明引用的时候必须初始化，且一旦绑定，不可把引用绑定到其他对象；即引用必须初始化，不能对引用重定义；
    对引用的一切操作，就相当于对原对象的操作。

## 2. & 与 &&
在C++11之前就有引用“&”，但是此种引用有一个缺陷，即正常情况下只能操作 C++ 中的左值，无法对右值添加引用。

右值往往是没有名称的，因此要使用它只能借助引用的方式。这就产生一个问题，实际开发中我们可能需要对右值进行修改（实现移动语义时就需要），显然左值引用的方式是行不通的。

为此，C++11 标准新引入了另一种引用方式，称为右值引用，用 "&&" 表示

这种形式的右值引用并没有实际用处。一方面，右值引用主要用于**移动语义和完美转发**，其中前者需要有修改右值的权限；其次，常量右值引用的作用就是引用一个不可修改的右值，这项工作完全可以交给常量左值引用完成。

总结：
1. 非常量左值引用可以引用的值的类型只有非常量左值；常量左值引用非常量左值、常量左值及右值
```cpp
	int num = 10;
	int& a = num;	//编译成功，非常量左值引用支持引用非常量左值
	const int num2 = 100;
	int& b = num2;	//编译失败，非常量左值引用不支持引用常量左值
	int& c = 10;	//编译失败，非常量左值引用不支持引用右值
 
	const int& d = num;		//编译成功，常量左值引用支持引用非常量左值
	const int& e = num2;	//编译成功，常量左值引用支持引用常量左值
	const int& f = 100;		//编译成功，常量左值引用支持引用右值
```
2. 右值引用不支持引用左值；非常量右值引用可以引用的值的类型**只有**非常量右值，常量右值引用非常量右值、常量右值
```cpp
	int num = 10;
	const int num2 = 100;
	int&& a = num;	//编译失败，非常量右值引用不支持引用非常量左值
	int&& b = num2;	//编译失败，非常量右值引用不支持引用常量左值
	int&& c =10;	//编译成功，非常量右值引用支持引用非常量右值
	const int&& d = num;	//编译失败，常量右值引用不支持引用非常量左值
	const int&& e = num2;	//编译失败，常量右值引用不支持引用常量左值
	const int&& f = 100;	//编译成功，常量右值引用支持引用右值
```
## 3. 右值引用
拷贝方法：
  + 深拷贝：用一块新内存，存储要拷贝的内容
  + 浅拷贝：用指针指向要拷贝的内容，相当于两个指针指向同一内存
  + move(变量)：用指针指向要拷贝的内容，但删除原来指向该目标内存的指针，即最终只有当前指针指向目标内容块 -> 多用于右值引用，但当某左值确定不再使用时，也可以用这种方式copy

右值引用：即用 move 的方法拷贝右值元素，多用于拷贝临时对象 `e.g insert(...&&x); //x为临时对象`

>Question: string() = "world";s1+s2 = s2;不报错，如何解释？？

![](../图片/新特性_18.png)

```cpp
int foo() { return 5;}
...
int x = foo(); //ok x=5
int *p = &foo();  //[error] 以前不行 不能对右值取引用 int *p = &foo; 可以通过编译，相当于取函数地址
									//c++11就不报错了 相当于取右值的引用
foo() = 7; //同上
```
![](../图片/新特性_19.png)

跟随右值引用出现的 新的拷贝赋值方式：

![](../图片/新特性_20.png)

Perfect Forwarding 完美转交,其实就是万能引用（在move.md中写了）

![Perfect Forwarding](../图片/新特性_21.png)

不完美引用，为什么会调用`void process(int& i)`呢？
   当你调用forward(2);时，2是一个右值，所以它被绑定到forward函数的右值引用参数int&& i。但是在forward函数内部，你通过process(i)调用了process函数，此时i虽然是右值引用类型，但在函数内部，它的名称是一个左值。
   
   虽然i是int&&类型，但一旦你给它取名字（即i），它就变成了一个左值。在C++中，任何有名字的变量都是左值，即使它本来是右值引用类型。因此，process(i)中的i是一个左值。如果希望保持右值引用属性并调用process(int&& i)，你需要使用std::move(i)或std::forward(i)。
![unperfect Forwarding](../图片/新特性_22.png)

右值引用的拷贝构造与拷贝赋值（使用move）：
重新定义一个string类：
  注意的是：move拷贝构造的时候，把原指针指向 null，这样配合临时变量的析构函数（临时变量的生命周期只在哪一行），当临时变量调用析构函数时，摧毁内存；
![](../图片/新特性_23.png)

![](../图片/新特性_24.png)


## 对左右值引用本质的讨论
抄自：https://zhuanlan.zhihu.com/p/335994370

1.  右值引用有办法指向左值吗？

有办法，std::move：
事实上std::move移动不了什么，唯一的功能是把左值强制转化为右值，让右值引用可以指向左值。其实现等同于一个类型转换：static_cast<T&&>(lvalue)。 所以，单纯的std::move(xxx)不会有性能提升，


同样的，右值引用能指向右值，本质上也是把右值提升为一个左值，并定义一个右值引用通过std::move指向该左值：

2. 左值引用、右值引用本身是左值还是右值？

被声明出来的左、右值引用都是左值。 因为被声明出的左右值引用是有地址的，也位于等号左边。

形参总是左值，即使类型是右值引用。


3.  完美转发 std::forward

与move相比，forward更强大，move只能转出来右值，forward都可以。

>std::forward<T>(u)有两个参数：T与 u。 a. 当T为左值引用类型时，u将被转换为T类型的左值； b. 否则u将被转换为T类型右值。


## 左值右值存储的地方

**左值：**
+ 定义：左值是指可以出现在赋值运算符左边的表达式，通常表示一个具有持久地址的对象。
+ 内存位置：左值通常存储在栈（stack）或堆（heap）上，具体取决于其生命周期和作用域。

```cpp
int x = 10;  // x 是一个左值，存储在栈上
int* p = new int(20);  // *p 是一个左值，存储在堆上
```

栈上的左值：局部变量通常存储在栈上。
堆上的左值：通过 new 动态分配的内存通常存储在堆上。


**右值**
定义：右值是指不能出现在赋值运算符左边的表达式，通常表示一个临时对象或字面量。
内存位置：右值通常存储在栈上，但它们是临时的，生命周期很短，通常只存在于表达式求值的过程中。

```cpp
int y = 20 + 30;  // 20 和 30 是右值，存储在栈上
int z = 50;  // 50 是右值，存储在栈上
```

栈上的右值：临时对象和字面量通常存储在栈上，但它们的生命周期非常短暂。

内存管理：

栈（Stack）：

+ 局部变量和临时对象通常存储在栈上。
+ 栈上的内存管理是自动的，当函数调用结束时，栈上的内存会自动释放。

堆（Heap）：

+ 动态分配的内存（通过 new 分配）存储在堆上。
+ 堆上的内存需要手动管理，通常通过 delete 或智能指针（如 std::unique_ptr 和 std::shared_ptr）来释放。


## 返回值是右值

在 C++ 中，函数返回值确实是一个右值（rvalue），但它的具体存储方式取决于返回值的类型和函数的实现。让我们详细探讨一下不同情况下的返回值存储机制。

### 1. 返回基本类型（如 `int`, `double` 等）

对于基本类型，返回值通常存储在栈上。编译器会在调用函数时为返回值分配空间，并在函数返回时将结果拷贝到这个空间中。

#### 示例

```cpp
int add(int a, int b) {
    return a + b;  // 返回一个临时的 int 值
}

int main() {
    int result = add(3, 4);  // result 存储在栈上
    std::cout << "Result: " << result << std::endl;
    return 0;
}
```

### 2. 返回用户定义类型（如类对象）

对于用户定义的类型（如类对象），返回值的存储方式更加复杂，因为涉及到对象的构造和析构。编译器可能会使用多种优化技术来提高性能。

#### 2.1 拷贝构造函数

如果没有优化，编译器会使用拷贝构造函数来创建返回值的副本。

#### 示例

```cpp
class MyClass {
public:
    int value;

    MyClass(int v) : value(v) {}
    MyClass(const MyClass& other) : value(other.value) {
        std::cout << "Copy constructor called" << std::endl;
    }
};

MyClass createObject() {
    MyClass obj(10);
    return obj;  // 返回一个临时的 MyClass 对象
}

int main() {
    MyClass obj = createObject();  // obj 存储在栈上
    std::cout << "Value: " << obj.value << std::endl;
    return 0;
}
```

#### 2.2 返回值优化（RVO 和 NRVO）

为了提高性能，编译器可能会应用返回值优化（Return Value Optimization, RVO）和命名返回值优化（Named Return Value Optimization, NRVO）。这些优化技术可以避免不必要的拷贝构造。

##### RVO（Return Value Optimization）

编译器可以在**调用函数时直接在调用者的栈帧中为返回值分配空间**，从而避免临时对象的创建和拷贝。

##### NRVO（Named Return Value Optimization）

编译器可以在**函数内部直接在调用者的栈帧中为返回值分配空间**，从而避免临时对象的创建和拷贝。

#### 示例

```cpp
class MyClass {
public:
    int value;

    MyClass(int v) : value(v) {}
    MyClass(const MyClass& other) : value(other.value) {
        std::cout << "Copy constructor called" << std::endl;
    }
};

MyClass createObject() {
    MyClass obj(10);
    return obj;  // 编译器可能会应用 RVO
}

int main() {
    MyClass obj = createObject();  // obj 存储在栈上
    std::cout << "Value: " << obj.value << std::endl;
    return 0;
}
```

### 3. 返回引用

如果函数返回的是引用，那么**返回值实际上是现有对象的引用**，而不是一个新的对象。这种情况下，返回值不会占用额外的存储空间。

#### 示例

```cpp
class MyClass {
public:
    int value;

    MyClass(int v) : value(v) {}
};

MyClass& getReference(MyClass& obj) {
    return obj;  // 返回现有对象的引用
}

int main() {
    MyClass obj(10);
    MyClass& ref = getReference(obj);  // ref 是 obj 的引用
    std::cout << "Value: " << ref.value << std::endl;
    return 0;
}
```

### 总结

- **基本类型**：返回值通常存储在栈上。
- **用户定义类型**：编译器可能会应用 RVO 或 NRVO 来优化返回值的存储，避免不必要的拷贝。
- **引用**：返回值是现有对象的引用，不会占用额外的存储空间。

理解这些机制有助于你更好地管理内存和优化代码。希望这些解释对你有所帮助！如果有任何其他问题，请告诉我。




