## 锁的种类Lock与Latch

![](../../项目/cmu15445/课程/图片/16_twophaselocking_1.png)
lock分离的是事务， Lack分离的是线程
lock保护数据内容， Latch保护数据结构
lock的持续事件是整个事务， Lack的持续事件是程序元编写的临界区
lock有很多模式， Lack通常只有读写
lock有死锁机制，如果检测到死锁就能够捕捉到并恢复， Lack没有
lock通过保护的是磁盘上的数据，用锁管理器维护， Lock保护的是内存上的，数据结构本身维护
这个Lock Manager是一个哈希表，将由一个 Lack编写并加以保护。

1. Latch是闩锁（轻量级的锁）
定义：
  + 闩锁是一种低级别的并发控制机制，用于保护共享数据结构，确保在多线程环境中对这些数据结构的访问是线程安全的。
  + 闩锁通常用于保护内部数据结构，如缓冲池、索引结构等

特性：
  + 粒度：闩锁的粒度通常较小，用于保护具体的内部数据结构。
  + 持续时间：闩锁通常在一次操作或一小段代码执行期间持有，操作完成后立即释放。
  + 类型：闩锁通常是互斥锁（Mutex），确保同一时间只有一个线程可以访问受保护的数据结构。

因为其要求锁定的时间必须非常短。若持续的时间长，则应用的性能会非常差。在InnoDB存储引擎中，latch又可以分为mutex（互斥量）和rowlock（读写锁）。其**主要目的是用来保证并发线程操作临界资源的正确性，并且通常没有死锁检测机制。**

用途：用于保护数据库管理系统内部的数据结构，确保线程安全。

查看方式：show engine innodb mutex

2. lock：
是一种高级并发控制机制，用于确保事务的隔离性和一致性

lock的对象是事务，用来**锁定的是数据库中的对象**，比如表、页、行。一般lock的对象仅在事务commit或rollback后进行释放，不同事务隔离级别释放的时间可能不同。此外，lock正如在大多数数据库中一样，是有死锁机制的。

特性：
 + 粒度：锁可以有不同的粒度，例如表锁、行锁、页锁等。
 + 持续时间：锁通常在事务开始时获取，在事务提交或回滚时释放。
 + 类型：常见的锁类型包括 共享锁（Shared Lock）和排他锁（Exclusive Lock）。
   + 共享锁：允许多个事务同时读取同一数据，但阻止写操作。
   + 排他锁：阻止其他事务读取或写入同一数据。

用途：用于确保事务的隔离性和一致性，防止数据冲突

查看方式： show engine innodb status

![](../图片/锁.png)


### 例子

假设有一个数据库管理系统，其中包含一个表 `Accounts`，用于存储用户账户信息。系统中有两个事务 `T1` 和 `T2`，它们需要对同一个账户进行操作。

#### 使用锁（Lock）

1. **事务 T1**：
   - 开始事务。
   - 获取 `Accounts` 表中某一行的排他锁（ Exclusive Lock）。
   - 更新账户余额。
   - 提交事务，释放锁。

2. **事务 T2**：
   - 开始事务。
   - 尝试获取 `Accounts` 表中同一行的排他锁，但由于 T1 已经持有锁，T2 需要等待。
   - T1 提交事务后，T2 获取锁，更新账户余额。
   - 提交事务，释放锁。

通过使用锁，确保了 T1 和 T2 对同一行数据的访问是互斥的，从而保证了事务的隔离性和一致性。

#### 使用闩锁（Latch）

假设数据库管理系统有一个缓冲池，用于缓存经常访问的数据页。系统中有两个线程 `Thread1` 和 `Thread2`，它们需要访问缓冲池中的同一个数据页。

1. **线程 Thread1**：
   - 获取缓冲池中数据页的闩锁（Latch）。
   - 读取或写入数据页。
   - 释放闩锁。

2. **线程 Thread2**：
   - 尝试获取缓冲池中同一数据页的闩锁，但由于 Thread1 已经持有闩锁，Thread2 需要等待。
   - Thread1 释放闩锁后，Thread2 获取闩锁，读取或写入数据页。
   - 释放闩锁。

通过使用闩锁，确保了 Thread1 和 Thread2 对缓冲池中同一数据页的访问是线程安全的，从而防止了数据竞争和不一致。

### 总结

- **锁** 用于确保**事务的隔离性和一致性**，通常在事务级别使用，持续时间较长。
- **闩锁** 用于保护数据库管理系统内部的**数据结构**，确保线程安全，通常在操作级别使用，持续时间较短。

通过这些机制，数据库管理系统能够有效地管理并发操作，确保数据的一致性和完整性。


