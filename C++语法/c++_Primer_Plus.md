# c++ Premer Plus

#<font color=Crimson>2024.3.1</font>

#c++中的头文件和源文件的作用

## 一、c++编译模式

C++ 语言支持"分别编译"（separatecompilation）。也就是说，一个程序所有的内容，可以分成不同的部分分别放在不同的 .cpp 文件里。.cpp 文件里的东西都是相对独立的，在编译（compile）时不需要与其他文件互通，只需要在编译成目标文件后再与其他的目标文件做一次链接（link）就行了



##三 、#include
/#include:#include 是一个来自 C 语言的宏命令，它在编译器进行编译之前，即在预编译的时候就会起作用。#include 的作用是把它后面所写的那个文件的内容，完完整整地、一字不改地包含到当前的文件中来。值得一提的是，它本身是没有其它任何作用与副功能的，它的作用就是把每一个它出现的地方，替换成它后面所写的那个文件的内容。简单的文本替换，别无其他。因此，main.cpp 文件中的第一句（#include"math.h"），在编译之前就会被替换成 math.h 文件的内容。即在编译过程将要开始的时候，main.cpp 的内容已经发生了改变：


##四、头文件中应该写什么
头文件的作用就是被其他的 .cpp 包含进去的。它们本身并不参与编译，但实际上，它们的内容却在多个 .cpp 文件中得到了编译。通过"定义只能有一次"的规则，我们很容易可以得出，头文件中应该只放变量和函数的声明，而不能放它们的定义。因为一个头文件的内容实际上是会被引入到多个不同的 .cpp 文件中的，并且它们都会被编译。放声明当然没事，如果放了定义，那么也就相当于在多个文件中出现了对于一个符号（变量或函数）的定义，纵然这些定义都是相同的，但对于编译器来说，这样做不合法。

所以，应该记住的一点就是，.h头文件中，只能存在变量或者函数的声明，而不要放定义。

## C++ 头文件和源文件的区别
一、源文件如何根据 #include 来关联头文件
1、系统自带的头文件用尖括号括起来，这样编译器会在系统文件目录下查找。
2、用户自定义的文件用双引号括起来，编译器首先会在用户目录下查找，然后在到 C++ 安装目录（比如 VC 中可以指定和修改库文件查找路径，Unix 和 Linux 中可以通过环境变量来设定）中查找，最后在系统文件中查找。


# 第2章

在C++中，用双引号括起来的一系列字符是字符串；

endl:重起一行； 打印字符串时，cout不会自动移到下一行；

C++中回车的作用和空格或制表符的作用相同。

C++允许再任何地方声明变量；

再C++中，函数调用中必须包括括号，即使没有参数；

自定义函数使用：函数原型放在main（）之前，函数代码放到main()之后。

# 第三章

3.1 “ #define a 10 ；#define 是一个预处理器编译指令，该编译指令告诉预处理器：在程序中查找字符a，并将所有的字符a替换成10；

用const定义常量。相较于#define好：1.const能够指定类型。2.可已使用C++的作用域规则将定义限制在特定的函数或者文件中。3.const可用于更复杂的数组和结构中。

3.2	在默认情况下，cout以十进制十进制格式显示数据，不管这些整数在程序中如何书写，如果要以十进制或者八进制显示，可以使用cout的一些特殊性质。用头文件iostream中的控制符dec,hex,oct，分别指示cout以十进制，16，8进制格式显示。

	#include<iostream>
	using namespace
	int main()
	{
		int a = 10;
		cout << a <<endl;
		cout << hex;
		cout << a <<endl;
		return 0;
	}	
	输出结果：10
			 a

cout<<hex;不会在屏幕上显示内容，只是修改cout显示整数的方式，因此，控制符hex实际上是一条消息，告诉cout采取何种行为。

虽然char最常用来处理字符，但也可以将它用做比short更小的整数；

c++将字符表示为整数：

	char ch;
	cin >> ch;

如果输入5，上述代码将读取字符“5”，并将其对应字符编码53储存到变量ch中。	

	int n;
	cin>>n;

如果输入5，上述代码将读取字符“5”，并将其对应字数字值5,储存到变量n中。

3.3	转义序列:\n表示换行符，下列三个相等。

	cout<<endl;
	cout<<'\n';
	cout<<"\n"

3.4	布尔变量：C++将非零值解释为true，零解释为false。

3.5 浮点数：计算机将这样的值分为两部分存储。一部分表示值，另一部分用于对值进行放大或缩小。d.dddE+n指的是将小数点右移动n位，d.dddE-n指的是将小数点左移动n位。小数点移动，因此得名浮点。（E和e都行）

对于float，c++只保证6位有效数字。

浮点常量在默认情况下位double类型。


# 第四章

sizeof运算符返回类型或者对象的长度（字节）。
如果将sizeof用于数组名，得到的僵尸整个数组的字节数，用于数组元素返回元素长度（字节）；

数组初始话：用大括号 int a[2] = {1,2} 未初始化的为0；

###4.1 字符串 string

数组表示：
char a = {'v','v','a'} 不是字符串
char a = {'v','v','\0'} 是字符串 

另一种初始化（主要），用双引号，这种字符被称为字符串常量。
char a = “adv”

注意：字符串常量（双引号）不能与字符常量（使用单引号）互换。字符常量（'s'）是字符串编码的简写表示。's'只是83的另一种表示。

char a = 's';
char a= "s";
是不同的，第一个表示的是把83赋值给a，第二个是将内存地址传给a。

字符串输入时：cin使用空白（空格、制表符、换行符）来确定字符串的结束位置。

读取一行：getline()和get(),着两个函数都读取一行输入，直到换行符。然而，getline()将丢弃换行符，

保留在序列中（下一个读取的话，就是换行符）。

getline:cin.getline(name,20),这将把一行读入到nme数组中（这行包含的字符串不超过19个）。通过换行符确定行尾，但不保存换行符。但是在存储字符串时，它用空字符来替换换行符。这里表明函数getline()是istream类的一个类方法。

string str;
getline(cin,str)；对string进行输入。这里没有使用.说明不是istream的类方法，由于string会自动调整大小，所以不需要传递长度参数。

若使用 cin>>str;则只能传递一个单词。比如输入aaa,但是str只能读取a一个字符

###4.1 get和getline

cin.get() 是 C++ 中用于从标准输入流中获取单个字符的函数。它从输入流中读取下一个字符，并返回读取的字符作为 int 类型的整数值。如果到达文件结束符或者发生读取错误，它会返回一个特殊的常量 EOF（End Of File）。

	int cin.get();

1：变量名(char)=cin.get();
用来获取输入的第一个字符
2:cin.get(字符数组名,20)//20指的是输入字符串的个数
这里对比cin（cin遇到空格就读取结束）而cin.get(字符数组名,20)可以读取空格
3:cin.get()用于舍弃输入流的不需要的字符(比如回车什么的)



getline 是 C++ 中用于从输入流中读取一行文本的函数。它可以从任何类型的输入流中读取数据，比如标准输入流 cin、文件流、字符串流等。这个函数声明在头文件 <string> 中。

	istream& getline(istream& is, string& str, char delim = '\n');

参数 is 是输入流对象，str 是存储读取文本的字符串对象的引用，delim 是可选的分隔符，默认为换行符 '\n'。

getline 函数会读取输入流中的字符，直到遇到分隔符 delim（默认为换行符）为止。读取的字符会存储到字符串对象 str 中，但不包括分隔符本身。分隔符会被丢弃，而不会存储到字符串中。

###4.2 string类

c++提供了string的库，所以现在可以使用string类型的变量而不是字符数组来储存字符串了。与字符串数组之间的主要区别是，可以将string对象声明为简单的变量。

头文件：#include<string>

string类位于名称空间std中，所以需要std::string来引用。

声明：std::string s = "adaf";

### 4.3 结构

结构可以存储多种类型的数据。

使用：关键字struct

	struct struct_name
	{
		int a;
		char b;
	};

结构声明通常放在main外面，外部变量，后面的函数都可以使用。

可以将结构作为参数传递给函数，函数也能返回一个结构；



<font color=Crimson>结构初始化：和数组一样，使用都好分割值列表：</font>.

	struct_name a = {3,'s'}

结构体数组：方法和创建基本类型数组完全相同;要初始化结构数组，结合初始化数组的规则（用逗号分割每个元素的值，并将这些值用花括号阔起）和初始化结构规则（用逗号分割每个成员的值，并将这些值用花括号括起）

	struct_name b[2] = {{2,'s'},{3,'w'}}

### 枚举

enum提供了另一种创建符号常量的方式，这种方式可以代替const
使用enum和结构相似；

	enum enum_test {a,b,c,d}

a,b,c,d是枚举量(整型)，默认情况下，将数值赋给枚举量，第一个是0，第二个是1，依次增加。也可以显示的指定数字覆盖默认值；

声明：

	enum enum_test {a=2,b=5,c,d=3}

声明变量：

	enum_test band;
	band = a;

指定的值必须是整数，后面没有被初始化的枚举值将比前面的值大1.

枚举量是整形，可以被提升为int类型，但int不能自动转化为枚举类型，在运算中枚举将会转化为int：

	int f = a; //a=2被转化为int 2
	a = 3; //错误
	f = a+1; //正确	
	
### 指针

1. 取地址：&
取值（解除引用）:*，应用与指针，可以取到地址处储存的值；

声明： int* a;

由于*运算符用于指针，因此a变量本身就是指针。a的类型是指向int的指针。

注意：

	int* a,b; //创建的a是指针，b是int变量，对内阁指针变量名都要使用一个*

2. 创建其他类型指针：

	int* a;
	double* b	

这里，*a占用4个字节， 
*b占用8个字节。虽然a和b指向两个不同类型的指针但是这两个变量本身的长度是相同的。地址的长度取决于计算机系统。

3. 指针不是整形，假如我们要把地址赋值给变量：

	int* a;
	a = 0x1425; //是不对的，但是可以进行强制转换
	a = (int*)0x1425 //正确的

<font color=Crimson>使用New分配内存，new返回的是一个指</font>.

	typename * p = new typename;

声明不同类型指针：
	
	int* p1 = new int;
	dpuble* p2 = new double;

这里p1和p2的长度都是一样的，储存的是地址；
*p1和
*p2的长度不同，*p1=4和
*p2=8，
因为*p1指定的是int类型
*p2指定的double类型。

<font color=Crimson>使用delete释放内存</font>.

	int* p1 = new int;
	delete p1;

只能使用delete释放用new分配到内存。

4. 使用new创建动态数组

	int* a = new int [10] //创建动态数组，a指向第一个元素的地址
	delete [] a; //释放数组

使用指针数组，只要把指针当作数组名使用即可。a[0],a[1].a[2];

5. 指针、数组和指针算术

指针变量加1后，增加的量等于它指向的类型的字节数，double指针加1，则数值将增加8。C++将数组名解释为地址。

但是，将sizeof运算符用于数组名时，此时将返回整个数组长度（单位字节）。

a[0] c++将其看作*（a+1）,这意味着先找地址然后在取出存的值；


<font color=Crimson>数组地址</font>.

	short tell[10];
	cout << tell ;
	cout << &tell;

从数字上，这两个地址相同，但是tell(&tell[0])是一个2字节内存块的地址，而&tell是一个20字节内存块的地址。所以，tell+1将地址加2，&tell+1将地址加20；

6. 指针和

在cout和多数c++表达式中，char数组名、char以及引用用括号括起的字符串常量都被解释为字符串中第一个字符的地址。cout对象认为char的地址是字符串的地址，因此它打印该地址的字符，然后继续打印后面的字符，直到遇到空字符（\0）为止。

一般来说，如果给cout提供一个指针，他将打印地址。但是指针类型为char*，则cout将显示指向的字符串，如果要显示字符串地址，则将必须将这种指针强制转换为另一种指针类型。

	char* a[20] = "adfav";
	cout << (int*)a; //强制转换

7. 使用new创建动态结构

创建结构：
	
	struct aaa
	{
		int a;
		int b; 
	}
	aaa * ps = new aaa;
	aaa b = {1,2};
	//指针访问：
	ps -> a

结构指针访问用->符号。所以，如果结构标识符号是结构名，则使用据点运算符；如果是指向结构指针，则使用箭头运算符。

或者用(*p).a也行；

8. 数组的替代品：vector,array

vector是使用new创建动态数组的替代品；

头文件 #include<vector>;

vector包含在名称空间中std;

创建变量：

	vector<typename> vt(n_elem);
	vector<int> vi;
	vector<int> a(10);

2024.3.2

#第五章 循环

	for (int i=0;i<10;i++)

a++:意味着使用a的当前值计算表达式，然后a的值加1；首先复制一个副本，将其加1，然后将复制的副本返回

++a:意味着先将a的值加1，然后使用新的值计算表达式；将值加1，然后返回结果，效率比后缀高

5.1 字符串比较

如果word是数组名

	word= "sdfa";

上面的表达式不是判断两个字符串是否相等，而是查看他们是否储存在相同的地址上。 数组名是数组的地址，同样，用引号括起的字符串常量也是其地址。

可以使用strcmp()，进行比较；该函数接收两个字符串地址作为参数，这意味着参数可以是指针、字符串常量或字符数组名。如果两个字符串形同，返回00；如果第一个字符串字母顺序排在第二个字符串之前，则返回一个负数，反正返回整数。

若是使用string，不用那么麻烦；

5.2 类型别名

有两种：使用预处理器：#define ；使用关键字typedef ；假如要使byte为char的别名：

	#define byte char;
	typedef char byte;

typedef通用格式：typedef typename aliasname;
相当于在声明变量前，加上typedef；但是typedef不会创建新类型，只能为已有的类型简历一个别名；


define和typedef的区别：

//  #define 是 C++ 预处理器指令，用于创建宏。它用来定义简单的文本替换。你可以使用 #define 定义一个标识符，以后每次在代码中出现这个标识符，都会被预处理器替换为相应的文本。


typedef 是 C++ 中的关键字，用于为已有的数据类型创建新的名称。它可以为现有的数据类型创建一个别名，使代码更易读和可维护。

比较：
// #define 是文本替换，而 typedef 是为数据类型创建别名。

// #define 可以用于定义常量、宏、条件编译等，而 typedef 用于创建数据类型的别名。

// #define 在预处理阶段进行替换，而 typedef 是在编译阶段进行处理。

5.2.1 指针常量和常量指针的区别

1、指针常量——指针类型的常量（int *const p）
本质上一个常量，指针用来说明常量的类型，表示该常量是一个指针类型的常量。在指针常量中，指针自身的值是一个常量，不可改变，始终指向同一个地址。在定义的同时必须初始化。用法如下：
int a = 10, b = 20;
int * const p = &a;
*p = 30; // p指向的地址是一定的，但其内容可以修改

2、常量指针——指向“常量”的指针（const int *p， int const *p）
常量指针本质上是一个指针，常量表示指针指向的内容，说明该指针指向一个“常量”。在常量指针中，指针指向的内容是不可改变的，指针看起来好像指向了一个常量。用法如下：
int a = 10, b = 20;
const int *p = &a;
p = &b; // 指针可以指向其他地址，但是内容不可以改变

内容不可以改变的意思是不可以对p进行*（解引用）改变里面的值，但可以重新指向其他地址空间！！！！！！！

5.3 二维数组

创建每个元素本身都是数组的数组：

int a [2][6];

意味着：a是一个包含2个元素的数组，其中每个元素都是一个由6个整数组成的数组；

5.4 字符函数库cctype

头文件：#include<cctype>

函数：

isalnum():如果参数是字母数字，返回true

isalpha():如果参数是字母，返回true

islower():如果是小写，返回true

isupper():如果是大写，返回true

5.5  ?:运算符

	expression ? expression2 : expression3

如果expression是true，则表达式的值为expression2,否则是expression3;


5.6 switch

	switch (expression)
	{
		case 1 :statement;
		...
		default: statement;
	}

&&: 如果左侧表达式为flase。则c++不会判断右侧表达式；

5.7 读取数字

假如，要把一系列数字读到数组中，并且允许在数组填满之前结束输入。可以用cin

	int n;
	cin >>n;

若用户输入一个单词，而不是一个数字，将发生：

（1）n的值保持不变；（2）不匹配的输入将被留在输入队列中；（3）cin对象中的一个错误标记被设置；（4）对cin方法的调用将返回false

返回false意味着可以用非数字输入来结束读取数字的循环。非数字输入设置标记意味着必须重置改标记，程序才能继续读取输入。clear（）方法惩治错误输入标记，同时也重置文件尾。

	while(!(cin>>golf[i]))
	{
		cin.clear(); //重置输入
		while(cin.get() != '\n') //读取行尾之前的所有输入，从而杀出这一行中的错误输入；
			contiue;
	}


5.8 文件输入和输出

写入到文本文件：

头文件： #include<fstream>

头文件定义了一个用于处理输出的ofstream类。需要声明一个ofstream对象。需要使用using或者std::;
ofstream和文件关联起来用open(),使用完文件后，使用close()将其关闭。
后面，就像使用cout那样使用ofstream对象。

	ofstream outfile;
	outfile.open("地址")
	outfile << "afdf"<<122<<endl;
	outfile.close();

outfile可以使用cout可使用的任何方法。

open():若文件不存在，则新建文件；若存在，丢掉内容重新写；

读取文本文件

头文件：#include<fstream>

头文件定义了一个用于处理输出的ifstream类。需要声明一个ifstream对象。需要使用using或者std::;
ifstream和文件关联起来用open(),使用完文件后，使用close()将其关闭。
后面，就像使用cin那样使用ifstream对象。

判读文件是否打开，使用is_open()函数:infile.is_open()


ifstream对象 >> 读取数据；，get()读取字符；getline()读取一行字符；

	ifstream infile;
	infile.open("路径")
	if(!file.is_open())
	{
		statement;h
	}

# 第6章

c++对于函数返回类型限制：不能是数组，可以是其他任何类型；

传递数组：int sum_arr(int arr[],int n);这里int arr[]的意思是传递一个指针，而n是数组的长度。在c++中，当用于函数头或函数原型中，int*arr 和int arr[]的含义是相同的。

所以接收数组名参数的函数访问的是原始数组。按值传递数据，函数使用数据副本。

为了防止函数无意中修改数组内容，可以在声明形参时使用关键字const.

6.1 const和指针

黁不能把const的地址赋给常规指针。

	const int moth[12] = {1,2,3,4};
	int sum(int arr[],int a);
	a = sum(moth,12) //是错误的，不能把const指针赋给const指针。

const int *p;
int * const p;

是不同的；const int*p只能防止修改p指向的值，而不能防止修改p的值，也就是可以将一个新的地址赋值给p；

int *const p;使得p只能指向地址，但允许p修改地址指向的值；

6.2 函数和二维数组

	int data[3][4] = {{1,2,3,4},{4,5,6,7},{1,5,6,8}};
	int toal = sum(data,3);

data是一个数组名，该数组有3个元素，第一个元素本身是一个数组，由4个int数字组成。因此data的类型是指向由4个int组成的数组的指针，因此可以正确的原型是：

	int sum(int (*arr)[4],int size);//size是行数
	或者是
	int sum(int[][4],int size)

6.3 返回字符串的函数

函数无法返回一个字符串，但可以返回字符串的地址，这样做的效率更高。

6.4 函数和结构

使用结构编程时，最直接的方式是想处理基本类型那样来处理结构；也就是说将结构作为参数传递，并在需要时将结构用作返回值使用。

然而，按值传递结构有一个缺点，如果结构非常大，则复制结构将增加内存需要，降低系统运行的速度。所以可以使用传递结构的地址，然后使用指针来访问结构内容。获取结构地址&结构变量，定义指向polar的指针：polar *p;获取成员->;

也可使用按引用传递；

6.5 函数指针

函数的地址：只要使用函数名（后面不跟参数）。如果think（）是一个函数，则think就是该函数的地址

要声明指向特定的函数指针，可以先写出这种函数的原型，然后用（*pf）替换函数名。 

在使用函数指针的时候，可以使用(*pf)，将它看成函数名，也可以直接使用pf

	double pam(int);
	double (*pf)(int);
	pf = pam;
	double a = (*pf)(5);
	double a = pf(5);

两种方式都是相同的。

# 第七章 函数探幽

7.1 内敛函数

内敛函数是c++为提高程序运行速度多做点一项改进。

常规函数调用是使程序跳到函数地址处，在函数运行完成后返回。

内联函数使将相应的函数代码替换函数调用。这样程序就无需跳到另一个位置执行代码，再跳回来。因此执行较快，但是消耗内存较大。如果由10个地方调用函数，则程序将有10个副本。

内联函数：在函数声明前加上关键子inline；在函数定义前加上关键子inline。

宏定义：并不是通过传递参数实现的，而是通过文本替代来实现的。

	#define sqa(x) x*x
	a = sqa(1+2);

结果为a = 1+2*1+2=5

7.2 引用变量

引用是一定义的变量的别名。通过引用变量用作参数，函数将使用原始数据，而不是其副本。

引用变量的主要用途是用作函数的形参，通过将引用变量用作参数，函数将使用原始数据，而不是其副本

7.2.1 创建引用变量

c++给&富裕了另一个含义，将其用来声明引用。

	int rats;
	int & roda = rats;

int &：是指向int的引用，rats和roda将指向相同的值和地址。

引用必须在声明引用时将其初始化，而不能像指针那样，先声明，再赋值。一旦与某个变量关联起来，就将一直效忠于它。

	int & roda = rats;  
实际上是下述代码  
	int * const roda = &rats;  

引用的本质就是指针常量，指针常量是指针指向不可改，所以引用不可修改，只能指向一个地方，不能修改，因为有const。而使用roda其实本质上相当于使用*rats，编译器自动帮我们转换。

但是在实际使用的时候，我们只需要吧roda当成rats即可，因为当中繁琐的步骤，编译器会自动完成。

7.2.2 引用用于结构

引入引用主要是用于结构和类，而不是基本的内置类型。

使用结构引用参数于使用基本变量引用相同，只需在声明结果i有参数时使用引用运算符&即可，

	struct free
	{
		string name;
		int a;
	};


	void set(free & ft);
	void set(const & ft)； //不希望函数修改传入的结构，这里会创建临时变量，相当于传值

函数返回引用：

声明：

free & accumulate(free & target, const free & source)
	{return target;}

如果返回类型被声明为free 而不是free &，上述返回类型将返回target的拷贝。但是返回类型为引用，这意味着返回的时最初传递给accumulate的对象

dup = accumulate(team,fuve);

如果accumulate返回一个结构，而不是指向结构的引用，将把整个结构复制到一个临时位置，在将这个拷贝复制给dup。但在返回值为引用时，将直接把team复制到dup，效率更高。

7.2.3 默认参数

设置默认参数，必须通过函数原型。由于编译器通过查看原型来了解函数所使用的参数数目。

	char * left(const char*str, int n=1);
	char * left(const char*str, int n)
	{}
	
假如函数声明的时候给了默认参数了，函数实现的时候就不要有默认参数。

对于带参数列表的函数，必须从右向左添加默认参数。也就是说，要为某个参数设置默认值。则必须为它右边的所有参数提供默认值。

	int happ(int a, int b=2, int c=3);
	int happ(int b=2, int a,int c=3); //错误

7.2.4 函数重载

函数特征标：如果两个函数的参数数目和类型相同，同时参数的排列顺序也相同，则他们的特征标相同，而变量名是无关紧要的。

函数重载：定义名称相同，但是特征标不同。函数类型不能作为判断标准。

将非const值赋给const变量是合法的，但反之是非法的。

7.3 函数模板

函数模板的作用：建立一个通用函数，其函数返回值类型和形参类型可以不具体制定，用一个虚拟的类型代表。

	template<typename T> //声明一个模板，告诉编译器后面的代码紧跟的T不要报错，T是一个通用的数据类型。
	函数声明或定义

template:关键字,声明创建模板
typename:关键字，表示其后面的符号是一种数据类型，可以用class代替。
T： 类型名，通用数据类型
必须使用尖括号

使用函数模板两种方式：

	template<typename T>
	void swap(T &a,T &b)
	{
		T temp = a;
		a = b;
		b = temp;
	}

	//使用函数模板
	//1.自动类型推导，编译器自动推导类型
	swap(a,b);
	//2.显示指定类型,直接告诉编译器类型
	swap<int>(a,b);

模板不能直接去使用，必须得确定类型后才能使用（两种方式确定，编译器自动推到，或直接给出）。

7.3.1 普通函数与函数模板的区别

1.普通函数调用时可以发生自动类型转换（隐式类型转换）
2.函数模板调用时，如果利用自动类型推导，不会发生隐式类型转换
3.如果利用显示指定类型的方式，可以发生隐式类型转换

隐式类型转换就是：调用的时候，实参会转变类型

	int add(int a,int b);
	template(typename T)
	T T_add(T a,T b);
	
	int a=5;
	char b ='s';
	c=add(a, b)//会把字符s转换为ascall码，进行相加
	c=T_add(a,b)//错误
	c=T_add<int>(a,b)//会把字符s转换为ascall码，进行相加

7.3.2 普通函数与函数模板的调用规则

1. 如果函数模板和普通函数都可以实现，优先调用普通函数
2. 可以通过空模板参数列表来强调函数模板：T_add<>()
3. 函数模板也可以发生重载
4. 如果函数模板可以产生更好的匹配。优先调用函数模板。

实际情况中，提供函数模板，最好不要提供普通函数



7.3.3 显式具体化

1. 对于给定的函数名，可以有非模板函数、模板函数和显式具体化模板函数以及他们的重载版本。
2. 显式具体化的原型和定义应以temaplate<>开头，并通过名称来指出类型
3. 具体化优于常规模板，而非模板函数优于具体化和常规模板

	//非模板函数
	void swap(job &, jov &);
	
	//模板函数
	template<typename T>
	void swap(T &,T &)；
	
	//具体化模板
	template<>
	void swap<job>(job &, jov &);

如果有多个原型，则编译器在选择原型时，非模板版本优先于显式具体化和模板版本；而显式具体化优先于使用模板生成的版本。

### 实例化

在 C++ 中，模板实例化是指根据模板定义创建模板的具体实例的过程。有两种方式可以实例化模板：隐式实例化和显式实例化。

隐式实例化（Implicit Instantiation）：
隐式实例化是指当编译器遇到使用模板的代码时，根据模板定义自动创建模板实例的过程。编译器会根据使用的模板参数类型推断出需要实例化的模板，并在编译过程中自动完成实例化操作。这是 C++ 模板的常规行为，也是最常见的模板实例化方式。

	// 模板定义
	template<typename T>
	void myFunction(T arg) {
	    // 实现
	}
	
	int main() {
	    // 隐式实例化：根据参数类型 int 自动实例化模板
	    myFunction(42); 
	    return 0;
	}

显式实例化（Explicit Instantiation）：
显式实例化是指在代码中显式声明需要实例化的模板，并在编译过程中要求编译器创建特定的模板实例。通过显式实例化，你可以避免编译器在多个源文件中重复实例化同一个模板，从而减少编译时间和减小可执行文件的体积。

	// 显式实例化：告诉编译器需要实例化模板 myFunction<int>
	template void myFunction<int>(int);
	
	int main() {
	    myFunction(42); // 仍然可以在其他地方隐式实例化
	    return 0;
	}

显式实例化的语法是在模板名称后加上尖括号 < >，并在尖括号中提供模板参数类型。这样编译器就会生成特定类型的模板实例。

总的来说，隐式实例化是编译器自动根据代码需要创建模板实例的过程，而显式实例化则是在代码中明确告诉编译器需要创建特定类型的模板实例。

### 实例化和具体化

实例化（Instantiation）：
实例化是指在编译器将模板代码转换为特定类型或参数集合的实际代码的过程。当编译器遇到使用模板的代码时，它会根据模板定义和提供的模板参数，生成特定类型或参数的实际代码。这个过程是在编译时完成的。

例如，当你调用一个模板函数，并提供特定的类型作为参数时，编译器会实例化模板函数，生成该类型的实际函数代码。

	template<typename T>
	void myFunction(T arg) {
	    // 实现
	}
	
	int main() {
	    myFunction(42); // 编译器会实例化模板函数 myFunction<int>
	    return 0;
	}

具体化（Specialization）：
具体化是指对模板的特定版本进行定制的过程。通常，模板是泛化的，可以适用于多种类型或参数集合。但有时，针对特定类型或参数集合，可能需要提供定制的实现。这就是模板具体化的作用。

有两种主要的具体化形式：模板偏特化（Partial Specialization）和完全具体化（Full Specialization）。

模板偏特化是针对模板的一部分参数进行特化，而另一部分参数保持泛化。这种情况下，只有一部分参数被具体化。

完全具体化是对模板的所有参数进行特化，这种情况下，整个模板被具体化。

	// 模板偏特化
	template<typename T, typename U>
	class MyClass {
	    // 通用实现
	};
	
	template<typename T>
	class MyClass<T, int> {
	    // 针对 (T, int) 参数的特定实现
	};
	
	// 完全具体化
	template<>
	class MyClass<int, int> {
	    // 针对 (int, int) 参数的特定实现
	};

总的来说，实例化是指根据模板定义创建特定类型或参数集合的实际代码的过程，而具体化是指对模板进行定制以适应特定类型或参数集合的过程。

# 第九章 内存模板和名称空间

内存分区模型：

c++将内存分为4个区域：
1.代码区：存放函数体的二进制代码，由操作系统进行管理。
2.全局区：存放全局变量和静态变量以及常量。
3.栈区：由编译器自动分配释放，存放函数的参数值，局部变量等。 
4.堆区：由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收

程序运行前：分为两个区域：代码区和全局区

代码区：存放cpu执行的机器指令。代码区是共享的，目的是对于频繁执行的程序，只需要在内存中有一份代码即可。代码区是只读的，使其只读的原因是防止程序意外修改它的指令。

全局区：全局变量和静态变量、常量保存在全局区。该区域的数据在程序结束后由系统释放。

程序运行之后分为两个区：栈区和堆区

栈区：由编译器自动分配释放，存放函数的参数值，局部变量。注意：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放。

堆区：由程序员分配释放，若程序员不释放，程序结束时由操作系统回收。在c++中主要利用new在堆区开辟内存。


9.1 作用域和链接性

在名称空间中声明的变量的作用域是整个名称空间。

9.1.1 自动存储持续性

在默认情况下，在函数中声明的函数参数和变量的存储持续性为自动，作用域为局部，没有链接性。

用栈对自动变量进行管理。之所以称为栈，是由于新数据被象征性地放在原有数据的上面（也就是说，在相邻的内存单元中，而不是在同一内存单元中），当程序使用完后，将其从栈中删除。程序使用两个指针跟踪栈，一个指针指向栈底（栈开始的位置），另一个指针指向堆顶（下一个可用的内存单元）。当函数被调用时，其自动变量将被加入栈中，栈顶指针指向变量后的下一个可用的内存单元，函数结束时，栈顶指针被重置为函数被调用前的值，从而释放新变量使用的内存。

栈是先进后出的。

9.1.2 静态持续变量

c++为静态变量提供了3种链接性：外部链接性（可在其他文件种访问），内部链接性（只能在当前文件种访问）。由于静态变量的数目在程序运行期间是不变的，因此程序不需要使用特殊的装置来管理他们。编译器将分配固定的内存来存储所有的静态变量，这些变量在整个程序执行期间一直存在。

如果没有显示的初始化静态变量，编译器将把它设置为0.默认情况下，静态数组和结构将每个元素和成员的所有位设置为0。

创建3种静态变量：
1. 创建链接性为外部的静态持续变量，必须在代码块的外面声明；
2. 创建链接性为内部的静态持续性变量，必须在代码块的外面声明它，并且使用static限定符；
3. 创建没有链接性的静态持续变量，必须在代码块内声明它，并且使用static限定符。

	int a = 10;  //链接性为外部的静态持续变量
	static int b = 20;  //链接性为内部的静态持续性变量
	int main(){}
	void fun(){
		static int c = 1; //没有链接性的静态持续变量
		int d = 2;
	}
	
在fun中声明的c的作用域为局部，没有链接性，这意味着只能在fun中使用，就像自动变量d一样。然而与d不同的是，即使在fun函数没有被执行的时候，c也留在内存中。

a和b的作用域都是整个文件，即从声明的位置到文件的结尾都能使用。由于a的链接性是外部的，因此可以在程序的其他文件中使用；b的链接性为内部的，因此只能在上述代码的文件中使用。

9.1.2 静态持续外部链接（课本9.2.4）


定义：有初始化；声明：没有初始化；

如果要在多个文件中使用外部变量，只需在一个文件中包含该变量定义，但在使用变量的其他文件中，都必须使用extern声明：

9.1.3 静态持续内部链接

将static限定符用于作用域为整个文件变量，改变量的链接性将为内部的。链接性为颞部的变量只能在其所属的文件中使用。


9.1.4 静态持续无链接性

将static限定符用于在代码中定义的变量。如果初始化了静态局部变量，则程序只在启动时进行一次初始化。以后调用的时候，就不会像自动变量那样再次被初始化。



在c++中const限定符对默认存储类型稍微影响。在默认情况下全局变量的链接性为外部的，但const全局变量的链接性为内部的。也就是说，全局const定义就像使用static一样。

9.2 动态分配

用new进行动态分配，分配的内存为动态内存。

动态内存的分配和释放顺序取决于new和delete在何时被使用。

通常编译器使用三块独立的内存：一块用于静态变量，一块用于自动变量，一块用于动态储存。

1. 使用new运算符初始化

如果要为内置的标量类型（如int或double）分配寸尺空间并初始化，可在类型名后面加上初始化，并将其用括号括起：

	int *pi = new int(6);
	double *pd = new double(10.3);

但是，要初始化常规结构或数组，需要使用大括号的列表初始化：

	struct where{double x;double y;double z;};
	where *ps = new where {1.2,40.3,5.3};
	int *ar = new int[4] {2,3,6};

在c++中，还可将列表初始化用于单值变量：

	int *pi = new int{6};
	double *pd = new double{10.3};

2. 定位new运算符

通常，new负责在堆中找到一个足以满足要求的内存块。new运算符还有另一种变体，被称为定位new运算符，它让你能够指定要使用的位置。

要使用定位new特性，首先需要包含头文件new，他提供了new运算符的原型；然后将new运算符用于提供了所需地址的参数。

定位new运算符使用传递给它的地址，它不跟踪哪些内存单元已被占用，也不查找未使用的内存块。

所以，使用定位new运算符，每次申请的时候会覆盖原来的信息。
	
	char buffer[512];
	double *p1,*p2;
	p1 = new (buffer) double [4];  //申请的地址为00FD9138,也是buffer的地址
	p2 = new (buffer) double [4];  //申请的地址也为00FD9138,也是buffer的地址。对p2赋值时会覆盖p1

假如不想覆盖，可以梯控一个从数组buffer开头算起的偏移量。

p2 = new (buffer+4*sizeof(double)) double [4];

buffer指定的内存时静态内存，而delete只能用于：指向常规new运算符分配的堆内存。也就是说，数组buffer位于delete的管辖区域之外，则delete [] p2是错误的。所以delete可与常规new运算符配合使用，但不能与定位new运算符配合使用。

# 第十章 对象和类

类成员变量使用前缀:m_

将接口（类）的定义放在头文件中，将实现（类方法的代码）放在源代码文件中。

stok.h文件：

	#ifndef stok_H_
	#define stok_H_
	...
	#endif

类和结构的唯一区别就是，结构的默认访问类型是public,而类是private。

数据通常放到私有，成员函数放在公共部分（调用函数）

10.1 构造函数的分类及调用

c++中拷贝构造函数调用有三种情况：
1.使用一个已经创建完毕的对象来初始化新对象 
2.值传递的方式给函数参数传值 
3.以值方式返回对象

这里2，3，要记住值传递本质上就是拷贝一个临时参数，把实参传递给形参。值返回也是这样，把返回值赋给一个临时变量，然后传递，所以这个过程使用到了构造函数。

再返回函数值的时候，如果要不改变本身变化，可以使用引用，直接在本体上修改。

构造函数调用规则：默认情况下，c++编译器自动至少给一个类添加3个函数：
1. 默认构造函数（无参，函数体为空） 
2. 默认析构函数（无参，函数体为空） 
3. 默认拷贝构造函数，对属性进行值拷贝

构造函数调用规则：
1. 如果用户定义有参构造函数，c++不在提供无参构造，但是会提供默认拷贝构造  
2.  如果用户定义拷贝构造函数，c++不会再提供其他构造函数（默认和有参构造函数）


10.2 深构造和浅构造

野指针：是指指针指向的位置不可知，有三种情况：
1. 指针未定义；
2. 2.指针越界访问 
3. 3. 指针指向空间释放

对指针进行free和delete，只是把指针指向的内存空间释放掉，但并没有把指针本身置空，此时指针之下那个的就是“垃圾”内存。释放后的指针应立即将指针置为NULL，防止产生野指针

避免野指针：
1.指针初始化（如果没有就初始化为NULL）；
2.指针指向空间释放即使其设置为NULL 
3.指针使用前检查有效性（判断是否为NULL）

浅拷贝：简单的赋值拷贝操作

深拷贝：再堆区重新申请空间，进行拷贝操作

如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的危害。

析构函数，可以用来释放在堆区创建的内存。

比如说下面的例子：

	class person
	{
		person(){};
		person(int age,int m){this->age = age; this->m = m}
		person(const person&p){
			age = p.age;
			//m = p.m //这个就是编译器自动创建的拷贝函数，浅拷贝
			m = new int*(*p.m)
			//如果不利用深拷贝在堆区创建内存，会导致浅拷贝带来的重复释放堆区的问题
		}
		~person(){
			if(m != NULL) //释放堆区创建的内存
				{
					delete m;
					m = NULL;
				}
		}
	public:
		int age;
		int * m;
	};
	int main()
	{
		person p1（1，2）;
		person p2(p1);
		return 0;
	}

由于在运行完后，会调用析构函数释放堆区内存，如果使用浅拷贝，由于p2是利用拷贝函数构造的，所以p1.m和p2,m是相同的，都是指向堆区同一个地方的内存，所以在程序运行完后，会重复释放两次，报错。使用深拷贝，在拷贝构造函数的时候会重新构造一个堆区，就有了两个堆区，p1,p2分别指向，这样释放的时候就不会重复释放了。


10.3 类对象作为类成员

类对象中创建其他类对象时：构造函数先调用其他对象的然后再调用本类的，析构函数则是先调用本类的然后调用其他类对象的。

静态成员：静态成员就是再成员变量和函数上加上关键字static，成为静态成员。

静态成员分为：静态成员变量和静态成员函数

静态成员变量：所以对象共享同一份数据；在编译阶段分配内存；类内声明，类外初始化

静态成员函数：所有对象共享同一函数；静态成员函数只能访问静态成员变量。

10.3 c++对象模型和this指针

类成员变量和成员函数是分开储存的，只有非静态成员变量属于类的对象，其他（比如静态成员变量和非静态成员函数、静态成员函数）都不在类对象上。

假如对象中没有的定义变量，声明对象的时候只占用1个字节，主要是为了区分定义类变量。

this指针指向被调用的成员函数所属的对象。this指针是隐含每一个非静态成员函数内的一种指针。this指针不需要定义，直接使用即可。

this指针的用途：1.当形参和成员变量同名时，可用this指针区分。 2.在类的非静态成员函数中返回都对象本身，可使用return *this

this指针的本质，是指针常量。

10.4 const修饰成员函数

常函数：1. 成员函数后加const后我们称为这个函数为常函数
 2.常函数内不可以修改成员属性 
3.成员属性声明加关键字mutable，在常函数中依然可以修改

	void show()const;

this指针的本质是指针常量，指针的指向是不可以修改的。  
相当于：Person * const this; //Person是类  
但是this指向对象的值可以修改，this->a=10 //a是成员变量
假如我们要求指向对象的值也不发生改变，则：
本质上就是：const Person * const this;所有就在声明括号后加上const，来表示这种意思。

常对象： 1. 声明对象前加const称该对象为常对象   
2. 常对象只能调用常函数


10.5 抽象数据类型

c++使用栈管理自动变量，当新的变量被自动生成后，他们被添加到堆顶，消亡时，从栈中删除。

栈的特征：栈存储了多个数据顶，  
其次，栈由可对它执行的操作描述：  
1. 可以创建空栈  
2. 可将数据添加到堆顶（压入）  
3. 可从栈顶删除数据项（弹出）  
4. 可查看栈是否填满  
5. 可查看栈是否为空  

	//例10.10
	class Stack {
		enum{max=10};
		Item m_item[max];
		int top;
	public:
		Stack();
		bool isempty()const;
		bool isfull()const;
		bool push(const Item& item);
		bool pop(Item& item);
	};


也可使用动态分配的数组保存栈顶（课后习题12.4）

	class Stack 
	{
		enum { max = 10 };
		Item* pitems;
		int size;
		int top;
	public:
		Stack(int n = max);
		Stack(const Stack& st);
		~Stack();
		bool isempty()const;
		bool isfull()const;
		bool push(const Item& item);
		bool pop(Item& item);
		Stack& operator=(const Stack& st);
		friend std::ostream& operator<<(std::ostream& cout, const Stack& s);
	};

# 第十一章 使用类

导读：首先介绍运算符重载，它允许将标准运算符用于类。然后友元，使得非成员函数可以访问私有函数。最后介绍如何命令c++对类执行自动类型转换。

11.1 运算符重载

要重载运算符，需要使用被称为运算符函数的特殊形式。运算符函数的格式如下： operator op()

例如：operator +()重载+运算符；operator*()重载*运算符

11.1.1 返回引用

一个类(Stock)的成员函数如下(l例题10.7)：

	void show() const; //显示数据，在函数的括号后面使用const限定符将this限定为const，这样将不能使用this来修改对象的值。
	const Stock & topval(const Stock &s) const; //返回类型为引用意味着返回的是调用对象本身，而不是其副本。
	//这里第一个const，是因为，由于该函数返回了两个const对象之一的引用，因此返回类型也应为cons  t引用
	
	const Stock & Stock::topval(const Stock &s) const
	{
		....
		return *this; //这里就表示着返回*this本身，而不是*this的副本。
	}

第二个类（Time）的成员函数（例题11.2）：

	Time Time::Sum(const Time & t)const
	{
		Time sum;
		...
		return sum;
	}

这里参数是引用，但返回类型不是引用。传递引用相较于传递值快。

这里返回值不能是引用。因为函数创建一个新的Time对象，是局部变量。返回对象将创建对象副本，而调用函数可以使用它。然而，如果返回类型为Time &，则引用的将是sum对象。但由于sum对象是局部变量，在函数结束时将被删除，因此引用将指向一个不存在的对象。使用返回类型Time意味着程序将在删除sum之前构造它的拷贝，调用函数将得到改拷贝。

注意：不要返回指向局部变量或临时变量对象的引用。函数执行完毕后，局部变量和临时对象将消失，引用将指向不存在的数据。

11.1.2 加法运算符

转换为重载的加法运算符很容易，只要将Sum的名称改为operator+即可。

	Time Time::Sum(const Time & t)const
	{
		Time sum;
		...
		return sum;
	}

	Time Time::operator+(const Time & t)const
	{
		Time sum;
		...
		return sum;
	}

t = coding.operator+(fixing);  
还可以表达为： t= coding + fixing;  
运算符左侧的对象是调用对象，右侧的对象是作为参数被传递的对象。
你  
总之，operator+()函数的名称使得可以使用函数表示法或运算符表示法来调用它。

假如t1,t2,t3,t4都是Time对象， t4= t1+t2+t3+t4;
上述表达式也是正确的，由于+是从左向右结合运算符，
因此等效于：t4=t1.oprator+(t2+t3)=t1.oprator+(t2.oprator+(t3))

函数调用t2.oprator+(t3)返回一个Time对象，然后改对象成为函数调用t1.oprator+()的参数。

11.1.3 左移运算符（11.3.2）

左移运算符重载：可以输出自定义数据类型；

假如有类：
	class Person{
		int m_a;
		int m_b;
		...
	}; 

	Person a(1,2);

要想实现cout<<p;来实现显示，就可以使用左移运算符重载。

用成员函数，实现不了cout<<a;这是因为，假如用成员函数定义
void oprator<<(cout);使用时就相当于：p.oprator<<(cout);
就相当于p<<cout;显然不是我们想要的结果。

所以就必须使用全局函数定义（类使用的时候，创造友元函数即可）。

	ostream & oprator<<(ostream &cout,Person &p)
	{
		cout<<a<<b;	
		return cout;
	}

使用链式编程的时候，返回值必须要有，这里就是return cout。

c++从左到右读取输出语句，意味着等于（cout<<x)<<y;

iosream中，<<运算符要求左边是一个istream对象，显然cout是ostream对象，所以cout<<x满足，表达式（cout<<x）位于<<y的左侧，所以输出语句也要求该表达式是一个ostream类型对象。因此，ostream类将operator<<()函数实现为返回一个指向ostream对象的引用。具体是，它返回一个指向调用队形的引用。因此（cout<<x）本身就是ostream对象cout。

所以cout<<x<<y;相当于：先cout<<x;显示x，然后被它的返回值cout所替代，然后cout<<y；

11.1.3 重载>>

	std::istream& operator>>(std::istream& cin, Complex0& s) {
		std::cout << "real: ";
		cin >> s.m_shi;
		std::cout << "imag: ";
		cin >> s.m_xu;
		return cin;
		}

本质上和重载<<一样。

11.1.4 递增运算符重载

递增运算符分为前置递增和后置递增。区分前置还是后置，只需要加int即可（Person类）：

	前置：
	Person &oprator++()
		{
			num++;
			return *this;
		}
	后置：
	Person oprator++(int)
	{
		Person temp = *this;
		num++;
		retrn temp;
	}

注意：前置递增返回类引用，后置递增返回值。

11.2 友元

友元的目的就是让一个函数或者类访问一个类中私有成员

友元的关键字：friend

友元的三张实现：全局函数做友元；类做友元；成员函数做友元；

全局函数做友元：在类中声明全局函数，并且在加上关键字friend

	friend void goodgay();

其他的也是在声明前加上friend，注意成员函数做友元的时候，要加上类的限定名。

11.2.2 

Time opratoe*(double n)const;
假如一个对象B，重载运算符*：

A = B*3;
被转化为下面成员函数： A = B.oprator*(3)
但是A= 3*B就不能使用成员函数访问；

在成员函数中：左侧的操作数为调用对象，3不是对象。

可以用非成员函数：Time oprator*(double m ,const Time &t)

对于非成员函数来说，运算符表达式左边的操作数对应于运算符的第一个参数，运算符右侧的操作数对应于运算符的第二个对象。然后使用友元函数即可。


11.3 

rand()函数：用于生成一个介于 0 和 RAND_MAX 之间的伪随机整数。RAND_MAX 是一个常量，表示 rand() 函数能够生成的最大随机数值。

	int rand(void);

这个函数不需要任何参数。它会生成一个伪随机数，可以用来模拟随机事件，比如随机选择元素、生成随机坐标等。但请注意，rand() 生成的随机数并不是真正的随机数，而是伪随机数，因为它们是根据特定的算法计算出来的，而不是来自于真正的随机过程。因此，在使用时，你可能需要结合其他的方法来确保生成的“随机数”具有一定的随机性和均匀性。

在使用 rand() 函数之前，你需要通过 srand() 函数设置随机数种子，以确保每次程序运行时生成的随机数序列不同。

	void srand(unsigned int seed);

这个函数的参数 seed 是一个无符号整数，用来初始化随机数生成器的种子。通常情况下，可以使用当前时间来作为种子，以确保每次运行时生成的随机数序列都不同。若种子一样，则生成的随机数也一样。

	#include <iostream>
	#include <cstdlib>
	#include <ctime>
	
	int main() {
	    // 使用当前时间作为随机数种子
	    srand(time(0));
	
	    // 生成随机数
	    int randomNumber = rand();
	
	    // 输出随机数
	    std::cout << "Random number: " << randomNumber << std::endl;
	
	    return 0;
	}

cin.clear(): 是 C++ 中用于清除输入流状态标志的函数。cin 是标准输入流对象，用于从标准输入（通常是键盘）读取用户输入的数据。当使用 cin 读取输入时，有时可能会出现错误，比如用户输入了一个不合法的数据类型，导致输入流的状态标志被设置为错误状态。

使用 cin.clear() 可以清除这些错误标志，使输入流恢复到正常状态，以便后续继续读取输入。通常情况下，结合其他操作，比如丢弃错误输入或者进行错误处理，可以更好地处理输入错误的情况。

将数据储存到文件中：首先包含头文件fstream，声明一个ofstream对象，将同一个文件关联起来：
	
	#include<fstream>
	ofstream fout;
	fout.open("文件路径");
	fout<<result<<endl; //加入到文件中



11.4 类的自动转换和强制类型转换

c++处理内置类型转换：将一个标准类型变量的值赋给另一种标准类型的变量时，如果这两种类型兼容，则c++自动将这个值转换为接收变量的类型。

在c++中，接收一个参数的构造函数为将类型与该参数相同的值转换为类提供了蓝图。因此，下面的构造函数用于将double类型的值转化为Stonewt类型：

	Stonewt(double lbs);

也就是说，可以编写这样的代码：

	Stonewt myCat;
	myCat= 19.6;

程序将使用构造函数来创建一个临时的Stonewt对象，并将19.6作为初始化值。随后，采用诸成员赋值方式将该临时对象的内容复制到myCat中。这一过程称为隐式转换，因为它是自动进行的，而不需要显式强制类型转换。

只有接收一个参数的构造函数才能作为转换函数。


只有接收一个参数的构造函数才能作为转换函数。构造函数有两个参数的，不能用来转换类型。但是如果给第二个参数默认值，便可以转换。

只接收一个参数的构造函数定义了从参数类型到类类型的转换。
如果使用关键字explicit限定了这种构造函数，则它只能用于显示转换，否则也可以用于隐式转换。

显式强制转换：
	Stonewt(19.6);


11.4.1 转换函数

构造函数只能用于从某种类型到类类型的转换。要进行相反的转换，必须使用特殊的c++运算符（转换函数）

转换函数是用户定义的强制类型转换，可以像使用强制类型转换那样使用他们。

创建转换函数：要转换为typename类型，需要使用这种姓氏的转换函数： operator typename();

注意：1. 转换函数必须是类方法；
2. 转换函数不能指定返回类型
3. 转换函数不能有参数

	operator double();

typename:指出要转换成的类型，因此不需要指定返回类型。转换函数是类方法意味着：它需要通过类对象来调用，从而告知函数要转换的值。因此，函数不需要参数。

虽然没有声明返回类型，这两个函数也要返回所需的值。另外，int转换将转换值四舍五入为最近的整数，而不是去掉小数部分。

	Complex0();
	Complex0(double a = 0, double b = 0);

这两个构造函数一起使用是错误的，因为第二个全部给默认值了，所以意味着调用的时候，不提供参数也行，也就和第一个冲突了，所以不能全部给默认参数。

# 第十二章 类和动态内存分配

对于在对象中保存姓名来说，通常的方法是，在类构造函数中使用new运算符在程序运行时分配内存。通常时使用string类。

12.1 动态内存和类

12.1.1 静态变量声明和初始化

假如在类中声明了静态变量，注意：不能在类声明中初始化静态成员变量，这是因为声明描述了如何分配内存，但并不分配内存。

对于静态类成员，可以在类声明之外使用单独的语句进行初始化，这是因为静态类成员是单独存储的，而不是对象的组成部分。初始化语句指出了类型，并使用了作用域运算符，但没有使用关键字static.
	
	class Person{...
		static int num;	}

	int Person::num = 0f

初始化是在方法文件中，而不是在类声明文件中的，这是因为类声明位于头文件中，程序可能将头文件包括在其他几个文件中。如果在头文件中进行初始化，将出现多个初始化语句的副本，从而引发错误。（#include的本质是复制粘贴）

注意：静态数据成员在类声明中声明，在包含类方法的文件中初始化。初始化时使用作用域运算符来指出静态成员所属的类。但如果静态成员时const整数类型或枚举型，则可以在类中初始化。

	static const int num=20;

这是因为整型常量在编译时被视为常量表达式，它的值可以在编译时确定，而不需要在运行时进行初始化。

12.1.2 srelen函数，strcpy函数，strcpy函数

1. strlen 函数用于计算字符串的长度，不包括字符串末尾的空字符('\0')。头文件 <cstring> 中包含了 strlen 函数的声明。

	size_t strlen(const char* str);

参数 str 是一个指向以空字符结尾的 C 字符串的指针。

2. strcpy 函数用于将一个字符串复制到另一个字符串中。它属于 C 语言标准库中的函数，声明在头文件 <cstring> 中。

	char* strcpy(char* dest, const char* src);

参数 dest 是目标字符串的指针，src 是源字符串的指针。
strcpy 函数将源字符串（src）的内容复制到目标字符串（dest）中，包括空字符 '\0'，直到遇到源字符串的空字符为止。然后返回目标字符串的指针。

3. 在 C++ 中，strcmp 函数用于比较两个字符串。它属于 C 语言标准库中的函数，声明在头文件 <cstring> 中。

	int strcmp(const char* str1, const char* str2);

参数 str1 和 str2 分别是要比较的两个字符串的指针。

strcmp 函数比较两个字符串的字典顺序。它返回一个整数值，表示两个字符串的比较结果：

如果 str1 小于 str2，则返回负数（通常为 -1）。
如果 str1 等于 str2，则返回零。
如果 str1 大于 str2，则返回正数（通常为 1）。

12.1.3 特殊成员函数

在构造函数中使用new分配内存时，必须在相应的析构函数中使用delete来释放内存。如果使用new[]来分配内存，则应使用delete[]来释放内存。

当使用一个对象来初始化另一个对象时，编译器将自动生成构造函数（复制构造函数，因为它创建对象的一个副本）

	Person (const Person &);

c++自动提供以下成员函数（如果没有定义的话）：  
1. 默认构造函数  
2. 默认析构函数  
3. 复制构造函数  
4. 赋值运算符  
5. 地址运算符：返回调用对象的地址（即this指针的值）  

（1）. 默认构造函数

编译器提供一个不接受任何参数，也不执行任何操作的构造函数（默认的默认构造函数）。如果定义了构造函数c++将不会定义默认构造函数。

注意：带参数的构造函数也可以是默认参数，只要所有的参数都有默认值。但是只能有一个默认构造函数。（11.4.1 转换函数：这样遇到过）

（2） 复制构造函数

复制构造函数用于将一个对象复制到新创建的对象中。也就是说，它用于初始化过程中（包括按值传递参数），而不是常规的复制过程中。类的复制构造函数原型如下：

	Class_name(const Class_name &);

2.1 何时调用复制构造函数：

新建一个对象并将其初始化为同类现有对象时，复制构造函数将被调用。最常见的情况就是将新对象显式地初始化为现有的对象。

Person a(b);
Person a=b;
Person a =Person(b)
Person *a=new Person(b)
都将调用；(记住：新建一个对象并将其初始化为同类现有对象时，都将被调用)

每当程序生产了对象副本时，编译器都将使用复制构造函数。具体地说，当函数按值传递对象或函数返回对象时，都将使用复制构造函数。（按值传递意味着创建原始变量的一个副本）编译器生成临时变量时，也将使用复制构造函数。按值传递和返回对象时都将调用复制构造函数。

2.2 默认的复制构造函数的功能

默认复制构造函数逐个复制非静态成员（成员复制也称浅复制），复制的是成员的值。

默认的复制构造函数只是浅拷贝，复制的是值。但是假如类中的变量有字符串时，进行对象复制的时候，将是复制指向字符串的指针，而不是字符串。这样的话，在调用析构函数的时候将释放两次内存。

	string::string(const string& st)
	{
		num_string++;
		len=st.len;
		str=new char[len+1];
		std::strcpy(str,st.str);
	}

（3） 赋值运算符

原型：

class_name & class_name::operator=(const class_name &)

它接收并返回一个指向类对象的引用。

3.1 赋值运算符的功能以及何时使用

将已有的对象赋给另一个对象时，将使用重载的赋值运算符：

Person a("afaf");
Person b;
b=a;  //使用赋值运算符

但是初始化对象时，并不一定会使用赋值运算符

Person s =a; //使用复制构造函数，也可能使用赋值运算符

s是一个新建的对象，被初始化为a的值，因此使用复制构造函数。但是，也可能是分为两步实现:使用复制构造函数创建一个临时对象，然后通过复制将临时对象的值复制到新对象中。

与复制构造函数相似，赋值运算符的隐式实现也对成员进行诸葛复制。

3.2 解决赋值的问题

对于默认赋值运算符不合适而导致的问题，需要重新定义赋值运算符

1. 由于目标对象可能引用了以前分配的数据，所以函数应使用delete[]来释放这些数据
2. 函数应当避免将对象赋给本身；否则，给对象重新赋值前，释放内存操作可能删除对象的内容
3. 函数返回一个指向调用对象的引用

	stringbad & stringbad::operator=(const stringbad *str)
	{
		if(this==&str)
			return *this;
		delete [] str;
		str = new char[len+1];
		std::strcpy(str,str.str);
		return *this;
	}

代码首先检测自我复制，这是通过查看赋值运算符右边地址（&str）是否与对象（this）的地址相同来完成，如果相同，返回*this。

如果地址不同，函数将释放str指向的内存，这是因为后面将把一个新的字符串的地址赋给str。如果不首先使用delete运算符，则上面的字符串将保留在内存中。


	istream & operator>>(istream &is,string& st)
	{
		char temp[string::CINLIM];
		is.get(temp, string::CINLIM);
		if(is)
			st=temp;
		while(is&&is.get()!='\n')
			continue;
		return is;
	}


12.3 在构造函数中使用new应注意的事项

1. 如果在构造函数中使用new来初始化指针成员，则应在析构函数中使用delete
2. new和delete必须相互兼容。new对应delete，new[]对应delete[]。
3. 如果有多个构造函数，则必须以相同的方式使用new，要么都带中括号，要么都不带。因为只有一个析构函数，所有的析构函数都必须与它兼容。
4. 应定义一个赋值构造函数，通过深度赋值将一个对象初始化为另一个对象。例如：

	string::string(const string& st)
	{
		num_string++;
		len=st.len;
		str=new char[len+1];
		std::strcpy(str,st.str);
	}

具体来说，复制构造函数应分配足够的空间来存储复制到数据，并复制数据，而不仅仅是数据的地址。

5. 应定义一个赋值运算符，通过深拷贝将一个复制给另一个对象。通常，该方法与下面类似：

	stringbad & stringbad::operator=(const stringbad *str)
	{
		if(this==&str)
			return *this;
		delete [] str;
		str = new char[len+1];
		std::strcpy(str,str.str);
		return *this;
	}

具体的说，该方法应完成这些操作：检查自我赋值的情况，释放成员指针以前指向的内存，复制数据而不仅仅是数据地址，并返回一个指向调用对象的引用。


对于输入字符串的处理：

	cin.get(temp,81);
	while(cin && cin.get()!='\n') //用于处理输入流剩余的字符，直到遇到换行符为止。这样做是为了确保下一次输入操作从新的一行开始。
		continue;
	if(!cin || temp[0]=='\0') //如果输入流处于无效状态或者读取到的第一个字符是空字符串。这个条件可以用来检测输入是否为一个空行。
		break;
	else
		saying[i]=temp;

！cin ：这个条件检查输入流cin状态。如果输入流处于无效状态，比如遇到文件结束符或者输入错误，cin的状态为假。


12.4 有关返回对象的说明

当成员函数或独立的函数返回函数时，有几种返回方式可供选择。可以返回指向对象的引用、指向对象的const引用或const对象。

12.5 使用指向对象的指针

调用析构函数：
1. 如果对象是动态变量，则当执行完定义该对象的程序块时，将调用该对象的析构函数。
2. 如果对象是静态变量（外部、静态、静态外部或来自名称空间），则在程序结束时将调用对象的析构函数。
3. 如果对象是用new创建的，则当显式使用delete删除对象时，其析构函数才会被调用。

12.5.3 定位new运算符用于对象

使用定位new运算符，创建对象内存注意：

1. 在内存缓冲区中创建两个对象；在创建第二个对象的时候，定位new运算符使用一个新对象来覆盖用于第一个对象的内存单元。

解决方法：提供两个位于缓冲区的不同地址，并确保这两个内存单元不重叠。
 
	char *buffer = new char[512];
	p1 = new (buffer) Person;
	p2 = new (buffer+sizeof(Person))Person("adfa");

2. 如果使用定位new运算符来为对象分配内存，必须确保其析构函数被调用。

不能直接使用delete p1；这是因为delete不能与定位new运算符配合使用。

delete [] buffer；这是可以的，这里buffer是使用常规new运算符分配的，直接释放整个内存块，但并没有为定位new运算符在该内存块中创建的对象调用析构函数。

解决办法：显示地为使用定位new运算符创建的对象调用析构函数。正常情况下将自动调用析构函数，这是需要显示调用析构函数的少数几种情况。显示地调用析构函数时，必须指定要销毁的对象。由于有指向对象的指针，因此可以使用这些指针。

	p1 ->~Person();
	p2 ->~Person();

需要注意的：正确的删除顺序，对于使用定位new运算符创建的对象，应已与创建顺序相反的顺序进行删除。


12.7 队列模型

队列是先进先出的。

引用和const数据类似，只能在被创建时进行初始化，但不能进行赋值。
从概念上说，调用构造函数时，对象将在括号中的代码执行之前被创建。因此，对于const数据成员，必须在执行到构造函数体之前，及创建对象时进行初始化。c++提供初始化列表来实现。

可以用成员初始化列表进行赋值。

对于const成员，必须使用这种语句。另外对于被声明为引用的类成员，也必须使用这种语法。这是因为引用与const数据类似，只能在被创建时进行初始化。对于简单数据成员，使用成员初始化列表和在函数体中使用复制没有什么区别。


12.7.1 队列类

队列的特征：

1. 队列存储有序的项目序列
2. 队列所能容纳的项目数有一定限制
3. 应当能创建空队列
4. 应当能检查队列是否为空
5. 应当能检查队列是否为满
6. 应当能够在队尾添加项目
7. 应当能够从队首删除项目
8. 应当能够确定队列的项目数

#<font color=Crimson>2024.3.24</font>.

#第十三章 类继承

父类的成员全部被继承，只不过私有成员被隐藏了（被编译器隐藏），但是还会继承下去；

继承中，先调用父亲构造函数，在调用子类构造函数；析构函数相反（先调用子类析构函数，然后调用父类析构函数）；

1. 子类对象可以直接访问到子类中同名成员
2. 子类对象加作用域可以访问到父类同名成员
3. 当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中同名函数。

同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式（通过对象和通过类名）

13.1 构造函数

派生类不能通过直接访问基类的私有成员，而必须通过基类方法进行访问。具体地说，派生类构造函数必须使用基类构造函数。

创建派生类对象时，程序首先创建基类对象。从概念上说，这意味着基类对象应当在程序进入派生类构造函数之前被创建。

派生类构造函数要点：
1. 首先创建基类对象
2. 派生类构造函数应通过成员
5. 将基类信息传递给基类构造函数
3. 派生类构造函数应初始化派生类新增的数据成员

注意： 创建派生类对象时，程序首先调用基类构造函数，然后在调用派生类构造函数。基类构造函数负责初始化继承的数据成员；派生类类构造函数总是调用一个基类构造函数。可以使用初始化列表语法指明要使用的基类构造函数，否则将使用默认构造函数。

派生类对象过期时，程序首先调用派生类析构函数，然后再调用基类析构函数。


13.1.4 派生类和基类之间的特殊关系

1. 派生类对象可以使用基类的方法，条件是方法不是私有的
2. 基类指针可以在不进行显示类型转换的情况下指向派生类对象
3. 基类引用可以在不进行显示类型转换的情况下引用派生类对象

然而，基类指针或引用只能用于调用基类方法，而不能调用派生类的方法。

通常，c++要求引用和指针类型与赋给的类型匹配，但这一规则对继承来说时例外。然而，这种例外只是单向的，不可以将基类对象和地址赋给派生类引用和指针。

13.3 多态公有继承

多态：希望同一种方法在派生类和基类中的行为是不同的。换句话是，方法的行为应却决于调用该方法的对象。


有两种方法可用于实现多态公有继承：
1. 在派生类中重新定义基类的方法
2. 使用虚方法

在基类中被声明为虚函数后，在派生类中将自动成为虚函数。但是，在派生类中也加上virtual关键字，来指出那些函数是虚函数。（可加可不加）

13.3.1 多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用子类的析构代码

解决方法：将父类中的析构函数改为虚析构或者时纯虚析构

虚析构和纯虚析构共性：
1. 可以解决父类指针释放子类对象
2. 都需要有具体的函数实现
虚析构和纯虚析构区别：
如果时纯虚析，该类对象属于抽象类，无法实例化对象；

虚析构语法：

	virtual ~类名（）{}

纯虚析构语法：

	virtual ~类名() = 0;

c++通过使用纯虚函数提供为实现的函数，纯虚函数声明的结尾处为=0；

当类声明中包含纯虚函数时，不能创建该类的对象。这里的理念是，包含纯虚函数的类只能用用作基类。要想成为真正的ABC（抽象基类），必须至少包含一个纯虚函数。

虚析构或纯虚析构就是用来解决通过父类释放子类对象，如果子类中没有堆区数据，可以不写为虚析构或纯虚析构
，拥有纯虚析构函数的类也属于抽象类。

13.4 静态联编和动态联编

将源代码中的函数调用解释为执行特定的函数代码块称为函数名联编。

在c++编译器可以在编译过程完成这种联编。

在编译过程中进行联编称为静态联编，又称为早期联编。
在编译器在程序运行时选择正确的虚方法的代码，被称为动态联编，又被成为晚期联编。

编译器对非虚方法使用静态联编；
编译器对虚方法使用动态联编；

调用虚函数时，程序将查看存储在对象中的vtbl地址，然后转向相应的函数地址表。

13.4.3 虚函数注意事项

析构函数应当是虚函数，除非类不用做基类。如果析构函数是虚函数，则先运行派生类的析构函数然后运行基类的析构函数。

即使基类不需要显式析构函数提供服务，也不应依赖于默认构造函数，而应提供虚析构函数，即使它不执行任何操作。

### 为什么不将operator=和operator<<声明为虚函数

在 C++ 中，将 operator= 和 operator<< 声明为虚函数通常是不合适的，因为这两个运算符通常用于执行对象的赋值和输出操作，而不是多态行为。

operator= (赋值运算符)：赋值运算符通常被用于给对象赋值，而且赋值操作是静态绑定的，即在编译时确定的。因此，将赋值运算符声明为虚函数是没有意义的，因为虚函数是用于实现动态绑定的，而不是用于赋值操作。

operator<< (输出运算符)：输出运算符通常被用于将对象输出到流中，例如 std::cout。这个操作也是静态绑定的，因为在编译时就知道要输出的对象的类型。而且，输出运算符通常是作为全局函数或类的友元函数实现的，而不是类的成员函数。将输出运算符声明为虚函数也是没有意义的，因为它们不应该用于实现多态行为。

虚函数主要用于实现运行时多态，即在运行时根据对象的实际类型来调用相应的函数。但是赋值运算符和输出运算符通常是不涉及多态的，因为它们的行为是基于对象的静态类型的。

#### 设置输出格式

std::ios_base::fmtflags flag = cout.setf(std::ios_base::fixed, std::ios_base::floatfield);：这行代码设置了 std::cout 的输出格式。  
std::ios_base::fixed 是一个标志位，表示要使用固定小数点表示法进行输出。  
std::ios_base::floatfield 是一个位掩码，表示要修改的是浮点数的显示格式。  
cout.setf() 函数用于设置标志位，它返回之前的标志位，并将新的标志位设置为参数中指定的值。  
因此，flag 变量保存了之前的输出格式。  

std::streamsize pr = cout.precision(2);：这行代码设置了浮点数的精度为 2 位小数。  
std::cout.precision(2) 函数返回之前的精度设置，并将新的精度设置为参数中指定的值。  
pr 变量保存了之前的精度设置。  


	 std::ios_base::fmtflags flag = std::cout.setf(std::ios_base::fixed, std::ios_base::floatfield);
	 std::streamsize pr = std::cout.precision(2);
	
	 // 在特定代码段中修改输出格式和精度
	 double num1 = 123.456789;
	 std::cout << "Modified output:" << std::endl;
	 std::cout << std::fixed << std::setprecision(3) << num1 << std::endl;
	
	 // 恢复之前的输出格式和精度设置
	 std::cout.flags(flag);
	 std::cout.precision(pr);

### 关于虚函数在基类和派生类加关键字virtual

使用开发人员命令窗口查看类结构：

cl(空格)/d1(空格)reportSingleClassLayout(类名)(空格)(文件名)(回车)     

0. 在派生类重写函数加virtual容易造成新建虚函数。虚函数签名不匹配的错误通常是因为 函数名、参数
1.  或 const 属性不一样，导致意外创建了一个新的虚函数，而不是重写一个已存在的虚函数。解决这种问题加上关键字override


1. 为了显式的确定派生类函数是否是重写基类，加上关键字override。明确表示派生类这个虚函数是重写基类，如果派生类与基类虚函数的签名不一致，编译器就报错：

	class Base {
	public:
	    virtual void Show(int x); // 虚函数
	};
	
	class Derived : public Base {
	public:
	    virtual void Show(int x) const override; // const 属性不一样，新的虚函数 
	};

2. 如果不希望某个类被破坏，或不希望某个虚函数被重写，则可以在类名和虚函数后加上final关键字，加上final关键字后，在被继承或重写，编译器就会报错。

	class Base {
	public:
	    virtual void Show(int x) final; // 虚函数
	};
	
	class Derived : public Base {
	public:
	    virtual void Show(int x) override; // 重写提示错误  
	};

所有在派生类中重写虚函数，应当尽量加上关键字virtual和override：

	virtual void Report()const override;



### 查看类结构时重载运算符不显示

对于运算符重载，例如 operator=、operator<< 等，它们通常不会在类结构的输出中显式地列出。这是因为它们在类结构中并不体现为独立的成员函数或成员变量。相反，编译器会将它们视为特殊的函数，并在需要时调用它们。

类结构的输出通常会列出成员变量的偏移量以及虚函数表中的虚函数指针。其他特殊函数，如构造函数、析构函数和拷贝构造函数等，可能会被列出，但运算符重载函数通常不会显式地显示在类结构的输出中。

运算符重载函数是类的一部分，但它们的存在通常是为了提供一种特定的语法，使得用户能够以一种更自然的方式使用类对象，而不是直接操纵类结构。因此，它们的存在通常是在语义层面上，而不是在类的内存布局中体现出来。

13.7 继承和动态内存分配

1. 假如派生类不使用new（动态内存分配）

派生类就不需要定义显式析构函数、复制构造函数和赋值运算符。（使用默认的，浅拷贝）

2. 假如派生类使用ne

这种情况就必须派生类定义显式析构函数、复制构造函数和赋值运算符。

（1）. 派生类析构函数：派生类析构函数自动调用基类的析构函数，故其自身只需对派生类狗崽哦函数进行清理即可。（注意：基类析构函数必须是虚函数，这样才能运行派生类析构函数）

（2）. 复制构造函数：hasDMA复制构造函数只能访问hasDMA的数据，因此它必须调用baseDMA复制构造函数来共享baseDMA数据：

	hasDMA::hasDMA(const hasDMA & hs):baseDMA(hs)
	{
		style = new char[strlen(hs.style)+1];
		strcpy(style, hs.style);
	}

这里需要注意的是，成员初始化列表将一个hasDMA引用传递baseDMA构造函数。没有参数类型为hasDMA引用的baseDMA构造函数，也不需要这样的构造函数。因为复制构造函数baseDMA有一个baseDMA引用参数，而基类引用可以指向派生类型。因此，baseDMA复制构造函数将使用hasDMA参数的baseDMA部分来构造新对象的baseDMA部分。

（3）. 赋值运算符：由于hadDMA也使用动态内存分配，所以它也需要一个显式赋值运算符。hasDMA赋值运算符只能访问hasDMA的数据
。然而，派生类的显式赋值运算符必须负责所有继承的baseDMA基类对象的赋值，可以通过显式调用基类赋值运算符来完成：

	hasDMA & hasDMA::operator=(const hasDMA & hs)
	{
		if(this == &ha)
			return *this;
		baseDMA::operator=(hs);
		delete [] style;
		style = new char[strlen(hs.style)+1];
		strcpy(style, hs.style);
		return * this;
	}

这里baseDMA::operator=(hs);其实也是用到：baseDMA有一个baseDMA引用参数，而基类引用可以指向派生类型。将使用hasDMA参数的baseDMA部分来赋值。

当基类和派生类都采用动态内存分配时，派生类的析构函数、复制构造函数、赋值运算符都必须使用相应的基类方法来处理基类元素。这种要求是通过三种不同的方式来满足的。对于析构函数，这是自动完成的；对于构造函数，这是通过在初始化成员列表中调用基类的复制构造函数来完成的；如果不这样做，将自动调用基类的默认构造函数。对于赋值运算符，这是通过使用作用域解析运算符显式地调用基类的复制运算符来完成的。

13.7.1  派生类如何访问基类的友元：

例如，hasDMa类的友元

	feiend std::ostream & oprator<<(std::ostream&os, const hasDMA & rs)

作为hasDMA类的友元，该函数能够访问style（派生类内成员），然而，：该函数不是baseDMA类（基类）的友元，那它如何访问成员lable和rating（基类成员）呢?答案是使用baseDMA类的友元函数operator<<()。另一个问题是，因为友元不是成员函数，所以不能使用作用域解析运算符来指出要使用那个函数。这个问题的解决方法是使用强制类型转换，以便匹配原型时能够选择正确的函数。因此，代码将参数 const hasDMA &转换成类型为 const baseDMA & 参数：

	std::ostream & oprator<<(std::ostream&os, const hasDMA & rs)
	{
		//转换类型后使用oprator<<(std::ostream&os, const baseDMA & rs)
		os<<(const baseDMA &) hs;
		os<<hs.style<<endl;
	}


#<font color=Crimson>2024.3.27</font>.

#第十四章 c++中的代码重用

14.1 包含对象成员的类

14.1.1 valarray类

头文件: #include<valarray>

valarray被定义为一个模板类，以便能够处理不同的数据类型。

模板特性意味着声明对象时，必须指定具体的数据类型。因此，使用valarray类声明一个对象时，需要在类标识符valarray后面加上一堆尖括号，并在其中包含所需的数据类型：

	valarray<int> q_values;
	valarray<double> we;

	
	valarray<double> we(8) //8个元素
	
	valarray<double> we(10，8) //8个元素，初始值为10
	valarray<double> we = {1，2，2}

operator[]():能够访问各个元素
size():返回包含元素数
sum():返回所有元素的总和
max():返回最大元素
min():返回最小元素

名称简化：

	typedef std::valarray<double> Array;


1. 初始化列表

当初始化列表包含多个项目时，这些项目被初始化的顺序为它们被声明的顺序，而不是它们在初始化列表中的顺序。

	Student(const char*str,const double*pd,int n) : scores(pd,n), name(str){}

则name成员仍首先被初始化，因为在类定义中它首先被声明。


14.2 私有继承

14.3 多重继承

MI描述的是有多个基类的类。

现有基类Worker，Singer,Waiter继承Worker,SingingWaiter类继承Singer,Waiter。
	
	class Singer : public Worker{}
	class Waiter : public Worker{}
	class SingingWaiter : public Singer,public Waiter{}

这样定义的话，SingingWaiter继承两个Worler对象，一个来自Singer,一个来自Waiter；

多重继承时，必须使用关键字public来限定每一个基类，这是因为，除非特别指出，否则编译器将认为时私有派生：

	class SingingWaiter : public Singer,public Waiter{} //这里基类sing就被默认为私有继承。

14.3.1 虚基类

虚基类从多个类（他们的基类相同）派生出的对象只继承一个基类对象。通过在类声明中使用关键字virtual，可以使Worker被用作Singer和Waiter的虚基类（virtual和public的顺序无关紧要）

	class Singer : virtual public Worker{}
	class Waiter : public virtual Worker{}

然后：

	class SingingWaiter : public Singer,public Waiter{}

这样的话，SingingWaiter对象现在只包含一个Worker对象的副本。从本质上讲，继承的Singer和Wiater对象共享一个Worker对象，而不是各自引入自己的Worker对象副本。

虚基类的本质是通过改变派生类中对共同基类的内存布局，解决菱形继承中出现的二义性问题。它的基本原理如下：

1. 当一个类被声明为虚基类时，它的子类中的每个间接继承它的类都会共享同一个基类子对象，而不是分别继承自己的基类子对象。

2. 派生类通过虚基类的虚表指针访问共享的基类子对象，以确保对该对象的访问是一致的。


14.3.2 新的构造函数规则

使用虚基类时，需要对类构造函数采用一种新的方法。对于非虚基类，唯一可以出现在初始化列表的构造函数是基类构造函数。这些构造函数需要将信息传递给基类。

比如非虚基类传递信息：

	class A
	{
		int a;
		A(int n):a(n){}
	}
	class B:public A
	{
		int b;
		B(int m,int n):A(n),b(m){}
	}
	class C:public B{
		int c;
		C(int q,int m,int n):B(m,n),c(q){}
	}

这里，C类的构造函数只能调用B类的构造函数，而B类的构造函数只能调用A类的构造函数。所以，这里C类的构造函数使用q值，并将m，n传递给B类的构造函数；而B类的构造函数使用m，并将n值传递给A类的构造函数。

但是，若是虚基类，则这种信息的自动传递将不起作用。

	SingingWaiter（const Worker & wk,int p,int v）:Waiter(wk,p), Singer(wk,v){}

这里存在的问题是，自动传递信息时，将通过2中不同的路径（Waiter和Singer）将wk传递给Worker对象。为了避免这种冲突，c++在基类时虚的时候，进制信息通过中间类自动传递给基类。因此，上述构造函数将初始化Waiter和Singer中的成员，但是wk参数中的信息将不会传递给子对象Waiter。然而，编译器必须在构造派生对象之前构造基类对象，所以，在上述这种情况下，编译器将使用Worker的默认构造函数。

如果不想使用默认构造函数来构造基类对象，则需要显式地调用所需的基类构造函数。如下:

	SingingWaiter（const Worker & wk,int p,int v）:Worker(wk)，Waiter(wk,p), Singer(wk,v){}

显式的调用构造函数worker（const Worker &）。对于虚基类必须这样做，但是对于非虚基类，则是非法的。


14.3.2 使用那种方法

SingingWaiter类继承Singer,Waiter。

假如Singer,Waiter中有两个Show函数，而SingingWaiter中没有

当用SingingWaiter对象调用show函数调用哪一个基类中的函数呢？
	
	SingingWaiter ss；
	ss.Show();

这就是多重继承导致的函数调用二义性；

1. 一种解决方法是，直接使用作用域解析运算符

	ss.Singer::Show()

2. 另一种方法是，在SingingWaiter中重新定义Show函数，并指出使用那个Show()函数。
	
	void SingingWaiter Show()
	{
		Singer::Show();
	}


总之，在祖先相同时，使用MI必须引入虚基类，并修改构造函数初始化列表的规则。


###strchr函数

	char *strchr(const char *str, int character);

str 是一个指向以 null 结尾的字符串的指针，表示待搜索的字符串。
character 是要查找的字符。

函数功能是在字符串 str 中搜索第一次出现字符 character 的位置，并返回指向该字符的指针。如果未找到该字符，则返回 NULL。

strrchr函数：与 strchr 函数一样，它同样表示在字符串 s 中查找字符 c，返回字符 c 第一次在字符串 s 中出现的位置，如果未找到字符 c，则返回 NULL。但两者唯一不同的是，strrchr 函数在字符串 s 中是从后到前（或者称为从右向左）查找字符 c。

14.4 类模板

14.4.1 定义类模板

1. 模板类以下面的代码开头：

	template<class Type>

关键字template告诉编辑器，将要定义一个模板。尖括号中的内容相当于函数的参数列表。可以把关键字class看作是变量的类型名，该变量接收类型作为其值，把Type看作是该变量的名称。
   
这里的Type成为类型参数，这意味着他们类似于变量，但赋给他们的不能是数字，只能是类型。

假如类中需要两个模板变量：
	template<class NameType, class Ang>
	class Person
	{
		NameType name;
		Ang age;
	}

类模板和函数模板语法类似，在声明模板template后加类，此类称为模板。

2. 类模板成员函数实现

使用类模板成员函数替代原有的类方法。每个函数头都将以相同的模板声明打头：template<class Type>,另外还需将类限定符从Person::改成Person<Type>::,例如：

	template<class T1,class T2>
	void Person<T1,T2>::ShowPerson()
	{}


3. 类模板分文件编写

类模板中成员函数和普通类成员函数创建时机是有区别的：

普通类中的成员函数一开始就创建了；
类模板中的成员函数在调用时才创建；

由于类模板中成员函数创建时机是在调用阶段，导致分文件编写链接不到。

解决方法：
1. 直接包含.cpp源文件
2. 将声明和实现写在同一个文件中，并更改后缀名为.hpp，.hpp是约定的名称，并不是强制（主要是使用方法2）

不能将模板成员函数放在独立的实现文件中。由于模板不是函数，他们不能单独编译。模板必须与特定的模板实例化请求在一起使用。为此，最简单的方法是将所有模板信息放在一个头文件中，并在要使用这些模板的文件中包含头文件。



14.4.2. 类模板和函数模板的区别  

1. 类模板没有自动类型推导的使用方式
 
	Person p1("dadf",77)

上面这种是错误的，类模板不能自动类型推导，只能显式的使用：

	Person<string,int>p1("dadf",77)

2. 类模板在模板参数列表中可以有默认参数

	template<class NameType, class Ang=int>
	class Person
	{
		NameType name;
		Ang age;
	}

上面，Ang有默认参数int，所以可以这样调用：

	Person<string>p1("dadf",77) //省略第二个参数

类模板中的成员函数并不是一开始就创建的，在调用时才创建的；

虽然可以为类模板类型参数提供默认值，但不能为函数模板参数提供默认值。然而，可以为非类型参数提供默认值，这对于类模板和函数模板都是适用的。

14.4.3. 深入探讨类模板

可以将内置类型或类对象用作类模板Stack<Type>的类型，指针也可以。（指针栈）

使用指针栈的方法之一是，让调用程序提供一个指针数组，其中每个指针都指向不同的字符串。


类模板对象做函数参数

类模板实例化出的对象，想函数传参的方式  
一共有三种传入方式：  
1. 指定传入的类型 --直接显式对象的数据类型   
2. 参数模板化  --将对象中的参数变为模板进行传递 
3. 整个类模板化  --将这个对象类型 模板化进行传递  

使用比较广泛的是第一种；


14.4.5. 类模板与继承

当类模板遇到继承时，需要注意：
1. 当子类继承的父类时一个类模板时，子类在声明的时候，要指出父类中T的类型  
2. 如果不指定，编译器无法给子类分配内存    
3. 如果想灵活指出父类中T的类型，子类也需变为类模板  

类模板可用作基类，也可用作组件类，还可以作其他模板的类型参数。


### 具体化


在 C++ 中，"具体化"（Specialization）通常指的是模板的特化。模板特化允许你为特定类型或特定参数集合提供定制的模板实现

类模板特化（Class Template Specialization）：
类模板特化是指针对特定类型或特定参数集合提供自定义的类模板实现。它可以用来为某些特殊情况提供定制的行为。类模板特化使用 template<> 关键字来指定模板参数，并在其后提供定制的实现。
	
	
	// 基本的类模板
	template<typename T>
	class MyClass {
	    // 通用实现
	};
	
	// 类模板的特化版本，针对特定类型 int 提供了定制的实现
	template<>
	class MyClass<int> {
	    // int 类型的特定实现
	};

函数模板特化（Function Template Specialization）：
函数模板特化允许你为特定类型或特定参数集合提供自定义的函数模板实现。它可以用来解决特殊情况下的特定问题。函数模板特化也使用 template<> 关键字来指定模板参数，并在其后提供定制的实现。

	// 基本的函数模板
	template<typename T>
	void myFunction(T arg) {
	    // 通用实现
	}
	
	// 函数模板的特化版本，针对特定类型 int 提供了定制的实现
	template<>
	void myFunction<int>(int arg) {
	    // int 类型的特定实现
	}

### 常量成员和非常量成员

	double&stdent::operator[](int n)
	{
		return s[i];
	}
	double&stdent::operator[](int n)const
	{
		return s[i];
	}

第一个就是非常量成员函数，第二是常量成员函数。第一个只能非常量对象调用，常量对象不能调用。第二个函数常量对象和非常量对象都能调用。如果只提供第二个常量函数那么非常量对象和常量对象都可以调用。







第16章 string类和模板库


STL从广义上分为：容器、算法、迭代器	
容器和算法之间通过迭代器进行链接；

STL分为六大件：容器、算法、迭代器、仿函数、适配器、空间配置器

1. 容器：各种数据结构，如vector、list等，用来存放数据
2. 算法：各种常用的算法
3. 迭代器：容器和算法之间的胶合剂
4. 仿函数：行为类似函数，作为算法的莫种策略
5. 适配器：用来修饰容器或者仿函数或者迭代器接口的东西
6. 空间配置器：负责空间的配置与管理



16.1 string类

16.1.1 构造字符串

共有9个构造函数；有2个是c++11新增的；(例题16.1)

16.1.2 string输入

	string str;
	cin>>str;  //输入一个单词
	getline(cin,str);  //输入一行

getline有一个可选参数，用于指定使用那个字符来确定输入的边界；

	getline(cin,str,':') //：为输入边界

16.1.3 字符串的使用

1. 字符串拼接

函数原型：

	string& operator+=(const char* str);    
	string& operator+=(const char c);
	string& operator+=(const string& str);
	
	string& append(const char*s);  // 把字符串s拼接到结尾
	string& append(const char*s,int n);  //把字符串前n个字符拼接到结尾
	string& append(const string& s);  
	string& append(const string&s,int pos, int n);  //把字符串s中从pos位置开始的n个字符拼接到字符结尾；

2. 字符查找和替换

npos变量是string类的静态成员，它的值是string对象能储存的最大字符数。由于索引从0开始，所以它币最大的索引大1，因此可以使用它来表示没有查到字符或者字符。

	int find (const string& str, int pos=0)const; //查找str第一次出现的位置，从pos开始查找
	int find(const char* s, int pos=0)const;
	int find(const char* s,int pos,int n)const;  // 从pos位置查找s的前n个字符第一次的位置
	int find(const char c,int pos=0)const;

查找到返回下标，没查到返回-1；

	int rfind(const string& str,int pos=npos)const; // 查找str的位置，从右查找
	int rfind(const char* s,int pos=npos)const;
	int rfind(const char* s,int pos,int n)const;// 从pos查找s的前n个字符，从右开始查找
	int rfind(const char c,int pos=0)const; 
	
	string& replace(int pos,int n,const string& str);//替换从pos开始n个字符为字符串str
	string& replace(int pos,int n,const char* s)

3. string字符串比较

比较方式： 字符串比较是按字符的ascll码进行对比
= 返回  0
> 返回  1
< 返回 -1

	int compare(const string &s)const;
	int compare(const char* s)const;

4. 字符提取

char& operator[](int n);
char& at(int n); //通过at方法获取字符

5. string插入和删除

string& insert(int pos ,const char*s);
string& insert(int pos ,const string& str);
string& insert(int pos ,int n ,char c); //在指定位置插入n个字符c
string& erase(int pos ,int n=npos);  //删除从pos开始的n个字符

插入和删除的起始下标都是从0开始。

	string a="abcdef";
	a.insert(1,"111");
	输出： a==a111bcdef

5. 截取字串

从字符串中截取想要的字串

string substr(int pos=0,int n=npos)const; //返回由pos开始的n个字符串组成的字符串（包含第pos位置的字符）


16.2 智能指针模板类

通过引用智能指针的概念，使得c++不需要手动释放内存

智能指针模板都定义了类似指针的对象，可以将new获得的地址赋给这种对象。当智能指针过期时，其析构函数将使用delete来释放内存。

智能指针的种类：std::unique_ptr ;std::shared_ptr ;std::weak_ptr; 

创建智能指针需要包含头文件#include<memory> ;智能指针模板位于名称空间std中；

1. unique_ptr

三种创建方式：
（1）通过已有裸指针创建；
（2）通过new来创建；
（3）通过std::make_unique创建（推荐）；

uinque_ptr可以通过get（）获取地址；
unique_ptr实现了->和*;

（1）通过落裸指针创建

	Person *s1 = new Person("aaa"); 
	std::unique_ptr<Person> u_s1{s1};

	//这样会导致，当s1改变的时候，u_s1也会跟着改变，所以可以先销毁s1，并指向空；
	delete s1;
	s1 = nullptr;

（2）通过new创建

	std::unique_ptr<Person> u_s2{new Person("aa")};

（3）通过make_unique创建(推荐)

	std::unique_ptr<Person> u_s3 = make_unique<Person>("afdsa");

u_s2.get() //获取地址
u_s3.get() //获取地址


### delete

delete 是在 C++ 中用于释放动态分配的内存并调用对象析构函数的操作符。在释放动态分配的内存时，如果内存中存储的是对象，delete 会首先调用对象的析构函数，然后释放内存。

因此，delete 不仅调用了析构函数，还负责释放与对象相关联的内存。这意味着 delete 做了两件事情：调用析构函数来销毁对象，然后释放对象占用的内存。这与简单地调用析构函数不同，因为析构函数只负责对象的清理工作，而不涉及内存的释放。


	MyClass *ptr = new MyClass(); // 创建对象并分配内存
	delete ptr; // 释放内存并调用析构函数

1.调用 MyClass 类的析构函数，执行对象的清理操作。
2.释放 ptr 指向的内存，使得该内存可以被重用。


16.3 vector容器

头文件： #include<vector>

vector与普通函数的区别：数组是静态空间，而vector是动态扩展；

动态扩展：并不是在原空间之后续接新空间，而是找更大的内存空间，然后将原始数据拷贝到新空间，然后释放原有空间。

vector容器的迭代器是支持随机访问的迭代器；

1. vector构造函数

函数原型：

	vector<T> v;  // 默认构造
	vector(v.begin(),v.end());  // 将v.begin()到v.end()区间的元素拷贝
	vector(n,elem);  //将n个elem拷贝
	vector(const vector &vec);
	 
2. vector赋值

函数原型：

	vector& operator=(const vector& vec);
	assign(beg,end); //将[beg,end)区间中的数据拷贝赋值
	assign(n,elem); //将n个elem拷贝给本身

3. vector容量和大小

函数原型：

	empty();   //判断容器释放为空
	capacity(); //容器的容量
	size(); //返回容器中的元素的个数
	resize(int num)  //重新定义容器的长度，若容器变长，则以默认值0进行填充；若变短，则末尾超出容器的元素被删除
	resize(int num,elem) //以elem进行填充


3. vector插入和删除

函数原型：

	push_back(ele); //尾部插入元素ele
	pop_back();  //删除最后一个元素

	insert(const_iterator pos,ele) //迭代器指定位置pos插入元素ele
	insert(const_iterator pos，int count,ele) //迭代器指定位置pos插入count个元素ele
	insert(const_iterator pos,const_iterator start,const_iterator end)

	erase(const_iterator pos); //删除迭代器指定的元素
	erase(const_iterator start,const_iterator end); //删除迭代器从start到end的元素

	clear（）；  //删除容器中所有元素

4. 数据存放

函数原型：

	at(int idx); //返回索引所指向的数据
	operator[]; 
	front(); //返回第一个数据元素
	back（）；  //返回最后一个元素


5. vector 互换容器

实现两个容器内元素进行互换

函数原型：

	swap(vec);  //将vec与本身的元素互换

6. vector预留空间

减少vector在动态扩展次数

函数原型：

	reserve（int len）; //容器预留len个元素长度，预留位置不可初始化，元素不可访问

16.4 list 列表

STL 列表是一个双向循环链表

1. 创建list容器

函数原型：

	list<T> lst;   //List采用模板类实现，对象的默认构造形式
	list(beg,end); //构造函数将[begin,end)区间中的元素拷贝给本身
	list(n,elem); //构造函数将n个elem拷贝给本身
	list(const list &lst); //拷贝构造函数


2. list赋值和交换

功能：给list容器进行赋值，以及·交换list容器

函数原型：  

	assign(beg,end); //将[beg,end)区间的数据拷贝到本身
	assign(n,elem); //将n个elem拷贝赋值
	list& operator=(const list&lst); //重载等号
	swap(lst); //将lst与本身元素交换

3. list大小操作

功能：对list容器的大小进行操作

函数原型：
	
	size(); //返回容器中元素的个数
	empty(); //判断容器是否为空
	resize(num); //重新指定容器的长度为num，若容器边长，则以默认值填充新位置，如果容器变短，则末尾超出容器长度的元素被删除
	resize(num,elem); //重新指定容器的长度为num，若容器边长，则以elem填充新位置，如果容器变短，则末尾超出容器长度的元素被删除

4. list 插入和删除

功能：对list容器进行数据的插入和删除

函数原型：

	push_back(elem); //在容器尾部加入一个元素
	pop_back(); //删除容器中最后一个元素
	push_front(elem); //在容器开头插入一个元素
	pop_front(); //从容器开始移除第一个元素
	
	insert(pos,elem); //在pos位置插入elem元素的拷贝，返回新数据的位置
	insert(pos,n,elem); //在pos位置插入n个elem数据，无返回值
	insert(pos,beg,end); //在pos位置插入[beg,end)区间的数据，无返回值
	clear(); //移除容器的所有数据
	erase(beg,end); //删除[beg,end)区间的数据，返回下一个数据的位置
	erase(pos); //删除pos位置的数据，返回下一个数据的位置
	remove(elem); //删除容器中所有与elem值匹配的元素


5. list数据存取

功能：对list容器中数据进行存取

函数原型：

	front(); //返回第一个元素
	back(); //返回最后一个元素

注意：list没有[]和at()，不支持随机访问

6. list反转和排序

功能：将容器中的元素反转，以及将容器中的数据进行排序

函数原型：
	
	reverse(); //反转链表
	sort(); //链表排序


16.5 stack栈常用的接口


构造函数：
	
	stack<T> stk;  //stack采用模板类实现，stack对象的默认构造函数
	stack(const stack& stk); //拷贝构造函数
	
	stack& operator=(const stack&stk); //重载等号运算符
	
	push(elem); //添加元素
	pop(); //从栈顶移除第一个元素
	top(); //返回栈顶元素
	
	empty(); //判断堆栈是否为空
	size(); //栈的大小



16.8 queue容器

队列：是一种先进先出的数据结构，

常用的接口：

构造函数：

	queue<T> que;  //默认构造函数
	queue(const queue &que);  //拷贝构造函数

赋值操作：

	queue& operator=(const queue& que);

数据存取

	push(elem); //往队尾添加元素
	pop(); //从对头溢出第一个元素
	back(); //返回最后一个元素
	front(); //返回第一个元素

大小操作：

	empty(); //判断对战是否为空
	size(); //返回栈的大小

16.6 set/multiset容器

所有元素都会在插入时自动排序

本质:set/multiset属于关联式容器，底层结构使用二叉树实现

set和multiset区别：
set不允许容器中有重复的元素；
Multiset允许容器中有重复的元素；

头文件：#include<set>

1. set构造和赋值

创建set容器以及赋值

	set<T>st; //默认构造函数
	set(const set&st); //拷贝构造函数

赋值：

	set& operator=(const set&st);

2. set大小和交换

统计set容器大小以及交换set容器

函数原型：

	size(); //返回容器中元素的数目
	empty(); //判断容器是否为空
	swap(st); //交换两个集合容器

3. set插入和删除

函数原型：

	insert(elem); //在容器中插入元素
	clear(); //清除所有元素
	erase(pos); //删除pos迭代器中所指的元素，返回下一个元素的迭代器
	erase(beg,end); //删除区间[beg,end)的所有元素，返回下一个元素的迭代器
	erase(elem); //删除容器中值为elem的元素

4. set查找和统计

对set容器进行查找数据以及统计

函数原型：

	find(key); //查找key是否存在，若存在，返回改建的元素的迭代器；若不存在，返回set.end()
	count(key); //统计key的元素个数

5. set和multiset区别

	set不可以插入重复数据，而multiset可以；
	set插入数据的同时会返回插入结果，表示插入成功；
	multiset不会检测数据，因此可以插入重复数据；

6. pair队组创建

成对出现的数据，利用对组可以返回两个数据

两种创建方式：
	
	pair<type, type>p(value1,value2);
	pair<type, type>p=make_pair(value1,value2);

p.first,p.second:第一个和第二个值；


16.7 map/multimap容器

简介：
map：中所有的元素都是pair；
pair中第一个元素为key，起到索引作用，第二个元素为value；
所有元素都会根据元素的键值自动排序

本质：
map/multimap属于关联式容器，底层结构是用二叉树实现

优点：
可以根据key值快速找到value值

map/multimap的区别：
map不允许容器有重复key值元素；
multimap允许有重复key值元素

1. map构造和赋值

函数原型：

	map<T1,T2>mp;//默认构造函数
	map(const map&mp);/拷贝构造函数
	
	map& operator=(const map&st);

2. map大小和交换

统计map容器大小以及交换map容器

函数原型：
	
	size(); //返回容器中元素的数目
	empty(); //判断容器是否为空
	swap(st); //交换两个集合容器

3. map插入和删除

函数原型：

	insert(elem); //在容器中插入元素
	clear(); //清除所有元素
	erase(pos); //删除pos迭代器所指的元素，返回下一个元素的迭代器
	erase(beg,end); //删除容器[beg,end)的所有的元素，返回一个元素的迭代器
	erase(key); //删除容器中值为key的元素

4. map查找和统计

函数原型：

	find(key); //查找key是否存在，若存在，返回该键的元素的迭代器；若不存在，返回map.end()
	count(key); //统计key的元素个数














16.3.3 对矢量可执行的其他操作

	for_each(),random_shuffle(),sort()

1. for_each():接收3个参数，前两个是定义容器中区间的迭代器，最后一个是指向函数的指针（准确的说是一个函数对象）。

可以用for_each()代替for循环；

例如：

	vector<double>::iterator pr;
	for(pr=source.begin();pr!=source.end();pr++)
		show(*pr);
	
	for_each(source.begin(),source.end(),show);


2. random_shuffle(): 接收两个参数，并随机排列该区间的元素；函数要求容器类型可以随机访问。

	random_shuffle(source.begin(),source.end())

3. 
4. sort():有两个版本（也要去容器支持随机访问）。

第一个版本：接收两个定义区间的迭代器参数，并使用为存储在容器中的类型元素定义的<运算符，对区间中的元素进行操作。

例如，下面对source的内容进行排序，排序时使用内置的<运算符进行比较：

	vector<int> source;
	sort(source.begin(),source.end());

如果容器元素时用户定义的对象，则要使用sort（），必须定义能够处理该类型的operator<()函数。

例如：
	struct Review{
		string title;
		int rate;
	}

bool operator<(const Review& t1,const Review& t2)
{
	if(t1.title<t2.title)
		return true;
	else if(t1.title == t2.title && t1.rate < t2.rate)
		return true;
	else
		return false;
}

有了这样的函数后，就可以对包含Review对象进行排序了：

	vector<Review>books;
	sort(books.begin(),books.end());


第二个版本：

sort()：接收三个参数，前两个是指定区间的迭代器，最后一个参数是指向要使用的函数的指针（函数对象），而不是用于比较的operator<()函数；返回值可转换为bool,false表示两个参数的顺序不正确。
	
	bool up(const Review& t1,const Review& t2)
	{
		if(t1.rate < t2.rate)
			return true;
		else
			return false;
	}

有了这个函数后，就可以使用sort对books矢量按照rate升序进行排序：

	sort(books.begin(),books.end(),up)

主要看up函数，返回的bool类型为true；
升序：
		if(t1.rate < t2.rate) 
			return true;    
降序：
		if(t1.rate > t2.rate) 
			return true;   



### 迭代器

每个容器都定义一个合适的迭代器，该迭代器的类型是一个名为iterator的typedef，其作用域为整个类。

	vector<double>::iterator pd //为vector的double类型声明一个迭代器

c++自动类型推断：

	vector<double>::iterator pd = source.begin();
	auto pd = source.begin();


用迭代器显示容器内容：
	vector<double> source;
	for(auto pd=source.begin();pd!=sourcr.end();pd++)
		 cout<<*pd;

16.4 泛型编程

16.4.1 为何使用迭代器

模板使得算法独立于存储的数据类型，而迭代器使得算法独立于使用的容器类型。


c++将operator++作为前缀版本，将operator++(int)作为后缀；

STL：每个容器类（vector,list,deque等）都定义了相应的迭代器类型。迭代器都提供了所需的操作，如*,++等。其次每个容器类都有一个超尾标记，当迭代器递增到超越容器的最后一个值后，这个指被赋给迭代器。每个容器都有begin()和end()方法。每个容器都使用++


16.4.2 迭代器类型

STL定义了5中迭代器，并根据所需的迭代器类型对算法进行了描述。5种迭代器分别是：输入迭代器，输出迭代器，正向迭代器，双向迭代器，随即迭代器。

1. 输入迭代器

将容器的信息视为输入。
对输入迭代器进行解引用将使程序能够读取容器种的值，但不一定能保证程序修改值。因此，需要输入迭代器的算法将不会修改容器种的值。

注意：输入迭代器是单向迭代器，可以递增，但不能倒退

2. 输出迭代器

值用来将信息从程序传输非容器的迭代器，因此程序的输出就是容器的输入；输出迭代器和输入迭代器类似，只是接触引用让程序修改容器值，而不能读取。

3. 正向迭代器

与输入迭代器和输出迭代器相似，正向迭代器只使用++运算符来遍历容器，所以它每次沿容器向前移动一个元素；然而，与输入和输出迭代器不同的是，它总是按相同的顺序遍历一系列值。另外，将正向迭代器递增后，仍可以对前面的迭代器值接触引用，并可以得到相同的值。

正向迭代器既可以使得能够以读取和修改数据，也可使得只能读取数据。

4. 双向迭代器

双向迭代器具有正向迭代器的所有特性，同时支持（前缀和后缀）递减运算

5. 随机访问迭代器

随机访问迭代器具有双向迭代器的所有特性，同时添加了支持随机访问的操作（如指针增加运算）和用于元素进行排序的关系运算。


16.4.4 概念、改进和模型

1. 将指针用作迭代器

copy()：可以将数据从一个容器赋值到另一个容器中；有三个参数，前两个迭代器参数是要复制的范围，最后一个迭代器参数是要将第一个元素复制到位置；

copy() 不能自动根据发送值调整目标容器的长度；

输出流的迭代器：STL提供了ostream_iterator模板。用STL的话说，该模板是输出迭代器概念的一个模板，他也是一个适配器（一个类或函数），可以将一些其他接口转换为STL使用的接口。头文件iterator

	`#include <iterator>`
	ostream_iterator<int,char> out_iter(cout," ");	

out_iter迭代器现在是一个接口，让现在能够使用cout来显示信息。第一个模板参数int指出被发送给输出流的数据类型；第二个参数shar指出了输出流使用的字符类型。构造函数第一个参数cout指出 要使用的输出流，它也可以是文件的输出流；最后一个参数是发送给输出流的每个数据项后面显示分隔符；

可以这样使用迭代器：

	*out_iter++ = 15;

对于ostream_iterator这意味着将15和空格符组成的字符串发送到cout管理的输出流中，并为下一个输出操作做好准备。

可以将copy用于迭代器：

	copy(dict.begin(),dict.end(),out_iter);

这意味着将dict容器的整个区间复制到整个区间到输出流中，即显示容器的内容。

iterator头文件还定义了一个istream_iterator模板，使istream输入可用作迭代器接口。可以使用两个istream_iterator对象来定义copy的输入范围：

	copy(istream_iterator<int, char>(cin),istream_iterator<int, char>(), dict.begin());

第一个参数指出要读取的数据类型，第二个参数指出输入流使用的字符类型。使用构造函数参数cin意味着使用由cin管理的输入流，省略构造函数参数表示输入失败，因此上述代码从输入流中读取，直到文件结尾、类型不匹配或出现其他输入故障为止。


2. 其他有用的迭代器

反向迭代器： reverse_iteraor
对reverse_iteraor执行递增操作导致它被递减；

vector类有两个rbegin()和rend()成员函数，前者返回一个指向超尾的反向迭代器，后者返回一个指向第一个元素的反向迭代器。因为对迭代器执行递增操作将导致它被递减，所以可以使用下面的语句进行反向显示内容：

	copy(dict.rbegin(),dict.rend(),out_iter)

注意：rbegin()和end()返回的相同的值（超尾），但类型不同（reverse_iterator和iterator）。同样rend()和begin()返回的值也相同，但是类型不同。

反向指针通过先递减，在解除引用解决：1. rbegin()返回超尾和rend()是第一个元素，则copy()必须提早一个位置停止，因为区间的结尾不包括在区间中。

 16.4.4  关联容器

STL提供4中关联容器：set,multiset,map,multimap
前两种在头文件set，后两者在头文件map中；


16.5 函数对象

函数对象也叫函数符。函数符是可以以函数方式与（）结合使用的任意对象。

函数符的概念：  
1. 生成器：是不用参数就可以调用的函数符  
2. 一元函数：是用一个参数可以调用的函数符  
3. 二元函数：使用两个参数可以调用的函数符  
4. 返回bool值的一元函数是谓词  
5. 返回bool值的二元函数是二元谓词  

重载函数调用操作符的类，其对象称为函数对象  
函数对象使用重载()时，行为类似函数调用，也叫仿函数  

本质:  
函数对象是一个类，不是一个函数。 

例如：提供给for_each()的函数符应当是医院函数，因为它每次用于一个容器元素；

函数对象特点：  
1. 函数对象在使用时，可以像普通函数那样调用，可以有参数，可以有返回值  
2. 函数对象超出普通函数的概念，函数对象可以有自己的状态  
3. 函数对象可以作为参数传递  

sort()第二个版本就是使用二元谓词


###find_if函数

std::find_if(s.begin(), s.end(), aaa());

从s.begin()到 s.end()依次遍历，找到大于某一个值的迭代器，直到s.end()

	class aaa
	{
	public:
		bool operator()(int a)
		{
			return a > n;
		}
		const int n;
		aaa(int qs=8) :n(qs){};
	};
	//........
	for (int i = 0; i < 10; i++)
		s.push_back(i);

	std::vector<int>::iterator m = std::find_if(s.begin(), s.end(), aaa()); //aaa()匿名函数对象

	if (m == s.end())
		std::cout << "not" << std::endl;
	else
		std::cout << *m << std::endl;

### 内建函数

STL内建了一些函数对象；

分类：算术仿函数、关系仿函数、逻辑仿函数

用法：  
1. 这些仿函数所产生的对象，用法和一般函数完全相同  
2. 使用内建函数，需要引入头文件 `#include<functional>`

 
  
(1) 算术仿函数   
 
功能：实现四则运算
其中negate是一元运算，其他都是二元运算；

仿函数原型：  
template<class T>T plus<T> //加法仿函数
template<class T>T minus<T> //减法仿函数
template<class T>T multiplies<T> //乘法仿函数
template<class T>T dicides<T> //除法仿函数
template<class T>T modulus<T> //取模仿函数
template<class T>T negate<T> //取反仿函数

（2）关系仿函数

功能：实现关系对比

原型：

template<class T> bool greater<T>  //大于
template<class T>bool equal_to<T> //等于
template<class T>bool not_equal_to<T> //不等于
template<class T>bool greater_equal<T> //大于等于
template<class T>bool less<T> //小于
template<class T>bool less_equal<T> //小于等于

降序：用greater
	
	std::sort(s.begin(), s.end(),std::greater<int>());

（3）逻辑仿函数

功能：实现逻辑运算

函数原型：

template<class T>bool logicai_and<T> //逻辑与
template<class T>bool logicai_or<T> //逻辑或
template<class T>bool logicai_not<T> //逻辑非



### for_each()函数

std::for_each 是 <algorithm> 头文件中提供的一个算法，它接受一个范围（如容器或数组）和一个函数对象（或函数指针），并对范围中的每个元素调用该函数对象（或函数指针）。它的作用类似于使用循环遍历容器，并对每个元素执行特定操作。

原型：

	template< class InputIt, class UnaryFunction >
	UnaryFunction for_each( InputIt first, InputIt last, UnaryFunction f );
		

16.5 常用的算法

概述：

算法主要是有头文件`<algorithm>`,`<functional>`,`<numeric>`组成

`<algorithm>`是所有STL头文件中最大的一个，范围涉及到比较、交换、遍历、复制、修改等；

`<numeric>`体积很小,只包括几个序列上面简单数学运算的模板函数

`<functional>`定义了一些模板类，用以声明函数对象


16.5.1 遍历算法	

1. `for_each` 遍历容器
2. `transform`搬运容器到另一个容器中

注意：加函数对象的时候，如果是普通函数，加上函数名；若是仿函数，加上函数对象（有小括号）。for_each()：假如是自定义数据，需定义operator<()或者使用仿函数

`transform`：

函数原型：  

	transform(iterator beg1, iterator end1,iterator beg2, _func)

beg1:源容器开始迭代器
end1：原容器结束迭代器
beg2：目标容器开始迭代器
_func:函数或函数对象

	// 仿函数
	class ccc
	{
	public:
		int operator()(int val)
		{
			return val;
		}
	};

	std::vector<int>s;
	for (int i = 0; i < 10; i++)
		s.push_back(i);
	std::vector<int>ss;
	ss.resize(s.size()); //这里注意重新开辟ss的空间
	std::transform(s.begin(), s.end(), ss.begin(), ccc());
	std::for_each(ss.begin(), ss.end(), Print);


16.5.2 查找算法	

算法：

`find`    //查找元素
`find_if`  //按条件查找
`adjacent_find` //查找相邻重复元素
`binary_serch` //二分查找法
`count` //统计元素个数
`count_if` //按条件统计元素个数

1. find

查找指定元素，找到返回指定元素的迭代器，找不到返回结束迭代器end()；

函数原型:

	find(iterator beg, iterator end,value);

beg: 开始迭代器
end: 结束迭代器
value: 查找的值

注意：find是使用数据类型operator==进行比较的，所以假如是自定义数据，需写出重载==函数；

2. find_if

按条件查找元素

函数原型：

	find_if(iterator beg, iteraotr end, _pred);

找到返回指定位置迭代器，没找到返回结束迭代器位置
beg:开始迭代器
end:结束迭代器
_pred:函数或谓词（返回bool类型的仿函数）

3. adjacent_find

查找相邻重复元素

函数原型：

	adjacent_find(iterator beg,iterator end);

查找相邻重复元素，返回相邻元素的第一个位置的迭代器
beg:开始迭代器
end:结束迭代器
使用数据类型operator==进行比较的

4. binary_search

查找指定元素是否存在

函数原型：

	bool binary_search(iterator beg,iterator end,value);

查找指定元素，查到返回true，否则false
注意：在无序序列中不可使用

5. count

统计元素个数

函数原型：

count(iterator beg,iterator end, value);

统计元素出现的次数
beg:开始迭代器
end:结束迭代器
value:统计的元素

注意：底层也是用bool operator==()

6. count_if

按条件统计元素

函数原型

	count_if(iterator beg,iterator end,_pred);

按条件统计元素出现次数
pred：谓词

`upper_bound` 是 C++ 标准库中的一个算法，用于在有序序列中查找第一个大于指定值的元素的位置。它采用二分查找的方式，在序列中定位第一个大于目标值的位置。

     auto it = std::upper_bound(vec.begin(), vec.end(), 5);
    
16.5.3 排序算法

`sort` //对容器内元素进行排序
`random_shuffle` // 指定范围内的元素随机调整次序
`merge` //容器元素合并，并储存到另一容器中
`reverse` //反转指定范围的元素

2. random_shuffle

函数原型：

	random_shuffle(iterator beg,iterator end);

指定范围内的元素随机调整次序
beg:开始迭代器
end:结束迭代器
（使用时加上随机种子）

3. merge

两个容器元素合并，并存储到另一个容器中

函数原型：

	merge(iterator beg1,iterator end1,iterator beg2,iterator end2,iterator dest);

dest: 目标容器开始 
注意：两个容器时有序的,在使用 std::merge() 函数之前，你需要确保目标序列 win2 具有足够的容量来容纳合并后的结果，否则会导致未定义的行为

4. reverse

将容器内元素进行反转

函数原型：

	reverse(iterator beg,iterator end)

反转指定范围的元素

16.5.4 拷贝和替换算法

`copy` //容器内指定分为的元素拷贝到另一容器中
`replace` // 降容器内指定分为的旧元素修改为新元素
`replace_if` // 容器内指定范围的旧元素修改为新元素
`swap`  // 互换两个容器的元素


1. copy

函数指定范围内的元素拷贝到另一个容器中

函数原型：

	copy(iterator beg,iterator end,iterator dest);

2. replace

将容器内指定范围的旧元素修改为新元素

函数原型：

	replace(iterator beg,iterator end,oldvalue,newvalue)

oldvalue:旧元素
newvalue：新元素

3. replace_if

按条件替换元素，满足条件的替换成指定元素

函数原型：

	replace_if(iterator beg,iterator end,_pred,newvalue);

_pred:谓词
newvalue: 替换的新元素

4. swap

互换两个容器的元素

函数原型：

	swap(container c1,contatiner c2);

c1:容器1
c2:容器2
（容器同类型）




16.5.5 常用算术生成算法

头文件：`#include<numeric>`

`accumulate` //计算容器元素累计总和
`fill` //像容器中添加元素

1. `accumulate`

函数原型;

	accumulate(iterator beg,iterator end, value);

计算容器元素累计和
value：起始值

2. `fill`

函数原型：

	fill(iterator beg,iterator end,value);

向容器中填入元素
value:填入的元素


16.5.6 集合算法

`set_intersection` // 求两个容器的交集
`set_union` //求两个容器的并集
`set_difference` // 求两个容器的差集

1. set_intersection

set_intersection（iterator beg1,iterator end1,iterator beg2,iterator end2,iterator dest）

求两个集合的交集
注意：两个容器必须是有序序列
dest：目标容器开始迭代器
返回值是：指向交集末尾的迭代器（end()）

2.set_union

set_union（iterator beg1,iterator end1,iterator beg2,iterator end2,iterator dest）

求两个集合的并集
注意：两个容器必须是有序序列
dest：目标容器开始迭代器
返回值是：指向交集末尾的迭代器（end()）

3.set_difference

set_difference（iterator beg1,iterator end1,iterator beg2,iterator end2,iterator dest）

求两个集合的交集
注意：两个容器必须是有序序列
dest：目标容器开始迭代器
返回值是：指向交集末尾的迭代器（end()）

### 
!isspace(x) 检查字符 x 是否不是空白字符。如果 x 不是空白字符，则表达式的值为 true。  
!ispunct(x) 检查字符 x 是否不是标点符号。如果 x 不是标点符号，则表达式的值为 true。  

这个条件语句 if (!isspace(x) && !ispunct(x)) 是用来检查字符 x 是否既不是空白字符（空格、制表符等），也不是标点符号（如逗号、句号等）。这种情况下，它会返回 true，表示字符 x 是一个可打印的字符（printable character），即它是字母、数字或其他可打印的符号。


### unique

std::unique 是 C++ 标准库 <algorithm> 头文件中提供的一个函数模板，用于在容器中移除连续的重复元素。它将相邻的重复元素移动到容器末尾，并返回一个指向新的“逻辑结束位置”的迭代器，指示不重复的元素的范围。


	template< class ForwardIt >
	ForwardIt unique( ForwardIt first, ForwardIt last );
	
first 和 last 是容器的起始迭代器和结束迭代器，表示要处理的元素范围。[first, last) 表示左闭右开区间，即包含 first，但不包含 last。
函数返回一个指向新的“逻辑结束位置”的迭代器，指示不重复的元素的范围。

std::unique 函数只能移除相邻的重复元素，如果容器中的重复元素不相邻，则需要先对容器进行排序，然后再使用 std::unique。

注意：std::merge() 函数的第四个参数上。在你的代码中，你没有指定目标序列的起始位置，而是直接使用了 win2.begin()，这会导致未定义的行为，因为 win2 目前是一个空的向量，其 begin() 方法返回的迭代器并不指向有效的位置。你需要确保目标序列 win2 至少具有足够的容量，或者在调用 std::merge() 函数之前使用 resize() 方法来为目标序列分配足够的空间。


### static_cast

C++ 强制类型转换运算符的用法如下：


	强制类型转换运算符 <要转换到的类型> (待转换的表达式)


```cpp
	double d = static_cast <double> (3*5);  //将 3*5 的值转换成实数
```

static_cast 用于进行比较“自然”和低风险的转换，如整型和浮点型、字符型之间的互相转换。另外，如果对象所属的类重载了强制类型转换运算符 T（如 T 是 int、int* 或其他类型名），则 static_cast 也能用来进行对象到 T 类型的转换。

static_cast 不能用于在不同类型的指针之间互相转换，也不能用于整型和指针之间的互相转换，当然也不能用于不同类型的引用之间的转换。因为这些属于风险比较高的转换。
###cout输出对齐
头文件：#include <iomanip>
后对齐：
`cout << setw(10) << a << endl;`
前对齐：
 `cout << left << setw(10) << a << endl;`
###lambda表达式

Lambda表达式是C++11引入的一种匿名函数，它可以用来创建临时的、一次性的函数对象。Lambda表达式的一般形式如下：

[capture list] (parameter list) -> return type { function body }

capture list：用于捕获变量。可以是空的、值捕获（以值的方式捕获）、引用捕获（以引用的方式捕获）或混合捕获。
parameter list：参数列表，就像函数参数一样。
return type：返回类型，可以省略，编译器会自动推导。
function body：函数体。

    for_each(D.begin(), D.end(), [](const int a) {cout << a << " "; });


可以使用范围-based for 循环来遍历 vector 的每个元素，也可以使用标准库中的 for_each 算法


```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // 使用范围-based for 循环遍历
    std::cout << "Using range-based for loop:" << std::endl;
    for (int num : vec) {
        std::cout << num << " ";
    }
    std::cout << std::endl;

    // 使用 for_each 算法遍历
    std::cout << "Using for_each algorithm:" << std::endl;
    std::for_each(vec.begin(), vec.end(), [](int num) {
        std::cout << num << " ";
    });
    std::cout << std::endl;

    return 0;
}

```


### 在一个类中定义常量作为数组的最大值
可以使用枚举、const 或 static 成员变量。每种方法都有其特点和适用场景：

1.. 枚举（enum）：枚举是一种用于定义命名整数常量的方式。你可以在类中定义一个枚举类型，其中包含数组的最大值。例如：

```cpp
class MyClass {
public:
    enum { MaxSize = 100 };
};

```
这种方式可以让你通过 MyClass::MaxSize 来访问最大值，并且能够保证该值在类内部是唯一的。

2.. const 成员变量：你可以在类中定义一个 const 成员变量作为数组的最大值。这样做可以将最大值与类的实例关联起来，但它的值在每个实例中都是相同的。

```cpp
class MyClass {
public:
    static const int MaxSize = 100;
};
```
这种方式可以通过 MyClass::MaxSize 来访问最大值，并且能够保证该值在整个程序中是唯一的。

3.. static 成员变量：你也可以将最大值定义为静态成员变量。这样做可以将最大值与类关联起来，但可以在程序中对其进行修改。但需要注意的是，你需要在类的实现文件中进行初始化。

```cpp
class MyClass {
public:
    static int MaxSize;
};

// 在实现文件中初始化
int MyClass::MaxSize = 100;
```
这种方式可以通过 MyClass::MaxSize 来访问最大值，但它可以在程序运行时进行修改，因此需要特别小心。

###iota

iota函数会从指定的值开始，然后递增地为容器中的每个元素赋予连续的值。下面是一个示例代码：

`#include <numeric> // 包含 iota 函数`

```cpp
#include <iostream>
#include <vector>
#include <numeric> // 包含 iota 函数

int main() {
    int n = 10; // 你要赋值的范围是从0到n-1
    std::vector<int> vec(n);

    // 使用 iota 函数从0开始赋值
    std::iota(vec.begin(), vec.end(), 0);

    // 输出赋值后的向量内容
    for (int i : vec) {
        std::cout << i << " ";
    }
    std::cout << std::endl;

    return 0;
}

```
### max_element

用于在给定范围内查找最大元素，并返回指向该元素的迭代器。它在 <algorithm> 头文件中声明。

```cpp
template< class ForwardIt >
ForwardIt max_element( ForwardIt first, ForwardIt last );

template< class ForwardIt, class Compare >
ForwardIt max_element( ForwardIt first, ForwardIt last, Compare comp );
```
first 和 last 是表示要搜索的元素范围的迭代器。搜索范围包括 [first, last)，即左闭右开区间。
comp 是一个可选的二元谓词，用于定义比较规则。如果未提供此参数，函数将使用默认的 < 比较运算符进行比较。
max_element 返回一个迭代器，指向范围内的最大元素。如果范围为空，则返回 last

### 

### 初始化列表
在C++中，类成员变量的初始化器不能引用同一个类中声明的常量成员。这是因为在类体内的成员声明是顺序无关的，编译器无法保证在初始化成员变量时常量成员已经被定义。因此，你需要使用初始化列表在构造函数中初始化成员变量，这样才能正确引用类中的常量成员。

### 指针差
为什么计算同一类型结构中的两个指针之差，结构的数据类型是long，值等于两个地址之差除以该数据类型的大小。
计算同一类型结构中的两个指针之差实际上是计算这两个指针之间相隔的元素个数。
当你计算两个指向相同类型的指针之间的差值时，结果是这两个指针之间相隔的元素数量。例如，对于指针 ptr1 和 ptr2（都指向同一个数组或同一个类型的内存块），表达式 ptr2 - ptr1 将返回它们之间的元素个数。这是因为指针之间的差值实际上是它们的地址差除以元素的大小。
# 第17章（2024.4.21）

c++把输入和输出看作字节流。输入时，程序从输入流中抽取字节；输出时，程序将字节插入到输出流中。

c++程序只是检查字节流，而不需要知道字节来自何方。同时，通过使用字节流，c++程序处理输出的方式将独立于去向。




头文件 <fstream>

1. 文本文件：文件以文本的ASCLL码形式存储
2. 二进制文件：文件以文本的二进制形式存储在计算机中

操作文件的三类：
1. ofstream:写操作
2. ifstrean：读操作
3. fstream：读写操作




# 第18章 c++新标准

1. auto
	用于实现自动类型推断，

2. Lambda函数



































