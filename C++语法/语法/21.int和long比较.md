## 2. int 和 long类型比较
  在 C++ 中，当你比较 int 和 long 类型的变量时，int 会被隐式转换为 long。这是因为 C++ 会将较小范围的整数类型转换为较大范围的整数类型，以确保比较的操作数具有相同的类型。
  
  C++ 有一套复杂的规则来决定不同类型之间如何进行转换，这些规则被称为类型提升规则。
  在比较不同整数类型时，通常会将较小范围的整数类型提升为较大范围的整数类型以进行比较。

  这种转换是由编译器处理的，不会对性能产生显著影响。
  不过，理解这些转换规则有助于避免潜在的类型错误和确保代码的正确性。

  `LONG_MIN` 定义了 `long `类型的最小值。
  `LLONG_MIN` 定义了 `long long` 类型的最小值。

  在32位系统中，int 和 long 都是 4 字节的情况下，INT_MIN 和 LONG_MIN 确实会是一样的，因为它们的范围相同。但在64位系统上，long 通常是8字节，int 仍然是4字节
  **32位系统**
    + int: 4 字节
    + long: 4 字节
    + long long: 8 字节
  **64位系统**
    + int: 4 字节
    + long: 8 字节
    + long long: 8 字节
## 3. 匿名结构体和命名结构体
  1.  匿名结构体
   ```cpp
    struct {
    struct spinlock lock;
    struct run *freelist;
    } kmem;
   ```
  
  + 这是一个匿名结构体，它没有名称。在这种定义中，结构体本身没有名字，而只是声明了一个名为kmem的变量，其类型是这个匿名结构体。
  
  + 在这种定义方式下，kmem是这个结构体的一个实例。你只能使用kmem来访问其成员lock和freelist。
  
  + 如果你想在程序的其他地方定义更多这种结构体类型的变量，你需要重复这个结构体定义。
  
  2. 命名结构体
   ```cpp
    struct kmem {
    struct spinlock lock;
    struct run *freelist;
    };
   ```
   + 这是一个命名结构体，结构体的类型名是kmem。你可以在程序的任何地方使用struct kmem来声明更多的变量。
   
   + 这种定义方式允许你在其他地方创建多个相同类型的结构体实例。例如，你可以定义struct kmem类型的多个变量，如struct kmem kmem1, kmem2;。
  
如果你只需要一个结构体实例，且不打算在其他地方重用相同类型的结构体，可以使用匿名结构体定义。

如果你需要在多个地方创建结构体实例，或者希望代码更具可读性和重用性，应该使用命名结构体定义。