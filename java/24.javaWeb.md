# springBoot

## 1. 创建项目

![](./图片/springboot-1.png)

![](./图片/springboot-2.png)

在com.yzx包下创建一个 HelloController 处理函数；

请求处理函数写法：
```java
@RestController // 标识请求处理类
public class HelloController {
    @RequestMapping("/hello") // 标识
    public String sayHello() {
        System.out.println("Hello World");
        return "Hello World";
    }
}
```

在存放源码的src/main/java目录中，Spring Boot对Java包的层级结构有一个要求。注意到我们的根package是com.itranswarp.learnjava，下面还有entity、service、web等子package。Spring Boot要求main()方法所在的启动类必须放到根package下，命名不做要求，这里我们以Application.java命名，它的内容如下：

```java
@SpringBootApplication
public class Application {
    public static void main(String[] args) throws Exception {
        SpringApplication.run(Application.class, args);
    }
}
```

启动端口 8080；

启动Spring Boot应用程序只需要一行代码加上一个注解@SpringBootApplication，该注解实际上又包含了：

+ @SpringBootConfiguration
    + @Configuration
+ @EnableAutoConfiguration
    + @AutoConfigurationPackage
+ @ComponentScan


## 2. 请求处理函数

✅ 1. 基本示例：处理 GET 请求

```java
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/hello")  // 类上的路径前缀
public class HelloController {

    @GetMapping("/say")  // 处理 GET 请求 /hello/say
    public String sayHello() {
        return "Hello, Spring Boot!";
    }
}
```

✅ 2. 接收参数的几种方式：

👉 方式一：路径参数（PathVariable）

```java
@GetMapping("/user/{id}")
public String getUser(@PathVariable("id") int id) {
    return "User ID: " + id;
}

```

👉 方式二：请求参数（RequestParam）

```java
@GetMapping("/search")
public String search(@RequestParam("q") String query) {
    return "Search query: " + query;
}
```

👉 方式三：请求体 JSON（Post 请求，RequestBody）
```java
@PostMapping("/user")
public String createUser(@RequestBody User user) {
    return "Received user: " + user.getName();
}
```
其中 User 是一个 POJO 类：
```java
public class User {
    private String name;
    private int age;

    // 记得加 getter/setter 或用 @Data 注解
}
```

✅ 3. 返回 JSON 对象
```java
@GetMapping("/json")
public User getUserJson() {
    User user = new User();
    user.setName("Tom");
    user.setAge(20);
    return user;  // 会自动转为 JSON 响应
}
```

✅ 4. 处理 POST 请求（表单或 JSON）
```java
@PostMapping("/submit")
public String handleForm(@RequestParam String name, @RequestParam int age) {
    return "Name: " + name + ", Age: " + age;
}
```

🔍 你可以理解为：

注解 | 描述 | 对应 HTTP 方法
---|---|---
@GetMapping | 处理 GET 请求 | GET
@PostMapping | 处理 POST 请求 | POST
@PutMapping | 处理 PUT 请求 | PUT
@DeleteMapping | 处理 DELETE 请求 | DELETE
@RequestBody | 从请求体中读取 JSON 数据，绑定到对象 | 任意（常用于 POST/PUT）
@RequestParam | 从 URL 查询参数中获取数据 | 任意（常用于 GET）
@PathVariable | 从路径中提取变量 | 任意


## 3. springbootweb 入门解析

![](./图片/springboot-3.png)

springboot 已经内嵌了Tomcat依赖，端口 8080；
![](./图片/springboot-4.png)

## 4. 请求响应

![](./图片/springboot-5.png)

DispacherServlet 用来接受和分发请求；

怎么包装请求和响应呢？
用两个对象：HttpServletRequest和HttpSerletResponse;
本质上就是 http请求和相应报文的包装类；

![](./图片/springboot-6.png)

📦 详细解释：

📨 HttpServletRequest：封装客户端请求的所有信息
它其实就是对 HTTP 请求报文 的封装，里面包含了：

+ 请求头（Headers）
+ 请求体（Body）
+ 方法类型（GET、POST等）
+ 请求参数（Query参数、Form表单）
+ 客户端 IP、Cookies 等

你可以通过这个类访问：

```java
request.getMethod();           // 请求方法 GET/POST
request.getHeader("User-Agent");
request.getParameter("name");  // 获取请求参数
request.getInputStream();      // 原始请求体（用于读取 JSON）
```

📤 HttpServletResponse：封装服务端返回给客户端的响应
这个类对应的是服务器返回的 HTTP 响应报文，你可以设置：

+ 响应状态码（200，404等）
+ 响应头（Content-Type 等）
+ 响应体内容（文本、JSON、文件等）

```java
response.setStatus(200);
response.setHeader("Content-Type", "application/json");
response.getWriter().write("{\"msg\": \"Hello\"}");
```

✅ 在 Spring Boot 中通常不用直接操作它们
因为 Spring Boot 已经封装了很多底层操作，你通常只需要这样写就好：

```java
@GetMapping("/hello")
public String hello() {
    return "Hello World"; // Spring Boot 会自动包装成 HTTP 响应
}
```

但如果你真的需要访问原始请求或响应，可以这样注入：

```java
@GetMapping("/info")
public void info(HttpServletRequest request, HttpServletResponse response) throws IOException {
    String userAgent = request.getHeader("User-Agent");
    response.setContentType("text/plain");
    response.getWriter().write("Your User-Agent is: " + userAgent);
}
```

### 4.1 请求

#### 4.1.1 简单参数

简单参数：参数名与形参变量名相同，定义形参即可接受参数

![](./图片/springboot-7.png)

✅ 1. @RequestParam：获取 URL 查询参数、表单参数
用于接收 URL 中的 ?name=xxx 形式的参数：

注意：@RequestParam中required属性默认true，代表改请求参数必须传递，如果不传递将报错。

如果该参数是可选的，可以将required属性设置为false；

```java
@RequestMapping("/hello")
public String sayHello(@RequestParam String name, @RequestParam int age) {
    System.out.println("Hello " + name + " " + age);
    return "Hello " + name + " " + age;
}
```

##### @RequestMapping 用法

🧩 基本用法
✅ 1. 获取 GET 请求的查询参数
```java
@GetMapping("/hello")
public String hello(@RequestParam String name) {
    return "Hello, " + name;
}
```

访问：`GET /hello?name=Tom`
返回：`Hello, Tom`

✅ 2. 设置参数名（当变量名和参数名不一致时）

```java
@GetMapping("/hello")
public String hello(@RequestParam("username") String name) {
    return "Hello, " + name;
}
```

请求 URL：`GET /hello?username=Alice`

✅ 3. 设置默认值和是否必填

```java
@GetMapping("/greet")
public String greet(@RequestParam(required = false, defaultValue = "Guest") String name) {
    return "Hi, " + name;
}
```

请求 /greet 或 /greet?name=Jack 都可以：

+ 没有传参数时：Hi, Guest
+ 传了参数：Hi, Jack


✅ 4. 接收多个参数
```java
@GetMapping("/sum")
public int sum(@RequestParam int a, @RequestParam int b) {
    return a + b;
}
```

✅ 5. 接收数组或集合参数
```java
@GetMapping("/ids")
public String ids(@RequestParam List<Integer> ids) {
    return "IDs: " + ids;
}
```

请求：`GET /ids?ids=1&ids=2&ids=3`

💡 与 POST 表单结合使用
```java
@PostMapping("/login")
public String login(@RequestParam String username, @RequestParam String password) {
    return "Username: " + username;
}
```

表单提交：
```java
Content-Type: application/x-www-form-urlencoded

username=Tom&password=123456
```

#### 4.1.2 实体参数

规则：请求参数名与形参对象属性名相同，即可直接接受；

![](./图片/springboot-8.png)

创建一个 Java 类（POJO），用来封装前端传过来的多个参数，Spring Boot 会自动根据参数名进行匹配并赋值。

✅ 用法示例

1. 定义一个实体类
```java
package com.yzx.pojo;

public class User {
    private String name;
    private int age;
    private Address address;

    @Override
    public String toString() {
        return "User{" +
                "name='" + name + '\'' +
                ", age=" + age +
                ", address=" + address +
                '}';
    }

    public Address getAddress() {
        return address;
    }

    public void setAddress(Address address) {
        this.address = address;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

}


package com.yzx.pojo;

public class Address {
    private String province;
    private String city;

    public String getProvince() {
        return province;
    }

    public void setProvince(String province) {
        this.province = province;
    }

    public String getCity() {
        return city;
    }

    public void setCity(String city) {
        this.city = city;
    }

    @Override
    public String toString() {
        return "Address{" +
                "province='" + province + '\'' +
                ", city='" + city + '\'' +
                '}';
    }
}

```

2. 控制器中接收实体参数
```java
@RestController
public class UserController {

    @GetMapping("/user")
    public String getUser(User user) {
        return "username: " + user.getUsername() + ", age: " + user.getAge();
    }
}
```

请求 URL 示例：[GET /user?username=Tom&age=22](http://localhost:8080/simplePojo?age=12&name=qwe&address.province=啊&address.city=是)

Spring 会根据参数名自动给 User 实体类里的字段赋值。

✅ 用于 POST 表单提交

```java
@PostMapping("/user")
public String createUser(User user) {
    return "Created user: " + user.getUsername();
}
```

适用于表单数据（application/x-www-form-urlencoded）

✅ 用于 POST JSON 提交（重要❗）

```java
@PostMapping("/json")
public String postJson(@RequestBody User user) {
    return "Received: " + user.getUsername();
}
```

注意：
+ 这个时候要加上 @RequestBody
+ 前端要发送 Content-Type: application/json 的 JSON 数据

示例 JSON 请求体：
```java
{
  "username": "Alice",
  "age": 25
}
```

#### 4.1.3 数组集合参数

请求：

![](./图片/springboot-9.png)

✅ 一、接收数组或集合参数：@RequestParam 接收查询参数

🌟 示例请求：http://localhost:8080/test?ids=1&ids=2&ids=3

```java
@GetMapping("/test")
public String testArray(@RequestParam List<Integer> ids) {
    return "接收到的 ids: " + ids;
}
```

你也可以使用 Integer[] 数组类型接收：
```java
@GetMapping("/test")
public String testArray(@RequestParam Integer[] ids) {
    return "接收到的 ids: " + Arrays.toString(ids);
}
```

#### 4.1.4 日期参数

✅ 使用 @DateTimeFormat

如果你想接收格式为 yyyy-MM-dd HH:mm:ss 的时间，可以用这个注解：

```java
import org.springframework.format.annotation.DateTimeFormat;

@GetMapping("/date")
public String getDate(@RequestParam("time")
                      @DateTimeFormat(pattern = "yyyy-MM-dd HH:mm:ss") Date time) {
    return "收到的日期是: " + time;
}
```

🔍 请求示例：

```java
http://localhost:8080/date?time=2024-04-21%2012:34:56
```
注意空格需要编码成 %20。


✅ 方式 2：使用 LocalDate、LocalDateTime（推荐）

```java
@GetMapping("/date2")
public String getDate(@RequestParam("time")
                      @DateTimeFormat(pattern = "yyyy-MM-dd HH:mm:ss") LocalDateTime time) {
    return "收到的时间是: " + time;
}

```

对应 URL：
http://localhost:8080/date2?time=2024-04-21%2014:23:00


#### 4.1.5 路径参数是JSON



✅ POST JSON 场景（@RequestBody）

如果你用的是 @RequestBody 接收 JSON，那格式控制应该交给 Jackson（Spring Boot 默认的 JSON 序列化库）。


![](./图片/springboot-10.png)
![](./图片/springboot-11.png)


```java
@RequestMapping("/jsonParam")
public String jsonParam(@RequestBody User user) {
    return user.toString();
}
```

#### 4.1.6 路径参数

![](./图片/springboot-12.png)

```java
@RequestMapping("/path/{id}/{name}")
public String path(@PathVariable String id, @PathVariable String name) {
    return id+":"+name;
}
```

#### 4.1.7 总结

参数位置 | 支持的方法 | 后端接收方式
---|---|---
URL路径参数 | GET/POST/PUT/DELETE | @PathVariable
查询字符串参数 | GET（也可POST等） | @RequestParam
表单体（键值对） | POST | @RequestParam
请求体（JSON） | POST/PUT/DELETE | @RequestBody
文件上传参数 | POST（multipart） | @RequestParam + MultipartFile

✅ 1. URL路径参数（Path Variable）

```sql
GET /user/123
```

+ 123 是 userId
+ 后端用 @PathVariable 接收

```java
@GetMapping("/user/{id}")
public String getUser(@PathVariable("id") Long id) {
    // ...
}
```

✅ 2. 查询字符串参数（Query Parameter）

常用于 GET 请求，也可以用于 POST：

```sql
GET /user/list?page=1&pageSize=10
```

+ 前端传在 URL 的 ? 后面
+ 后端用 @RequestParam 接收：

```java
@GetMapping("/user/list")
public List<User> list(@RequestParam("page") int page,
                       @RequestParam("pageSize") int size) {
    // ...
}
```

✅ 3. 请求体参数（Request Body）

用于 POST、PUT、DELETE 等请求方式：

🔸 表单方式（application/x-www-form-urlencoded）

表单键值对格式：

```html
<form method="post" action="/add">
    <input name="username">
    <input name="age">
</form>
```

后端用 @RequestParam 接收：

```java
@PostMapping("/add")
public String add(@RequestParam("username") String name) { ... }
```

🔸 JSON格式（application/json）

适合复杂对象传递：

```json
POST /add
Content-Type: application/json

{
  "username": "Tom",
  "age": 20
}
```

后端用 @RequestBody 接收：

```java
@PostMapping("/add")
public String add(@RequestBody User user) { ... }
```

✅ 4. 上传文件（multipart/form-data）

文件 + 表单一起传：

```html
<form enctype="multipart/form-data">
    <input type="text" name="username">
    <input type="file" name="avatar">
</form>

```

后端：

```java
@PostMapping("/upload")
public String upload(@RequestParam("username") String name,
                     @RequestParam("avatar") MultipartFile file) { ... }
```



### 4.2 设置相应数据

![](./图片/springboot-13.png)


```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Controller
@ResponseBody
public @interface RestController {
}
```

🧩 一、最基本的返回：字符串

```java
@RestController
public class HelloController {
    @GetMapping("/hello")
    public String sayHello() {
        return "Hello Spring Boot!";
    }
}
```

默认返回的是字符串，响应类型是：text/plain

🧩 二、返回对象（自动转 JSON）
```java
@RestController
public class UserController {
    @GetMapping("/user")
    public User getUser() {
        return new User(1, "Tom");
    }
}
```
```java
public class User {
    private int id;
    private String name;

    // 构造器、getter、setter 省略
}
```
✅ 响应结果（自动转 JSON）：
```java
{
  "id": 1,
  "name": "Tom"
}
```

这得益于 Spring Boot 默认集成的 Jackson（对象 <-> JSON 自动转换）

🧩 三、返回集合
```java
@GetMapping("/list")
public List<User> getUserList() {
    return Arrays.asList(
        new User(1, "Tom"),
        new User(2, "Jerry")
    );
}
```

✅ 响应 JSON：
```java
[
  {"id":1,"name":"Tom"},
  {"id":2,"name":"Jerry"}
]
```

🧩 四、自定义响应格式（统一返回结构）

很多项目中会统一封装响应，比如：

```java
public class Result<T> {
    private int code;
    private String message;
    private T data;

    public static <T> Result<T> success(T data) {
        return new Result<>(200, "success", data);
    }

    public static <T> Result<T> error(String message) {
        return new Result<>(500, message, null);
    }

    // 构造器 / getter / setter
}

```

Controller 使用：
```java
@GetMapping("/info")
public Result<User> getInfo() {
    return Result.success(new User(1, "Tom"));
}
```
✅ 响应：
```java
{
  "code": 200,
  "message": "success",
  "data": {
    "id": 1,
    "name": "Tom"
  }
}
```

### 4.3 demo

```java
@RestController
public class EmpController {

    @RequestMapping("/listEmp")
    public Result list(){
        // 加载并解析.xml
        String file = this.getClass().getClassLoader().getResource("emp.xml").getFile();
        System.out.println(file);
        List<Emp> empList = XmlParserUtils.parse(file, Emp.class);
        // 数据转化处理
        empList.stream().forEach(emp -> {
            String gender = emp.getGender();
            if("1".equals(gender)){
                emp.setGender("M");
            }else if("2".equals(gender)){
                emp.setGender("F");
            }

            String job = emp.getJob();
            if("1".equals(job)){
                emp.setJob("讲师");
            }else if("2".equals(job)){
                emp.setJob("班主任");
            }else if("3".equals(job)){
                emp.setJob("就业指导");
            }
        });

        return Result.success(empList);
    }
}
```


在 Spring Boot 中是可以正确拿到 resources 目录下的 emp.xml 文件的路径的：
```java
String file = this.getClass().getClassLoader().getResource("emp.xml").getFile();
```

1️⃣ this.getClass()
获取当前对象的 Class 对象，比如 com.example.MyClass。
2️⃣ getClassLoader()
获取这个类的 类加载器（ClassLoader）。在大多数 Java 程序中，这返回的是 AppClassLoader，它专门用来加载你项目的 .class 文件和 resources 资源文件。
3️⃣ getResource("emp.xml")
这个方法会在 类路径（classpath） 中查找你传入的资源：

src/main/resources/emp.xml 会在编译后变成：
```java
target/classes/emp.xml
```
所以 getResource("emp.xml") 就能找到它。返回的是一个 URL 对象。

例如：
```java
file:/D:/workspace/your_project/target/classes/emp.xml
```
4️⃣ getFile()
从 URL 中获取文件路径字符串，就是：

```java
"D:/workspace/your_project/target/classes/emp.xml"
```
你就可以拿这个路径去做 FileReader、new File(path) 之类的操作了。


✅ 一、前提条件
你必须确保文件路径是这样：
```java
src
 └── main
     └── resources
         └── emp.xml
```
这个路径下的文件，在构建时会被自动打包到 target/classes 目录中，也就是类路径的一部分（Classpath）。

✅ 二、推荐方式：获取 URL、InputStream、Path
✔️ 1. 获取文件路径（你的方式）

```java
String path = this.getClass().getClassLoader().getResource("emp.xml").getFile();
System.out.println(path);
```

✔️ 2. 获取 URL（更通用）
```java
URL url = this.getClass().getClassLoader().getResource("emp.xml");
```

✔️ 3. 获取 InputStream（最常用，用于读配置文件）
```java
InputStream in = this.getClass().getClassLoader().getResourceAsStream("emp.xml");
```

✔️ 4. 使用 Resource（Spring 提供，支持多种资源）
```java
@Resource
private ResourceLoader resourceLoader;

public void readFile() throws IOException {
    Resource resource = resourceLoader.getResource("classpath:emp.xml");
    InputStream in = resource.getInputStream();
}
```

或使用静态注入：
```java
Resource resource = new ClassPathResource("emp.xml");
InputStream in = resource.getInputStream();
```

### 4.4 分层解耦

#### 4.4.1 三层架构

![](./图片/springboot-14.png)

![](./图片/springboot-15.png)


+ controller : 控制层，接受前端发送的请求，对请求进行处理，并相应数据
+ service : 业务逻辑层，处理具体的业务逻辑
+ dao : 数据访问层（Data Access Object），负责数据访问操作，包括数据的增删改查；

demo 代码拆分：
![](./图片/springboot-16.png)

![](./图片/springboot-17.png)

#### 4.4.2 分层解耦 IOC & DI

![](./图片/springboot-18.png)

上述代码，通过创建对象来建立每层之间的关系。所以耦合性较强；
通过控制反转和依赖注入来解耦；

![](./图片/springboot-19.png)

**IOC & DI 的实现通过加上@Componet和@Autowired实现；**

![](./图片/springboot-20.png)

所以说如果想使用 EmpServiceB 这个服务，只需在类上加上 @Component，然后再把 EmpServiceA 上的 @Component 去掉，就行了；

> IOC 

Component的衍生：

![](./图片/springboot-21.png)

> Bean 组件扫描

![](./图片/springboot-22.png)


> DI

![](./图片/springboot-23.png)

![](./图片/springboot-24.png)

## 5. Mysql

远程连接：

mysql -u用户名 -p密码 -h ip地址 -P 端口号

[mysql的使用](../Mysql/使用/1.基础.md)

+ Idea中操作数据库设置列的主键、唯一、非空、递增等属性

![](./图片/idea-table.png)

注意要加上基础字段：id,create_time,update_time;

ctrl+alt+l 进行格式化；


多表：一对多
+ 实现：在数据表中多的一方，添加字段，来关联一的一方的主键；

![](./图片/mysql_一对多.png)

多表：一对一
+ 一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其他字段放在另一张表中，以提高操作效率；
+ 实现：在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的；可以看成一对多的特殊形式；

多表：多对多
+ 实现：建立第三张中间表，中间表至少包含两个外键，分别关联两方主键；


多表设计流程
+ 阅读页面原型及需求文档，分析各个模块涉及到的表结构，及表结构之间的关系
+ 根据页面原型及需求文档，分析各个表结构中具体的字段及约束。

![](./图片/mysql-苍穹外卖表结构.png)

## 6. Mybatis

https://mybatis.net.cn/

1. 准备工作(创建springboot工程、数据库表user、实体类User)

实体类的成员变量和数据库表一一对应；

![](./图片/springboot-mybits.png)

2. 引入Mybatis的相关依赖，配置Mybatis(数据库连接信息)

![](./图片/springboot-mybits2.png)

3. 编写SQL语句(注解/XML)

```java
@Mapper
public interface UserMapper {    
    @Select("select *  from user")  
    public List<User> list();
    }
```

这里不需要写实现类，spring会自动实现；这里采用的是注入依赖，所以后面直接定义就行；

3. 单元测试

```java
@SpringBootTest class SpringbootMybatisQuickstart1ApplicationTests {            
    @Autowired    
    private UserMapper userMapper;
    @Test    
    public void test1(){       
        List<User> userList = userMapper.list();        userList.stream().forEach(user -> {
            System.out.println(user);        
        });    
    }
}
```

### 6.1 LOMBOK

![](./图片/springboot-lombok.png)

### 6.2 Mybits 删除

用 '#{}' 来接受参数；

```java
    @Delete("delete from tb_emp where id = #{id}")
    public int deleteByPrimaryKey(Integer id);
```

开启日志：

![](./图片/springboot-mybitslog.png)

### 6.3 Mybits 新增

这里的 @Options(useGeneratedKeys = true, keyProperty = "id") 是主键返回，保存在 id 中；

```java
    @Options(useGeneratedKeys = true, keyProperty = "id")
    @Insert("insert into tb_emp(username, name, gender, image, job, entrydate, dept_id, create_time, update_time)" +
            " values (#{username},#{name},#{gender},#{image},#{job},#{entrydate},#{deptId},#{createTime},#{updateTime})")
    public void insert(Emp emp);

```

### 6.4 Mybits 更新

```java
    //更新员工
    @Update("update emp set username = #{username}, name = #{name}, gender = #{gender}, image = #{image}," +
            " job = #{job}, entrydate = #{entrydate}, dept_id = #{deptId},update_time = #{updateTime} where id = #{id}")
    public void update(Emp emp);
```

### 6.4 Mybits 查询

```java
    @Select("select * from emp where id = #{id}")
    public Emp getById(Integer id);
```

数据封装：

+ 实体类属性名 和 数据库表查询返回的字段名一致，mybatis会自动封装。

+ 如果实体类属性名 和 数据库表查询返回的字段名不一致，不能自动封装。

解决方法：

+ 1.起别名：在SQL语句中，对不一样的列名起别名，别名和实体类属性名一样

```java
@Select("select id, username, password, name, gender, image, job, entrydate, dept_id deptId, create_time createTime, update_time updateTime from emp where id = #{id} ")
public Emp getById(Integer id);
```

+ 2.手动结果映射：通过 @Results及@Result 进行手动结果映射。

```java
    @Results({
            @Result(column = "dept_id", property = "deptId"),
            @Result(column = "create_time", property = "createTime"),
            @Result(column = "update_time", property = "updateTime")
    })
    @Select("select * from emp where id = #{id}")
    public Emp getById(Integer id);
```

+ 3.开启驼峰命名(推荐)：如果字段名与属性名符合驼峰命名规则，mybatis会自动通过驼峰命名规则映射。

```bash
#开启驼峰命名自动映射，即从数据库字段名 a_column 映射到Java 属性名 aColumn。
mybatis.configuration.map-underscore-to-camel-case=true
```

> 条件查询

关于 `like '%张%'`,不能直接使用 like '%#{name}%' -> '%?%' 这里？是不能出现在字符串中，所以错误；

方法一 使用 $ 进行拼接，不会生成预编译 SQL
```java
    //条件查询员工
    //方式一
    @Select("select * from emp where name like '%${name}%' and gender = #{gender} and " + "entrydate between #{begin} and #{end} order by update_time desc ")
    /public List<Emp> list(String name, Short gender, LocalDate begin , LocalDate end);
```

上面使用 $ 进行拼接，也就是说 性能低、不安全、存在SQL注入问题;


解决方法：使用 concat 函数进行拼接，这样继续使用 #,使用预编译SQL;

```java
    //方式二
@Select("select * from emp where name like concat('%',#{name},'%') and gender = #{gender} and " +
"entrydate between #{begin} and #{end} order by update_time desc ")
public List<Emp> list(String name, Short gender, LocalDate begin , LocalDate end);

```

### 6.5. XML映射文件

#### 6.5.1 什么是 XML

XML（eXtensible Markup Language） 是一种 可扩展标记语言，用来存储、传输、组织结构化数据。

简单说，XML就是一种格式，长得很像 HTML，但它不规定标签，你可以自己定义！

例如：

```xml
<user>
  <id>1</id>
  <name>Tom</name>
  <age>18</age>
</user>
```

就是描述了一个用户的信息。

XML 本身只是用来描述数据，不会执行逻辑！


✅ 那怎么利用 XML 来实现 SQL 查询？

➡️ 把 SQL 语句写在 XML 文件里，由 MyBatis 读取并执行！

✅ MyBatis 里 XML 组织 SQL 查询的方式

一般来说，步骤是这样的：

步骤 | 说明
---|---
1 | 定义一个 Mapper 接口（Java的接口，声明方法）
2 | 写一个 XML 文件（同名 Mapper.xml），里面用 XML 格式写 SQL 语句
3 | 配置好 MyBatis 让它自动加载这些 XML
4 | 调用接口方法，MyBatis 去 XML 找 SQL 执行


📌 注意事项

+ XML映射文件的名称与Mapper接口名称一致，并且将XML映射文件和Mapper接口放置在相同包下（同包同名）。

+ XML映射文件的namespace属性为Mapper接口全限定名一致。

+ XML映射文件中sql语句的id与Mapper 接口中的方法名一致，并保持返回类型一致。

![](./图片/springboot-xml1.png)

1. 定义 Java 接口 UserMapper

```java 
public interface UserMapper {
    User selectById(Integer id);
}
```

2. 创建对应 XML UserMapper.xml

```xml
<mapper namespace="com.example.mapper.UserMapper">

    <select id="selectById" resultType="com.example.model.User">
        SELECT id, name, age
        FROM user
        WHERE id = #{id}
    </select>

</mapper>
```

+ < mapper>：表明这是一个映射器
+ namespace：要跟接口的完整包名一致
+ < select>：表示这是个查询语句
+ id="selectById"：对应接口的方法名
+ #{id}：占位符，MyBatis自动把方法参数填进来
+ resultType：查询结果映射成哪个 Java 类

更新

```java
<update id="updateUserName" parameterType="com.example.model.User">
    update user
    set name = #{name}
    where id = #{id}
</update>
```

### 6.6 动态 SQL

随着用户的输入或外部条件的变化而变化的SQL语句，我们称为 动态SQL。

+ <if>
+ <foreach>
+ <sql><include>

#### 6.6.1 <if>

+ < if >：用于判断条件是否成立。使用test属性进行条件判断，如果条件为true，则拼接SQL。

+ < where >：where 元素只会在子元素有内容的情况下才插入where子句。而且会自动去除子句的开头的AND 或OR

```xml
    <select id="list" resultType="com.yzx.pojo.Emp">
        select * from tb_emp
        <where>
            <if test="name != null">
                name like concat('%', #{name}, '%')
            </if>
            <if test="gender != null">
                and gender = #{gender}
            </if>
            <if test="begin != null and end != null">
                and entrydate between #{begin} and #{end}
            </if>
        </where>
        order by update_time desc
    </select>
```

+ <set>：动态地在行首插入 SET 关键字，并会删掉额外的逗号。（用在update语句中）

```xml
    <update id="update2">
        update tb_emp
        <set>
            <if test="username != null">
                username = #{username},
            </if>
    
            <if test="name != null">
                name = #{name},
            </if>
    
            <if test="gender != null">
                gender = #{gender},
            </if>
    
            <if test="image != null">
                image = #{image},
            </if>
            <if test="job != null">
                job = #{job},
            </if>
            <if test="entrydate != null">
                entrydate = #{entrydate},
            </if>
            <if test="deptId!= null">
                dept_id = #{deptId},
            </if>
            <if test="updateTime != null">
                update_time = #{updateTime}
            </if>
        </set>
        where id = #{id}

    </update>
```

#### 6.6.2 <foreach>

✅ foreach 是干嘛的？

在 MyBatis 的 SQL 中，如果你有一组数据要用，比如：

+ 批量插入
+ WHERE id IN (...) 多条件查询
+ 更新多条记录

就需要用到 <foreach>，它能遍历集合或者数组，自动生成一段动态 SQL！

✅ <foreach> 基本语法

```xml
<foreach 
    collection="集合名字" 
    item="每一项的名字" 
    index="下标变量名（可选）" 
    open="开始符" 
    close="结束符" 
    separator="分隔符">

    SQL片段（用 #{item} 或自己定义的名字）

</foreach>
```

属性 | 说明
---|---
collection | 要遍历的集合名（List/Array/Map）
item | 每次遍历出的元素名字
index | 当前元素的索引（可以不用）
open | 语句前加的内容（比如 '(' ）
close | 语句后加的内容（比如 ')' ）
separator | 每个元素之间的分隔符（比如 ',' ）

```xml
<!--    批量删除-->
    <delete id="deleteByIds">
        delete from tb_emp where id in
        <foreach collection="ids" item="id" separator="," open="(" close=")">
            #{id}
        </foreach>
    </delete>
```

#### 6.6.3 <sql><include>

✅ <sql> 和 <include> 是干什么用的？

简简单单一句话：

把重复用的 SQL 片段提取出来，想用的时候直接 <include> 引用，避免重复写。

就像写函数一样，有了一份公用 SQL 片段，想用多少次都可以拿来用，超级方便、维护简单！

✅ 基本用法

标签 | 作用
---|---
<sql id="xxx"> | 定义一段可以复用的 SQL 片段
<include refid="xxx"/> | 引用那段 SQL 片段

✅ 举个简单例子

假设：查询用户时经常需要 id, name, age 这三个字段。

如果每次都写：

```sql
SELECT id, name, age FROM user
SELECT id, name, age FROM admin
SELECT id, name, age FROM manager
```

于是你可以这样 👇

1. 定义 <sql>

```xml
<sql id="Base_Column_List">
    id, name, age
</sql>
```

2. 使用 <include>

```xml
<select id="selectUserById" resultType="com.example.User">
    SELECT 
        <include refid="Base_Column_List"/>
    FROM user
    WHERE id = #{id}
</select>

```

这里：

+ <include refid="Base_Column_List"/>
就是直接把 id, name, age 那段插进来了！

✅ 注意事项

要点 | 说明
--|---
<sql> 标签必须写在 <mapper> 里 | 跟 <select> <insert> 是平级的
id 要唯一 | 类似于函数名，引用靠这个 id
<include> 只能引用已经定义好的 <sql> | 不能直接写 SQL 进去
可以嵌套 <include> | 一个 <sql> 里面也可以 <include> 别的 <sql>


## 7. 案例

1. 环境搭建

![](./图片/springboot-demo1.png)

2. 开发规范 - Restful

![](./图片/springboot-demo2.png)

+ REST是风格，是约定方式，约定不是规定，可以打破。

+ 描述模块的功能通常使用复数，也就是加s的格式来描述，表示此类资源，而非单个资源。如：users、emps、books…

3. 流程

![](./图片/springboot-demo3.png)

👉 首先在 controller 中写出接受请求

![](./图片/springboot-demo4.png)

👉 然后调用给你 service层的实现

![](./图片/springboot-demo5.png)

👉 最后实现操作数据库

两种方式，一种注解；一种xml

![](./图片/springboot-demo6.png)

**注意xml的约束**

![](./图片/springboot-demo7.png)

### 7.1 pagehelper

核心功能：

+ 只要在查询前调用一下 PageHelper.startPage(pageNum, pageSize)，

+ 后面查询的SQL会自动加上 limit，

+ 还能自动带上分页信息，比如总记录数、总页数。

📦 第一步：引入依赖

如果你用的是 Maven，在 pom.xml 里加：

```xml
<dependency>
    <groupId>com.github.pagehelper</groupId>
    <artifactId>pagehelper-spring-boot-starter</artifactId>
    <version>1.4.7</version> <!-- 版本可以换成你需要的 -->
</dependency>
```

🛠️ 第二步：基本使用

在你 Service层 调用查询方法之前，先写：

```java
PageHelper.startPage(pageNum, pageSize);
List<User> users = userMapper.selectAll();
```

这样，底层就自动加了 limit！

👉 不需要你自己在 XML 里写 limit #{offset}, #{pageSize} 了。

比如实际发出的 SQL 会变成：

```sql
select * from user limit 0, 10
```

🛠️ 第三步：拿到分页信息

如果你想要总记录数、总页数等分页信息，还可以用 PageInfo 包装一下：

```java
PageHelper.startPage(pageNo, pageSize);

List<Emp> list = empMapper.list();
Page<Emp> p = (Page<Emp>) list;

return new PageBean(p.getTotal(), p.getResult());
```

mapper 只要实现下面即可，pagehelper会自动对这个sql进行改造，生成两条语句，分别查找总数和总limit；

```java
@Select("select * from emp")
    public List<Emp> list();
```

### 7.2 配置文件

常量，放到配置文件中；加载时，使用注解 @Value("key")

![](./图片/springboot-demo8.png)

但是正常情况下 是使用yml文件。

yml数据格式：

![](./图片/springboot-yml1.png)

使用 @ConfigurationProperties 进行映射替代 Value：

![](./图片/springboot-yml2.png)

🌟 例子

1. 在 yml 文件中配置参数：

![](./图片/springboot-yml3.png)

2. 创建实体类进行映射

![](./图片/springboot-yml4.png)

3. 使用

![](./图片/springboot-yml5.png)



## 8. 文件上传

### 8.1 保存到本地

![](./图片/springboot-file.png)

🔽 表单部分重点讲解

```html
<form action="/upload" method="post" enctype="multipart/form-data">
```

🔹 action="/upload"

表示表单提交后，数据会被发送到服务器 /upload 这个路径。

🔹 method="post"

使用 POST 方法提交（因为上传文件不能用 GET）。

🔹 enctype="multipart/form-data"

⚠️ 这是上传文件的关键点！

必须加这个 enctype，否则上传的文件字段是空的！

🔸 表单字段

```html
姓名: <input type="text" name="username"><br>
```

普通文本框，name=“username”，用于提交用户名。

```html
年龄: <input type="text" name="age"><br>
```

文本框，name=“age”，填写年龄。

```html
头像: <input type="file" name="image"><br>
```

+ 文件选择控件，让用户选择本地文件（图片等）。

+ name="image" 是服务端获取这个文件字段的 key。文件选择控件，让用户选择本地文件（图片等）。


```html
<input type="submit" value="提交">
```

提交按钮。

🧪 提交效果

点击【提交】之后，会把以下内容打包上传到 /upload：

+ username=小明
+ age=18
+ image=本地上传的文件二进制内容

🧰 后端配合（简单例子）

```java
@PostMapping("/upload")
public String handleUpload(
        @RequestParam("username") String username,
        @RequestParam("age") String age,
        @RequestParam("image") MultipartFile image) throws IOException {

    System.out.println("用户名: " + username);
    System.out.println("年龄: " + age);
    System.out.println("文件名: " + image.getOriginalFilename());

    // 保存到本地
    image.transferTo(new File("D:/upload/" + image.getOriginalFilename()));
    
    return "上传成功";
}
```

### 8.2 UUID 类生成全局唯一的字符串

```java
import java.io.File;
import java.io.IOException;
import java.util.UUID;
import org.springframework.web.multipart.MultipartFile;

@PostMapping("/upload")
public String uploadFile(@RequestParam("file") MultipartFile file) throws IOException {
    // 获取原始文件名后缀（如 .jpg/.png/.txt）
    String originalFilename = file.getOriginalFilename();
    String suffix = originalFilename.substring(originalFilename.lastIndexOf("."));

    // 生成 UUID 文件名
    String uuidFileName = UUID.randomUUID().toString() + suffix;

    // 保存路径（确保目录存在）
    File dest = new File("D:/upload/" + uuidFileName);
    file.transferTo(dest);

    return "上传成功，保存名为：" + uuidFileName;
}

```

在SpringBoot中，文件上传，默认单个文件允许最大大小为 1M。如果需要上传大文件，可以进行如下配置：

```java
#配置单个文件最大上传大小
spring.servlet.multipart.max-file-size=10MB
#配置单个请求最大上传大小(一次请求可以上传多个文件)
spring.servlet.multipart.max-request-size=100MB
```

常见的方法

```java
String getOriginalFilename(); //获取原始文件名
void transferTo(File dest); //将接收的文件转存到磁盘文件中
long getSize(); //获取文件的大小，单位：字节
byte[] getBytes(); //获取文件内容的字节数组
InputStream getInputStream(); //获取接收到的文件内容的输入流
```

### 8.3 云保存

直接看阿里云文档；

![](./图片/springboot-oss.png)


## 9. springboot 常用注解

+ @Slf4j ： 直接使用日志 `log.info("call getDept");`

✅ Controller 层常用注解汇总

注解 | 作用 | 常用在哪
---|---|---
@RestController | 定义一个 RESTful 风格的 Controller，返回 JSON 数据 | 类上
@Controller | 定义一个普通的 Controller，返回视图页面（比如 Thymeleaf） | 类上
@RequestMapping | 请求路径映射（可以加在类和方法上） | 类/方法上
@GetMapping / @PostMapping / @PutMapping / @DeleteMapping | 更具体的请求方式映射（简化版） | 方法上
@RequestParam | 绑定请求参数到方法的入参（如 ?name=xxx） | 方法参数上
@PathVariable | 绑定 URL 里的路径变量（如 /user/{id}） | 方法参数上
@RequestBody | 把请求体里的 JSON 数据，绑定到 Java 对象 | 方法参数上
@ResponseBody | 方法返回的数据直接作为 HTTP 响应体输出 | 方法上（隐含在 @RestController）
@RequestHeader | 绑定请求头到方法参数 | 方法参数上
@ModelAttribute | 把请求参数绑定到对象，同时可以用于初始化表单数据 | 方法参数上

✅ 常见的IOC/DI相关注解一览表

注解 | 作用 | 位置 | 备注
---|---|---|---
@Component | 标注为普通组件 | 类上 | 最基础的注解
@Service | 标注为服务层组件 | 类上 | 业务逻辑层（Service）
@Repository | 标注为数据访问层组件 | 类上 | DAO 层（数据库操作）
@Controller | 标注为控制器组件 | 类上 | Web 控制器层
@RestController | Controller + ResponseBody组合 | 类上 | 返回 JSON
@Autowired | 自动注入 Spring 容器中的 Bean | 属性/构造器/方法上 | 按类型注入
@Qualifier | 配合 @Autowired 按名字注入 | 属性/参数上 | 解决多个 Bean 冲突
@Resource | JSR-250规范，按名字注入（优先） | 属性上 | 需要引入 javax.annotation 包
@Inject | JSR-330规范，按类型注入 | 属性上 | 和@Autowired类似，但是标准
@Value | 注入配置文件中的值 | 属性上 | 如application.properties

5. @Autowired
➡️ 自动注入容器中的 Bean，按类型来注入。

```java
@Service
public class OrderService {

    @Autowired
    private UserService userService;

    public void createOrder() {
        userService.register();
        System.out.println("Order created!");
    }
}
```

## 10. 登录认证

### 10.1 登录功能

根据 用户名 和 密码 到数据库进行查询即可；

```java
@Select("select * from emp where username = #{username} and password = #{password}")
Emp getByUsernameAndPassword(Emp emp);
```

### 10.2 登录校验

🧠 为什么需要登录校验 ？

首先http协议是无状态的，也就是每一次请求都是独立的，下一次请求不会携带上一次请求的数据。服务器与浏览器之间进行交互就是基于http协议，那么比如我们通过浏览器来访问了登录这个接口并实现了登录的这个操作，但我们再执行其他业务操作时 服务器也并不知道这个员工有没有登录，因为http协议时无状态的，两次请求之间是独立的，所以就有了登录校验这个操作

👉 假如没有登录校验，此时一个用户进行登录了。此时拿到这个 url。当这个用户退出后，再次访问这个 url，就会发生可以访问到这个资源。这显然是不对的。因为此时没有登录就可以访问到数据。

解决方案：我们要在员工登录之后存储一个标记，我们就可以在每一个接口方法之前来做一个条件判断，如果这个员工已经登录了，那就执行正常的业务操作，否则就是没有登录就直接返回错误信息给前端，前端拿到这个错误信息后 它会自动地跳转到登录页面（其他的功能也是根据这个相同的逻辑来进行判断！）


⚡ 但是如果每次都进行判断会很繁琐。统一拦截技术，可以来拦截浏览器发送过来的所有请求，就可以对其进行校验员工是否登录，那我们就可以获取之前所存入的这个登陆的标记，如果成功获取到了这个标记并没有问题，那就说明这个员工已经登录了，就直接放行 继续去访问正常的业务接口就可以，但如果获取到的登录标记是有问题的，我们还是给前端响应一个错误信息，前端就会自动的跳转到登录页面

![](./图片/springboot-登录校验1.png)

#### 10.2.1 会话技术

会话： 指的就是服务器 与浏览器之间的一次连接，直到有一方断开连接 会话才会结束，并且在一次会话中可以包含多次请求和响应。只要这个浏览器和服务器都没有关闭，那么这三次请求都是在一次会话中完成的。

🧠 为什么需要会话技术？

HTTP 是无状态协议，即：

> 每次请求之间是独立的，服务器无法知道两次请求来自同一个用户。

而在实际业务中我们通常需要：

+ 用户登录一次后，多次访问仍保持“已登录状态”
+ 购物车、浏览记录、权限校验等信息能维持
+ 避免每次都重新登录或重新提交信息

➡️ 所以就需要 会话技术。


📌 **会话跟踪**

会话跟踪（Session Tracking）是 Web 开发中用于识别同一个用户在多次请求中身份，并保存其状态信息的一种技术。由于 HTTP 是无状态协议，服务器默认无法识别两次请求是否来自同一个用户，因此需要通过会话跟踪来维持用户状态。

通俗来说就是今后服务器会收到很多的请求，服务器这时就需要识别出来这写些请求是不是来自同一个浏览器，如果不是 就说明是不同的会话，如果是 就说明是同一会话 就在同一次会话的多次请求间共享数据，这个过程就叫做 ————会话跟踪。

🧠 举个例子：
你登录了一个购物网站后：

1. 添加商品到购物车
2. 查看订单
3. 提交支付

这一系列操作都属于同一个“会话”。服务器需要跟踪你这个用户当前的状态，否则每次请求它都不知道“你是谁”。

🎯 会话跟踪的目的

+ 实现用户登录保持（无需每次都登录）
+ 保存购物车、浏览记录、用户权限等信息
+ 支持多步骤操作流程（如下单 → 支付）



✅ 常见的会话跟踪技术有：

| 技术              | 说明 |
|-------------------|------|
| **Cookie**        | 在客户端浏览器中保存用户标识信息，自动随请求发送给服务器。|
| **Session**       | 在服务器端为每个用户生成唯一 session 对象，使用 sessionId 与客户端绑定。|
| **URL重写**       | 将用户标识作为参数附加到每个URL后面，例如：`/cart.jsp?sessionid=12345`。|
| **隐藏表单字段**  | 在表单中嵌入隐藏字段 `<input type="hidden" name="sessionId" value="xxx"/>`。|
| **Token (JWT 等)**| 使用令牌在前后端之间传递会话信息，常用于移动端和前后端分离项目。|

🌐 对比几个方式

| 方法       | 存储位置      | 安全性 | 适用场景 |
|------------|---------------|--------|-----------|
| Cookie     | 浏览器本地    | 中等   | 简单状态维护 |
| Session    | 服务器内存/缓存 | 高     | 多用户系统、用户数据较多 |
| URL重写    | URL中         | 低     | 无Cookie支持的浏览器 |
| JWT Token  | 客户端+服务端解析 | 高   | 前后端分离、分布式系统 |

![](./图片/springboot-登录校验2.png)

#### 10.2.2 JWT令牌

主要两步操作：生成令牌、校验令牌；

![](./图片/springboot-登录校验3.png)

```java
@Test
public void genJwt() {
    Map<String, Object> claims = new HashMap<>();
    claims.put("id", 1);
    claims.put("username", "Tom");

    String jwt = Jwts.builder()
            .signWith(SignatureAlgorithm.HS256, "yzxeqrygwer") //签名算法
            .setClaims(claims) //自定义内容(载荷)
            .setExpiration(new Date(System.currentTimeMillis() + 12 * 3600 * 1000)) //有效期
            .compact();
    System.out.println(jwt);
}

@Test
public void testJwt2() {
    Claims claims = Jwts.parser()
            .setSigningKey("yzxeqrygwer")
            .parseClaimsJws("eyJhbGciOiJIUzI1NiJ9.eyJpZCI6MSwiZXhwIjoxNzQ1OTc4NjgzLCJ1c2VybmFtZSI6IlRvbSJ9.bHNWPI8mIq9tsnRg0l9A59iTjyTen6omKYi3j90B6F4")
            .getBody();
    System.out.println(claims);
}
```




⚠️ 报错：

| 问题 | 原因 |
|------|------|
| `signWith(SignatureAlgorithm, String)` 报错 | 被弃用，应使用 `Key` |
| `IllegalArgumentException: key too short` | 密钥太短，需 ≥ 32 字节 |
| `Cannot resolve method signWith(...)` | 依赖版本过旧或不完整 |

#### 10.2.3 过滤器Filter

● 概念: Filter 过滤器,是JavaWeb 三大组件(Servlet、Filter、Listener)之一。

● 过滤器可以把对资源的请求拦截下来,从而实现一些特殊的功能。

● 过滤器一般完成一些通用的操作,比如:登录校验、统一编码处理、敏感字符处理等。

![](./图片/springboot-filter1.png)


✅ 拦截路径：Filter可以根据需求，配置不同的拦截资源路径

`@WebFilter(urlPatterns = "/*")`

拦截具体路径： /login ，之访问 /login 路径时，才会被拦截；

目录拦截：/emps/* ，访问 /emps 下的所有资源，都会被拦截；

拦截所有：/* ,访问所有资源都会被拦截；

✅ 过滤器链：一个web应用中，可以配置多个过滤器，这多个过滤器就形成了一个 过滤器链；

注意：过滤器顺序是和名字强关联的；

![](./图片/springboot-filter2.png)

✅ 登录校验

+ 所有的请求，拦截到了之后，都需要校验令牌吗？有一个例外，登录请求

+ 拦截到请求后，什么情况下才可以放行，执行业务操作？有令牌，且令牌校验通过（合法）；否则都返回未登录错误结果

✨ 登录校验流程

![](./图片/springboot-filter3.png)

```java
public class LoginCheckFilter implements Filter {
    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {

        HttpServletRequest req = (HttpServletRequest) request;
        HttpServletResponse resp = (HttpServletResponse) response;

        //1.获取请求url。
        String url = req.getRequestURL().toString();
        log.info("请求的url: {}",url);

        //2.判断请求url中是否包含login，如果包含，说明是登录操作，放行。
        if(url.contains("login")){
            log.info("登录操作, 放行...");
            chain.doFilter(request,response);
            return;
        }

        //3.获取请求头中的令牌（token）。
        String jwt = req.getHeader("token");

        //4.判断令牌是否存在，如果不存在，返回错误结果（未登录）。
        if(!StringUtils.hasLength(jwt)){
            log.info("请求头token为空,返回未登录的信息");
            Result error = Result.error("NOT_LOGIN");
            //手动转换 对象--json --------> 阿里巴巴fastJSON
            String notLogin = JSONObject.toJSONString(error);
            resp.getWriter().write(notLogin);
            return;
        }

        //5.解析token，如果解析失败，返回错误结果（未登录）。
        try {
            JwtUtils.parseJWT(jwt);
        } catch (Exception e) {//jwt解析失败
            e.printStackTrace();
            log.info("解析令牌失败, 返回未登录错误信息");
            Result error = Result.error("NOT_LOGIN");
            //手动转换 对象--json --------> 阿里巴巴fastJSON
            String notLogin = JSONObject.toJSONString(error);
            resp.getWriter().write(notLogin);
            return;
        }

        //6.放行。
        log.info("令牌合法, 放行");
        chain.doFilter(request, response);
    }
}
```


#### 10.2.4 拦截器Interceptor

✅ 简介

+ 概念：是一种动态拦截方法调用的机制，类似于过滤器。Spring框架中提供的，用来动态拦截控制器方法的执行。

+ 作用：拦截请求，在指定的方法调用前后，根据业务需要执行预先设定的代码。

✅ 快速入门

![](./图片/springboot-filter4.png)

定义类实现：

```java
@Slf4j
@Component
public class LoginCheckInterceptor implements HandlerInterceptor {
    @Override //目标资源方法运行前运行, 返回true: 放行, 放回false, 不放行
    public boolean preHandle(HttpServletRequest req, HttpServletResponse resp, Object handler) throws Exception {
        //1.获取请求url。
        String url = req.getRequestURL().toString();
        log.info("请求的url: {}",url);

        //2.判断请求url中是否包含login，如果包含，说明是登录操作，放行。
        if(url.contains("login")){
            log.info("登录操作, 放行...");
            return true;
        }

        //3.获取请求头中的令牌（token）。
        String jwt = req.getHeader("token");

        //4.判断令牌是否存在，如果不存在，返回错误结果（未登录）。
        if(!StringUtils.hasLength(jwt)){
            log.info("请求头token为空,返回未登录的信息");
            Result error = Result.error("NOT_LOGIN");
            //手动转换 对象--json --------> 阿里巴巴fastJSON
            String notLogin = JSONObject.toJSONString(error);
            resp.getWriter().write(notLogin);
            return false;
        }

        //5.解析token，如果解析失败，返回错误结果（未登录）。
        try {
            JwtUtils.parseJWT(jwt);
        } catch (Exception e) {//jwt解析失败
            e.printStackTrace();
            log.info("解析令牌失败, 返回未登录错误信息");
            Result error = Result.error("NOT_LOGIN");
            //手动转换 对象--json --------> 阿里巴巴fastJSON
            String notLogin = JSONObject.toJSONString(error);
            resp.getWriter().write(notLogin);
            return false;
        }

        //6.放行。
        log.info("令牌合法, 放行");
        return true;
    }

    @Override //目标资源方法运行后运行
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        System.out.println("postHandle ...");
    }

    @Override //视图渲染完毕后运行, 最后运行
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        System.out.println("afterCompletion...");
    }
}
```

定义配置项：

```java
@Configuration //配置类
public class WebConfig implements WebMvcConfigurer {

    @Autowired
    private LoginCheckInterceptor loginCheckInterceptor;

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(loginCheckInterceptor)
                .addPathPatterns("/**")
                .excludePathPatterns("/login");
    }
}
```

✅ 拦截器-拦截路径

![](./图片/springboot-filter5.png)

![](./图片/springboot-filter6.png)

✅ 登录校验- Interceptor

![](./图片/springboot-Interceptor1.png)



### 10.3 异常处理

解决方案：全局异常处理器

由于异常的处理如果不处理会从下往上抛出，所以都在异常处理器这里进行处理；

![](./图片/springboot-exception1.png)

主要：

+ @RestControllerAdvice = @ControllerAdvice + @ResponseBody
+ @ExceptionHandler 捕获那些异常

```java
@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(Exception.class)//捕获所有异常
    public Result ex(Exception ex){
        ex.printStackTrace();
        return Result.error("对不起,操作失败,请联系管理员");
    }

}
```

## 11. AOP  

### 11.1 Spring事务管理

![](./图片/springboot-transactional1.png)

✅ 事务进阶

默认情况下，只有出现 RuntimeException 才回滚异常。rollbackFor属性用于控制出现何种异常类型，回滚事务。

```java
@Transactional(rollbackFor = Exception.class)
@DeleteMapping("/{id}")
public Result delete(@PathVariable Integer id) {
    // 删除部门
    deptService.delete(id);
        int a = 1/0;
    // 删除部门下的员工
    emptService.deleteByDeptId(id);

    return Result.success();
}
```

事务传播行为：指的就是当一个事务方法被另一个事务方法调用时，这个事务方法应该如何进行事务控制。

![](./图片/springboot-transactional2.png)


### 11.2 AOP 基础

AOP：Aspect Oriented Programming（面向切面编程、面向方面编程），其实就是面向特定方法编程；

🧠 为什么需要 AOP？

假设你要在多个服务方法中添加日志：

```java
public void addUser() {
    System.out.println("添加日志...");
    // 核心业务逻辑
}
public void deleteUser() {
    System.out.println("添加日志...");
    // 核心业务逻辑
}
```

➡️ 重复代码太多，不利于维护。

AOP 就是为了解耦这类“横切关注点”（日志、事务、安全验证等）和“核心业务逻辑”。

🧩 AOP 的核心概念

| 术语        | 含义 |
|-------------|------|
| **切面（Aspect）**       | 横切逻辑的模块，比如“日志切面”、“事务切面” |
| **连接点（JoinPoint）** | 程序执行过程中可以插入横切逻辑的点，比如方法调用、异常抛出等 |
| **切入点（Pointcut）**   | 描述哪些连接点会被织入，比如指定某些包下的所有方法 |
| **通知（Advice）**       | 实际要织入的代码，比如日志打印，可以是“前置通知”、“后置通知”、“异常通知”等 |
| **织入（Weaving）**      | 把通知应用到目标对象的过程（运行时或编译时） |

![](./图片/springboot-aop1.png )

📌 Spring AOP 常用注解

Spring AOP 是基于动态代理实现的，常用注解包括：

```java
@Aspect            // 声明一个切面类
@Component         // 交给 Spring 容器管理

@Before            // 前置通知（在方法执行前执行）
@AfterReturning    // 后置通知（方法成功返回后）
@AfterThrowing     // 异常通知（方法抛出异常后）
@After             // 最终通知（无论是否异常都会执行）
@Around            // 环绕通知（方法前后都能插入逻辑）
```

```java
@Slf4j
@Component
@Aspect
public class MyAspect1 {

    @Pointcut("execution(* com.itheima.service.impl.DeptServiceImpl.*(..))")
    public void pt(){}

    @Before("pt()")
    public void before(){
        log.info("before ...");
    }

    @Around("pt()")
    public Object around(ProceedingJoinPoint proceedingJoinPoint) throws Throwable {
        log.info("around before ...");

        //调用目标对象的原始方法执行
        Object result = proceedingJoinPoint.proceed();

        log.info("around after ...");
        return result;
    }

    @After("pt()")
    public void after(){
        log.info("after ...");
    }

    @AfterReturning("pt()")
    public void afterReturning(){
        log.info("afterReturning ...");
    }

    @AfterThrowing("pt()")
    public void afterThrowing(){
        log.info("afterThrowing ...");
    }
}

``` 

execution(...) 表达式的语法

```java
execution(修饰符? 返回值 包名.类名.方法名(参数) 异常?)
```

其中大多数可以用 * 作为通配符：

| 符号         | 含义 |
|--------------|------|
| `*`          | 任意值（任意返回值、任意方法名等） |
| `..`         | 任意层级、任意参数 |
| `+`          | 表示“当前类及其子类”或“接口及其实现类” |


### 11.2.1 通知顺序

1. 通知顺序和类名的顺序相关；

2. 或者用 @Order(数字) 加在切面类上来控制顺序

+ 目标方法前的通知方法：数字小的先执行

+ 目标方法后的通知方法，数字小的后执行

### 11.2.2 切入点表达式

+ 切入点表达式：描述切入点方法的一种表达式

+ 作用：主要用来决定项目中的哪些方法需要加入通知

+ 常见形式：
    + execution(……)：根据方法的签名来匹配
    + @annotation(……) ：根据注解匹配

✅ 切入点表达式-execution

execution 主要根据方法的返回值、包名、类名、方法名、方法参数等信息来匹配，语法为：

```java
execution(访问修饰符?  返回值  包名.类名.?方法名(方法参数) throws 异常?)
```

+ 其中带 ? 的表示可以省略的部分
    + 访问修饰符：可省略（比如: public、protected）
    + 包名.类名： 可省略
    + throws 异常：可省略（注意是方法上声明抛出的异常，不是实际抛出的异常）

+ * ：单个独立的任意符号，可以通配任意返回值、包名、类名、方法名、任意类型的一个参数，也可以通配包、类、方法名的一部分

+ .. ：多个连续的任意符号，可以通配任意层级的包，或任意类型、任意个数的参数
 

🎯书写建议

+ 所有业务方法名在命名时尽量规范，方便切入点表达式快速匹配。如：查询类方法都是 find 开头，更新类方法都是 update开头。

+ 描述切入点方法通常基于接口描述，而不是直接描述实现类，增强拓展性。

+ 在满足业务需要的前提下，尽量缩小切入点的匹配范围。如：包名匹配尽量不使用 ..，使用 * 匹配单个包。


✅ 切入点表达式-@annotation

@annotation(注解类) 表示：匹配被某个注解标注的方法。

这在我们需要根据注解来决定是否应用某些横切逻辑（如权限检查、日志记录、限流）时非常常用。

```java
@annotation(com.itheima.anno.Log)
```

✅ 示例：匹配带某个注解的方法

1. 定义自定义注解

```java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface LogOperation {
    String value() default "";
}
```

2. 标注到某个方法上

```java
@Service
public class UserService {
    
    @LogOperation("添加用户")
    public void addUser() {
        System.out.println("执行添加用户逻辑...");
    }
}
```

3. 使用 @annotation 定义切点

```java
@Aspect
@Component
public class LogAspect {

    // 切点：拦截所有使用 @LogOperation 注解的方法
    @Pointcut("@annotation(com.example.annotation.LogOperation)")
    public void logPointCut() {}

    @Before("logPointCut()")
    public void before(JoinPoint joinPoint) {
        System.out.println("执行了 @LogOperation 注解方法！");
    }
}
```

✅ 获取注解中的值（增强版）

```java
@Before("@annotation(logOperation)")
public void before(JoinPoint joinPoint, LogOperation logOperation) {
    System.out.println("注解内容：" + logOperation.value());
}
```

注意：要在切面方法参数中显式加上 注解名，Spring 会自动把注解对象注入进来。

### 11.2.3 连接点

在Spring中用JoinPoint抽象了连接点，用它可以获得方法执行时的相关信息，如目标类名、方法名、方法参数等

+ ProceedingJoinPoint
+ JoinPoint

![](./图片/springboot-aop3.png)

![](./图片/springboot-aop2.png)

 
### aop demo

🌐 将案例中 增、删、改 相关接口的操作日志记录到数据库表中。

✅ 需要对所有业务类中的增、删、改 方法添加统一功能，使用 AOP 技术最为方便; @Around 环绕通知

由于增、删、改方法名没有规律，可以自定义 @Log 注解完成目标方法匹配。


1. 导入数据、实体类和mapper 接口

![](./图片/springboot-aopdemo1.png)

![](./图片/springboot-aopdemo1.png)
![](./图片/springboot-aopdemo2.png)

2. 自定义注解

这里的注解只是起到标识的作用，所以不需要成员

![](./图片/springboot-aopdemo3.png)

3. 定义切面类，完成记录操作日志的逻辑

![](./图片/springboot-aopdemo4.png)

然后在函数上加入 @Log 注解即可；

## 12. springboot 原理

配置文件优先级

.properties > .yml > .yaml

主流：yml;

### 12.1 Bean 管理

✅ 获取 bean 对象

![](./图片/springboot-bean1.png)

✅ bean 作用域

![](./图片/springboot-bean2.png)

可以通过 @Scope 注解进行配置作用域；
并且可以使用 @Lazy 注解来延迟初始化；

![](./图片/springboot-bean3.png)

### 12.2 第三方 bean

如果要管理的bean对象来自于第三方（不是自定义的），是无法用 @Component 及衍生注解声明bean的，就需要用到 @Bean注解

![](./图片/springboot-bean4.png)

@Component 及衍生注解 与 @Bean注解使用场景？

+ 项目中自定义的，使用@Component及其衍生注解
+ 项目中引入第三方的，使用@Bean注解

### 12.3 springboot 原理

+ 起步依赖：mavean以来传递

+ 自动配置：SpringBoot的自动配置就是当spring容器启动后，一些配置类、bean对象就自动存入到了IOC容器中，不需要我们手动去声明，从而简化了开发，省去了繁琐的配置操作。

#### 自动配置 原理


## 13. Maven

### 13.1 分模块设计与开发

![](./图片/springboot-maven1.png)

把之前的代码拆分成各个模块，这样可以共给他人使用；

1. 首先新建模块，把 pojo 的东西放到新模块中

2. 然后在模块中加载即可

### 13.2 继承与聚合

通过parent ，管理包；注意，打包方式为 pom；

![](./图片/springboot-jicheng1.png)

![](./图片/springboot-jicheng2.png)


版本锁定：在maven中，可以在父工程的pom文件中通过 < dependencyManagement > 来统一管理依赖版本。

![](./图片/springboot-jicheng3.png)


✅ 聚合

![](./图片/springboot-juhe1.png)

使用：

![](./图片/springboot-juhe2.png)

### 13.3 私服

![](./图片/springboot-sifu1.png)




 














