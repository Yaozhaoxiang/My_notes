# 3.直接插入排序

直接插入排序(Straight Insertion Sort)的基本思想是：把n个待排序的元素看成为一个有序表和一个无序表。

开始时有序表中只包含1个元素，无序表中包含有n-1个元素，排序过程中每次从无序表中取出第一个元素，将它插入到有序表中的适当位置，使之成为新的有序表，重复n-1次可完成排序过程。

本质就是将一个记录插入到已经拍好的有序表中，从而得到一个新的有序表
```cpp
struct SqList{
    int r[MAXSIZE+1];//由于存储要排序的数组，r[0]用作哨兵或临时变量
    int length;
};
void swap(SqList*L,int i,int j)
{
    int temp=L->r[i];
    L->r[i]=L->r[j];
    L->r[j]=temp;
}

void InsertSort(SqList* L)
{
    int i,j;
    for(i=2;i<=L->length;i++)//从2开始，因为第一个元素作为已经排序好的序列
    {
        if(L->r[i]<L->r[i-1])//如果当前元素小于左边的元素，则插入位置在该元素的左边
        {
            // 和哨兵比较，也就是当前要插入的元素
            //如果哨兵小于左边的元素，左边的元素右移，直到不小于左边的元素
            //由于当前元素位置在i，而且已经把值赋值给哨兵了，当前的位置可以直接被左边元素覆盖
            L->r[0]=L->r[i];
            for(j=i-1;L->r[j]>L->r[0];j--)
            {
                L->r[j+1]=L->r[j];
            }
            L->r[j+1]=L->r[0];
        }
        //如果当前元素已经大于r[i-1],则r[i]就是最大值，不需要换位置
    }
}
```
数组形式：
```cpp
void InsertSort(vector<int>& a)
{
    int i, j;
    int len = a.size();
    for (i = 1; i < len; i++)
    {
        if (a[i] < a[i - 1])
        {
            int key = a[i];
            for (j = i - 1; j >= 0 && a[j]>key; j--)
            {
                a[j + 1] = a[j];
            }
            a[j + 1] = key;
        }
    }
}
```

直接插入排序的时间复杂度和稳定性

直接插入排序时间复杂度
直接插入排序的时间复杂度是O(N^2)。
假设被排序的数列中有N个数。遍历一趟的时间复杂度是O(N)，需要遍历多少次呢？N-1！因此，直接插入排序的时间复杂度是O(N2)。

直接插入排序稳定性
直接插入排序是稳定的算法，它满足稳定算法的定义。
算法稳定性 -- 假设在数列中存在a[i]=a[j]，若在排序之前，a[i]在a[j]前面；并且排序之后，a[i]仍然在a[j]前面。则这个排序算法是稳定的！























