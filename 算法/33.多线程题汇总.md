## leetcode 1114. æŒ‰åºæ‰“å°

>ç»™ä½ ä¸€ä¸ªç±»ï¼š
>
>public class Foo {
>  public void first() { print("first"); }
>  public void second() { print("second"); }
>  public void third() { print("third"); }
>}
>ä¸‰ä¸ªä¸åŒçš„çº¿ç¨‹ Aã€Bã€C å°†ä¼šå…±ç”¨ä¸€ä¸ª Foo å®ä¾‹ã€‚
>
>çº¿ç¨‹ A å°†ä¼šè°ƒç”¨ first() æ–¹æ³•
>çº¿ç¨‹ B å°†ä¼šè°ƒç”¨ second() æ–¹æ³•
>çº¿ç¨‹ C å°†ä¼šè°ƒç”¨ third() æ–¹æ³•
>è¯·è®¾è®¡ä¿®æ”¹ç¨‹åºï¼Œä»¥ç¡®ä¿ second() æ–¹æ³•åœ¨ first() æ–¹æ³•ä¹‹åè¢«æ‰§è¡Œï¼Œthird() æ–¹æ³•åœ¨ second() >æ–¹æ³•ä¹‹åè¢«æ‰§è¡Œã€‚
>
>æç¤ºï¼š
>
>å°½ç®¡è¾“å…¥ä¸­çš„æ•°å­—ä¼¼ä¹æš—ç¤ºäº†é¡ºåºï¼Œä½†æ˜¯æˆ‘ä»¬å¹¶ä¸ä¿è¯çº¿ç¨‹åœ¨æ“ä½œç³»ç»Ÿä¸­çš„è°ƒåº¦é¡ºåºã€‚
>ä½ çœ‹åˆ°çš„è¾“å…¥æ ¼å¼ä¸»è¦æ˜¯ä¸ºäº†ç¡®ä¿æµ‹è¯•çš„å…¨é¢æ€§ã€‚

### c++ äº’æ–¥é”ï¼Œ æ¡ä»¶å˜é‡ï¼Œ ä¿¡å·é‡ï¼Œ å¼‚æ­¥æ“ä½œï¼Œ åŸå­æ“ä½œ

> äº’æ–¥é”+æ¡ä»¶å˜é‡
```cpp
#include <iostream>
#include <thread>
#include <mutex>
#include <functional>
#include <condition_variable>
using namespace std;

class Foo {
    int step = 1;
    mutex mtx;
    condition_variable cv1,cv2;
public:
    Foo() {

    }

    void first(function<void()> printFirst) {
        unique_lock<mutex>  lock(mtx);
        printFirst();
        step = 2;
        cv1.notify_one();
    }

    void second(function<void()> printSecond) {
        unique_lock<mutex>  lock(mtx);
        cv1.wait(lock, [this]() {return step == 2;});
        printSecond();
        step = 3;
        cv2.notify_one();
    }

    void third(function<void()> printThird) {
        unique_lock<mutex>  lock(mtx);
        cv2.wait(lock, [this]() {return step == 3;});

        printThird();
    }
};

void printFirst() {
    std::cout << "first" << std::endl;
}
void printSecond() {
    std::cout << "second" << std::endl;
}
void printThird() {
    std::cout << "third" << std::endl;
}

int main() {

    Foo foo;
    // åˆ›å»ºä¸‰ä¸ªçº¿ç¨‹åˆ†åˆ«è°ƒç”¨ firstã€secondã€third æ–¹æ³•
    std::thread t1(&Foo::first, &foo, printFirst);
    std::thread t2(&Foo::second, &foo, printSecond );
    std::thread t3(&Foo::third, &foo, printThird);

    // ç­‰å¾…æ‰€æœ‰çº¿ç¨‹æ‰§è¡Œå®Œæ¯•
    t1.join();
    t2.join();
    t3.join();

    return 0;

}
```

> ä¿¡å·é‡
ä¿¡å·é‡æ˜¯ç”¨æ¥å®ç°å¯¹å…±äº«èµ„æºçš„åŒæ­¥è®¿é—®çš„æœºåˆ¶ï¼Œå…¶ä½¿ç”¨æ–¹æ³•å’Œæ¡ä»¶å˜é‡ç±»ä¼¼ï¼Œéƒ½æ˜¯é€šè¿‡ä¸»åŠ¨ç­‰å¾…å’Œä¸»åŠ¨å”¤é†’æ¥å®ç°çš„ã€‚

C++ æ ‡å‡†åº“ä¸­å¹¶æ²¡æœ‰ä¿¡å·é‡çš„å®ç°å’Œå°è£…ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨ C è¯­è¨€æä¾›çš„ <sempahore.h> åº“æ¥è§£é¢˜ ï¼š
åˆå§‹åŒ–å…¨ä¸º0ï¼Œå…¨éƒ¨ç­‰å¾…ï¼›

```cpp
#include <iostream>
#include <thread>
#include <functional>
#include <semaphore.h>
using namespace std;

class Foo {
    sem_t sem_1, sem_2;
public:
    Foo() {
        sem_init(&sem_1,0,0);
        sem_init(&sem_2,0,0);
    }

    void first(function<void()> printFirst) {

        printFirst();
        sem_post(&sem_1);
    }

    void second(function<void()> printSecond) {
        sem_wait(&sem_1);
        printSecond();
        sem_post(&sem_2);
    }

    void third(function<void()> printThird) {
        sem_wait(&sem_2);
        printThird();
    }
};

void printFirst() {
    std::cout << "first" << std::endl;
}
void printSecond() {
    std::cout << "second" << std::endl;
}
void printThird() {
    std::cout << "third" << std::endl;
}

int main() {

    Foo foo;
    // åˆ›å»ºä¸‰ä¸ªçº¿ç¨‹åˆ†åˆ«è°ƒç”¨ firstã€secondã€third æ–¹æ³•
    std::thread t1(&Foo::first, &foo, printFirst);
    std::thread t2(&Foo::second, &foo, printSecond );
    std::thread t3(&Foo::third, &foo, printThird);

    // ç­‰å¾…æ‰€æœ‰çº¿ç¨‹æ‰§è¡Œå®Œæ¯•
    t1.join();
    t2.join();
    t3.join();

    return 0;

}
```

> å¼‚æ­¥æ“ä½œï¼š

å¼‚æ­¥æ“ä½œæ˜¯ä¸€ç§ï¼Œåœ¨ä¸éœ€è¦ç­‰å¾…è¢«è°ƒç”¨æ–¹è¿”å›ç»“æœä¹‹å‰ï¼Œå°±è®©æ“ä½œç»§ç»­è¿›è¡Œä¸‹å»çš„æ–¹æ³•ã€‚é’ˆå¯¹è¿™é“é¢˜å¯ä»¥ä½¿ç”¨åŸºäº future/promise çš„å¼‚æ­¥ç¼–ç¨‹æ¨¡å‹ã€‚

future å’Œ promise èµ·æºäºå‡½æ•°å¼ç¼–ç¨‹ï¼Œå…¶ç›®çš„æ˜¯å°†å€¼ï¼ˆfutureï¼‰å’Œè®¡ç®—æ–¹å¼ï¼ˆpromiseï¼‰åˆ†ç¦»ï¼Œä½¿å¾— promise å¯ä»¥å¼‚æ­¥åœ°ä¿®æ”¹ futureï¼Œä»è€Œæé«˜ä»£ç çš„å¯è¯»æ€§ï¼Œå¹¶å‡å°‘é€šä¿¡å»¶è¿Ÿã€‚

std::future æ˜¯ç”¨æ¥è·å–å¼‚æ­¥æ“ä½œç»“æœçš„æ¨¡æ¿ç±»ï¼›std::packaged_task, std::promise, std::async éƒ½å¯ä»¥è¿›è¡Œå¼‚æ­¥æ“ä½œï¼Œå¹¶æ‹¥æœ‰ä¸€ä¸ª std::future å¯¹è±¡ï¼Œç”¨æ¥å­˜å‚¨å®ƒä»¬æ‰€è¿›è¡Œçš„å¼‚æ­¥æ“ä½œè¿”å›æˆ–è®¾ç½®çš„å€¼ï¼ˆæˆ–å¼‚å¸¸ï¼‰ï¼Œè¿™ä¸ªå€¼ä¼šåœ¨å°†æ¥çš„æŸä¸€ä¸ªæ—¶é—´ç‚¹ï¼Œé€šè¿‡æŸç§æœºåˆ¶è¢«ä¿®æ”¹åï¼Œä¿å­˜åœ¨å…¶å¯¹åº”çš„ std::future å¯¹è±¡ä¸­ï¼š

å¯¹äº std::promiseï¼Œå¯ä»¥é€šè¿‡è°ƒç”¨ std::promise::set_value æ¥è®¾ç½®å€¼å¹¶é€šçŸ¥ std::future å¯¹è±¡ï¼š

```cpp
#include <iostream>
#include <thread>
#include <functional>
#include <future>
using namespace std;

class Foo {
    promise<void> pro1, pro2;
public:
    Foo() {

    }

    void first(function<void()> printFirst) {
        printFirst();
        pro1.set_value();
    }

    void second(function<void()> printSecond) {
        pro1.get_future().wait();
        printSecond();
        pro2.set_value();
    }

    void third(function<void()> printThird) {
        pro2.get_future().wait();
        printThird();
    }
};

void printFirst() {
    std::cout << "first" << std::endl;
}
void printSecond() {
    std::cout << "second" << std::endl;
}
void printThird() {
    std::cout << "third" << std::endl;
}

int main() {

    Foo foo;
    // åˆ›å»ºä¸‰ä¸ªçº¿ç¨‹åˆ†åˆ«è°ƒç”¨ firstã€secondã€third æ–¹æ³•
    std::thread t1(&Foo::first, &foo, printFirst);
    std::thread t2(&Foo::second, &foo, printSecond );
    std::thread t3(&Foo::third, &foo, printThird);

    // ç­‰å¾…æ‰€æœ‰çº¿ç¨‹æ‰§è¡Œå®Œæ¯•
    t1.join();
    t2.join();
    t3.join();

    return 0;

}
```

std::future<T>::wait å’Œ std::future<T>::get éƒ½ä¼šé˜»å¡åœ°ç­‰å¾…æ‹¥æœ‰å®ƒçš„ promise å¯¹è±¡è¿”å›å…¶æ‰€å­˜å‚¨çš„å€¼ï¼Œåè€…è¿˜ä¼šè·å– T ç±»å‹çš„å¯¹è±¡ï¼›è¿™é“é¢˜åªéœ€è¦åˆ©ç”¨åˆ°å¼‚æ­¥é€šä¿¡çš„æœºåˆ¶ï¼Œæ‰€ä»¥å¹¶æ²¡æœ‰è¿”å›ä»»ä½•å®é™…çš„å€¼

> åŸå­æ“ä½œ

è€Œ åŸå­æ“ä½œèƒ½å¤Ÿä¿è¯å¤šä¸ªçº¿ç¨‹é¡ºåºè®¿é—®ï¼Œä¸ä¼šå¯¼è‡´æ•°æ®äº‰ç”¨ï¼Œå…¶æ‰§è¡Œæ—¶æ²¡æœ‰ä»»ä½•å…¶å®ƒçº¿ç¨‹èƒ½å¤Ÿä¿®æ”¹ç›¸åŒçš„åŸå­å¯¹è±¡ã€‚

é’ˆå¯¹è¿™é“é¢˜ï¼Œæˆ‘ä»¬å¯ä»¥è®© second å’Œ third å‡½æ•°ç­‰å¾…åŸå­å˜é‡è¢«ä¿®æ”¹ä¸ºæŸä¸ªå€¼åå†æ‰§è¡Œï¼Œç„¶ååˆ†åˆ«åœ¨ first å’Œ second å‡½æ•°ä¸­æ¥ä¿®æ”¹è¿™ä¸ªåŸå­å˜é‡ã€‚

C++ 11 æä¾›äº† std::atomic<T> æ¨¡æ¿ç±»æ¥æ„é€ åŸå­å¯¹è±¡ï¼š

```cpp
class Foo {
    std::atomic<bool> a{ false };
    std::atomic<bool> b{ false };
public:
    void first(function<void()> printFirst) {
        printFirst();
        a = true;
    }

    void second(function<void()> printSecond) {
        while (!a)
        this_thread::sleep_for(chrono::milliseconds(1));
        printSecond();
        b = true;
    }

    void third(function<void()> printThird) {
        while (!b)
        this_thread::sleep_for(chrono::milliseconds(1));
        printThird();
    }
};

ä½œè€…ï¼šChr1s
é“¾æ¥ï¼šhttps://leetcode.cn/problems/print-in-order/solutions/445416/c-hu-chi-suo-tiao-jian-bian-liang-xin-hao-liang-yi/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚
```

## leetcode 1115 äº¤æ›¿æ‰“å° FooBar

>ç»™ä½ ä¸€ä¸ªç±»ï¼š
>
>class FooBar {
>  public void foo() {
>    for (int i = 0; i < n; i++) {
>      print("foo");
>    }
>  }
>
>  public void bar() {
>    for (int i = 0; i < n; i++) {
>      print("bar");
>    }
>  }
>}
>ä¸¤ä¸ªä¸åŒçš„çº¿ç¨‹å°†ä¼šå…±ç”¨ä¸€ä¸ª FooBar å®ä¾‹ï¼š
>
>çº¿ç¨‹ A å°†ä¼šè°ƒç”¨ foo() æ–¹æ³•ï¼Œè€Œ
>çº¿ç¨‹ B å°†ä¼šè°ƒç”¨ bar() æ–¹æ³•
>è¯·è®¾è®¡ä¿®æ”¹ç¨‹åºï¼Œä»¥ç¡®ä¿ "foobar" è¢«è¾“å‡º n æ¬¡ã€‚

```cpp
class FooBar {
private:
    int n;
    bool flag{true};
    mutex mtx;
    condition_variable cv;
public:
    FooBar(int n) {
        this->n = n;
    }

    void foo(function<void()> printFoo) {
        unique_lock<mutex> lock(mtx);
        for (int i = 0; i < n; i++) {
            cv.wait(lock,[this](){return flag;});
        	// printFoo() outputs "foo". Do not change or remove this line.
        	printFoo();
            flag=false;
            cv.notify_all();
        }
    }

    void bar(function<void()> printBar) {
        unique_lock<mutex> lock(mtx);
        
        for (int i = 0; i < n; i++) {
            cv.wait(lock,[this](){return !flag;});
            
        	// printBar() outputs "bar". Do not change or remove this line.
        	printBar();
            flag=true;
            cv.notify_all();
        }
    }
};
```
ä¿¡å·é‡
```cpp
#include<semaphore.h>
class FooBar {
private:
    int n;
    sem_t foo_done,bar_done;
public:
    FooBar(int n) {
        this->n = n;
        sem_init(&foo_done,0,0);
        sem_init(&bar_done,0,1);
    }
    void foo(function<void()> printFoo) {
        for (int i = 0; i < n; i++) {
            sem_wait(&bar_done);
            printFoo();
            sem_post(&foo_done);
        }
    }
    void bar(function<void()> printBar) {
        for (int i = 0; i < n; i++) {
            sem_wait(&foo_done);
            printBar();
            sem_post(&bar_done);
        }
    }
};

ä½œè€…ï¼šå­æ´ª
é“¾æ¥ï¼šhttps://leetcode.cn/problems/print-foobar-alternately/solutions/1020308/c-duo-fang-fa-by-zhouzihong-zdvj/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚
```

å¼‚æ­¥æ“ä½œ
```cpp
class FooBar {
private:
    int n;
    promise<void>readyFoo,readyBar;
    future<void>futureFoo,futureBar;
public:
    FooBar(int n) {
        this->n = n;
        futureFoo=readyFoo.get_future();
        futureBar=readyBar.get_future();
    }
    void foo(function<void()> printFoo) {   
        for (int i = 0; i < n; i++) {
            printFoo();
            readyFoo.set_value();
            futureBar.get();
            promise<void>newReadyBar;
            future<void>newFutureBar;
            readyBar=move(newReadyBar);
            newFutureBar=readyBar.get_future();
            futureBar=move(newFutureBar);
        }
    }
    void bar(function<void()> printBar) {   
        for (int i = 0; i < n; i++) {
            promise<void>newReadyFoo;
            future<void>newFutureFoo;
            readyFoo=move(newReadyFoo);
            newFutureFoo=readyFoo.get_future();
            futureFoo=move(newFutureFoo);
            printBar();
            readyBar.set_value();
        }
    }
};

ä½œè€…ï¼šå­æ´ª
é“¾æ¥ï¼šhttps://leetcode.cn/problems/print-foobar-alternately/solutions/1020308/c-duo-fang-fa-by-zhouzihong-zdvj/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚
```

åŸå­æ“ä½œ
```cpp
class FooBar {
private:
    int n;
    atomic<bool>foo_done=false;
public:
    FooBar(int n) {
        this->n = n;
    }
    void foo(function<void()> printFoo) {
        for (int i = 0; i < n; i++) {
            while(foo_done){
                this_thread::yield();
            }            
            printFoo();
            foo_done=true;
        }
    }
    void bar(function<void()> printBar) {
        for (int i = 0; i < n; i++) {
            while(foo_done==false){
                this_thread::yield();
            }            
            printBar();
            foo_done=false;
        }
    }
};

ä½œè€…ï¼šå­æ´ª
é“¾æ¥ï¼šhttps://leetcode.cn/problems/print-foobar-alternately/solutions/1020308/c-duo-fang-fa-by-zhouzihong-zdvj/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚
```

## leetcode 1116 æ‰“å°é›¶å’Œå¥‡å¶æ•°

> ç°æœ‰å‡½æ•° printNumber å¯ä»¥ç”¨ä¸€ä¸ªæ•´æ•°å‚æ•°è°ƒç”¨ï¼Œå¹¶è¾“å‡ºè¯¥æ•´æ•°åˆ°æ§åˆ¶å°ã€‚
> 
> ä¾‹å¦‚ï¼Œè°ƒç”¨ printNumber(7) å°†ä¼šè¾“å‡º 7 åˆ°æ§åˆ¶å°ã€‚
> ç»™ä½ ç±» ZeroEvenOdd çš„ä¸€ä¸ªå®ä¾‹ï¼Œè¯¥ç±»ä¸­æœ‰ä¸‰ä¸ªå‡½æ•°ï¼šzeroã€even å’Œ odd ã€‚ZeroEvenOdd çš„ç›¸åŒå®ä¾‹å°†ä¼šä¼ é€’ç»™ä¸‰ä¸ªä¸åŒçº¿ç¨‹ï¼š
> 
> çº¿ç¨‹ Aï¼šè°ƒç”¨ zero() ï¼Œåªè¾“å‡º 0
> çº¿ç¨‹ Bï¼šè°ƒç”¨ even() ï¼Œåªè¾“å‡ºå¶æ•°
> çº¿ç¨‹ Cï¼šè°ƒç”¨ odd() ï¼Œåªè¾“å‡ºå¥‡æ•°
> ä¿®æ”¹ç»™å‡ºçš„ç±»ï¼Œä»¥è¾“å‡ºåºåˆ— "010203040506..." ï¼Œå…¶ä¸­åºåˆ—çš„é•¿åº¦å¿…é¡»ä¸º 2n ã€‚
> 
> å®ç° ZeroEvenOdd ç±»ï¼š
> 
> ZeroEvenOdd(int n) ç”¨æ•°å­— n åˆå§‹åŒ–å¯¹è±¡ï¼Œè¡¨ç¤ºéœ€è¦è¾“å‡ºçš„æ•°ã€‚
> void zero(printNumber) è°ƒç”¨ printNumber ä»¥è¾“å‡ºä¸€ä¸ª 0 ã€‚
> void even(printNumber) è°ƒç”¨printNumber ä»¥è¾“å‡ºå¶æ•°ã€‚
> void odd(printNumber) è°ƒç”¨ printNumber ä»¥è¾“å‡ºå¥‡æ•°ã€‚

```cpp
#include <iostream>
#include <thread>
#include <functional>
#include <mutex>
#include <condition_variable>
using namespace std;

class ZeroEvenOdd {
private:
    int n;
    int flag;
    mutex mtx;
    condition_variable cv;
public:
    ZeroEvenOdd(int n) {
        this->n = n;
    }

    // printNumber(x) outputs "x", where x is an integer.
    void zero(function<void(int)> printNumber) {
        unique_lock<mutex> lock(mtx);
        for (int i = 0;i < n;i++) {
            cv.wait(lock, [this]() {return flag==0;});
            printNumber(0);
            flag = i%2==0 ? 2:1;
            cv.notify_all();
        }
    }

    void even(function<void(int)> printNumber) {
        unique_lock<mutex> lock(mtx);
        for(int i=2;i<=n;i+=2){
            cv.wait(lock, [this]() {return flag==1;});
            printNumber(i);
            flag = 0;
            cv.notify_all();
        }
    }

    void odd(function<void(int)> printNumber) {
        unique_lock<mutex> lock(mtx);
        for(int i=1;i<=n;i+=2){
            cv.wait(lock, [this]() {return flag==2;});
            printNumber(i);
            flag = 0;
            cv.notify_all();
        }
    }
};
void printNumber(int n) {
    cout << n << endl;
}
int main() {

    ZeroEvenOdd foo(10);
    // åˆ›å»ºä¸‰ä¸ªçº¿ç¨‹åˆ†åˆ«è°ƒç”¨ firstã€secondã€third æ–¹æ³•
    std::thread t1(&ZeroEvenOdd::zero, &foo, printNumber);
    std::thread t2(&ZeroEvenOdd::even, &foo, printNumber);
    std::thread t3(&ZeroEvenOdd::odd,  &foo, printNumber);

    // ç­‰å¾…æ‰€æœ‰çº¿ç¨‹æ‰§è¡Œå®Œæ¯•
    t1.join();
    t2.join();
    t3.join();

    return 0;

}
```

åŸå­æ“ä½œ
```cpp
class ZeroEvenOdd {
private:
    int n;
    atomic<int> flag = 0;
public:
    ZeroEvenOdd(int n) {
        this->n = n;
    }

    // printNumber(x) outputs "x", where x is an integer.
    void zero(function<void(int)> printNumber) {
        for (int i = 1; i <= n; ++i) {
            while (flag != 0) {
                this_thread::yield();
            }
            printNumber(0);
            if (i % 2 == 0) {
                flag = 2;
            } else {
                flag = 1;
            }
        }
    }

    void even(function<void(int)> printNumber) {
        for (int i = 2; i <= n; i += 2) {
            while (flag != 2) {
                this_thread::yield();
            }
            printNumber(i);
            flag = 0;
        } 
    }

    void odd(function<void(int)> printNumber) {
        for (int i = 1; i <= n; i += 2) {
            while (flag != 1) {
                this_thread::yield();
            }
            printNumber(i);
            flag = 0;
        }
    }
};

ä½œè€…ï¼šdesAweis
é“¾æ¥ï¼šhttps://leetcode.cn/problems/print-zero-even-odd/solutions/922116/c-san-chong-fang-shi-by-desaweis-imvm/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚
```

ä¿¡å·é‡
```cpp
#include <semaphore.h>

class ZeroEvenOdd {
private:
    int n;
    sem_t printOdd, printEven, numDone;
public:
    ZeroEvenOdd(int n) {
        this->n = n;
        sem_init(&printOdd, 0, 0);
        sem_init(&printEven, 0, 0);
        sem_init(&numDone, 0, 1);
    }

    // printNumber(x) outputs "x", where x is an integer.
    void zero(function<void(int)> printNumber) {
        for (int i = 1; i <= n; ++i) {
            sem_wait(&numDone);
            printNumber(0);
            if (i % 2 == 0) {
                sem_post(&printEven);
            } else {
                sem_post(&printOdd);
            }
        }
    }

    void even(function<void(int)> printNumber) {
        for (int i = 2; i <= n; i += 2) {
            sem_wait(&printEven);
            printNumber(i);
            sem_post(&numDone);
        }       
    }

    void odd(function<void(int)> printNumber) {
        for (int i = 1; i <=n; i += 2) {
            sem_wait(&printOdd);
            printNumber(i);
            sem_post(&numDone);
        }
    }
};

ä½œè€…ï¼šdesAweis
é“¾æ¥ï¼šhttps://leetcode.cn/problems/print-zero-even-odd/solutions/922116/c-san-chong-fang-shi-by-desaweis-imvm/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚
```
## leetcode 1117 H2Oç”Ÿæˆ

> ç°åœ¨æœ‰ä¸¤ç§çº¿ç¨‹ï¼Œæ°§ oxygen å’Œæ°¢ hydrogenï¼Œä½ çš„ç›®æ ‡æ˜¯ç»„ç»‡è¿™ä¸¤ç§çº¿ç¨‹æ¥äº§ç”Ÿæ°´åˆ†å­ã€‚
> 
> å­˜åœ¨ä¸€ä¸ªå±éšœï¼ˆbarrierï¼‰ä½¿å¾—æ¯ä¸ªçº¿ç¨‹å¿…é¡»ç­‰å€™ç›´åˆ°ä¸€ä¸ªå®Œæ•´æ°´åˆ†å­èƒ½å¤Ÿè¢«äº§ç”Ÿå‡ºæ¥ã€‚
> 
> æ°¢å’Œæ°§çº¿ç¨‹ä¼šè¢«åˆ†åˆ«ç»™äºˆ releaseHydrogen å’Œ releaseOxygen æ–¹æ³•æ¥å…è®¸å®ƒä»¬çªç ´å±éšœã€‚
> 
> è¿™äº›çº¿ç¨‹åº”è¯¥ä¸‰ä¸‰æˆç»„çªç ´å±éšœå¹¶èƒ½ç«‹å³ç»„åˆäº§ç”Ÿä¸€ä¸ªæ°´åˆ†å­ã€‚
> 
> ä½ å¿…é¡»ä¿è¯äº§ç”Ÿä¸€ä¸ªæ°´åˆ†å­æ‰€éœ€çº¿ç¨‹çš„ç»“åˆå¿…é¡»å‘ç”Ÿåœ¨ä¸‹ä¸€ä¸ªæ°´åˆ†å­äº§ç”Ÿä¹‹å‰ã€‚
> 
> æ¢å¥è¯è¯´:
> 
> å¦‚æœä¸€ä¸ªæ°§çº¿ç¨‹åˆ°è¾¾å±éšœæ—¶æ²¡æœ‰æ°¢çº¿ç¨‹åˆ°è¾¾ï¼Œå®ƒå¿…é¡»ç­‰å€™ç›´åˆ°ä¸¤ä¸ªæ°¢çº¿ç¨‹åˆ°è¾¾ã€‚
> å¦‚æœä¸€ä¸ªæ°¢çº¿ç¨‹åˆ°è¾¾å±éšœæ—¶æ²¡æœ‰å…¶å®ƒçº¿ç¨‹åˆ°è¾¾ï¼Œå®ƒå¿…é¡»ç­‰å€™ç›´åˆ°ä¸€ä¸ªæ°§çº¿ç¨‹å’Œå¦ä¸€ä¸ªæ°¢çº¿ç¨‹åˆ°è¾¾ã€‚
> ä¹¦å†™æ»¡è¶³è¿™äº›é™åˆ¶æ¡ä»¶çš„æ°¢ã€æ°§çº¿ç¨‹åŒæ­¥ä»£ç ã€‚

å½“ä¸€ä¸ªæ°¢/æ°§çº¿ç¨‹åˆ°è¾¾æ—¶ï¼Œå¦‚æœä¸å·²ç»åˆ°è¾¾çš„å…¶ä½™å…ƒç´ æ— æ³•ç»„æˆ H2Oï¼Œé‚£ä¹ˆå®ƒå¿…é¡»è¢«å¡åœ¨ releaseHydrogen() / releaseOxygen() ä¹‹å‰ã€‚

```cpp
class Semaphore {
private:
    int n_;
    mutex mu_;
    condition_variable cv_;

public:
    Semaphore(int n): n_{n} {}

public:
    void wait() {
        unique_lock<mutex> lock(mu_);
        if (!n_) {
            cv_.wait(lock, [this]{return n_;});
        }
        --n_;
    }

    void signal() {
        unique_lock<mutex> lock(mu_);
        ++n_;
        cv_.notify_one();
    }
};

class H2O {
private:
    Semaphore s_hIn, s_oIn;
    Semaphore s_hBarrier, s_oBarrier;

public:
    H2O(): s_hIn{2}, s_oIn{1}, s_hBarrier{0}, s_oBarrier{0} {}

    void hydrogen(function<void()> releaseHydrogen) {
        s_hIn.wait(); //é™åˆ¶æœ€å¤šæœ‰ä¸¤ä¸ª hydrogen å‡½æ•°åŒæ—¶è¢«è°ƒç”¨è¿è¡Œåˆ°ä¸‹ä¸€å¥ï¼Œç¬¬ä¸‰ä¸ªä¼šè¢«é˜»å¡åœ¨è¿™ä¸€å¥
        s_oBarrier.signal(); //å½“ signal ä¸¤æ¬¡æ‰èƒ½è§£é™¤ oxygen å‡½æ•°çš„é˜»å¡ï¼Œä¿è¯äº†ä¸¤ä¸ª H,å¿…æœ‰ä¸€ä¸ª O
        s_hBarrier.wait(); //æ­¤å¤„ä¼šé˜»å¡ï¼Œç›´åˆ° oxygen å‡½æ•°æ‰§è¡Œå®Œ s_hBarrier.signal();æ‰èƒ½å¾€ä¸‹äº§ç”Ÿ H2O
        releaseHydrogen();
        s_hIn.signal(); //æ¢å¤ä¿¡å·é‡ï¼Œè¿›è¡Œä¸‹ä¸€è½®åˆæˆ
    }

    void oxygen(function<void()> releaseOxygen) {
        s_oIn.wait(); //é™åˆ¶æœ€å¤šæœ‰ä¸€ä¸ª oxygen å‡½æ•°è¢«è°ƒç”¨è¿è¡Œåˆ°ä¸‹ä¸€å¥ï¼Œç¬¬äºŒä¸ªä¼šè¢«é˜»å¡åœ¨è¿™ä¸€å¥
        s_oBarrier.wait(); // ç­‰å¾…ä¸¤ä¸ª hydrogen å‡½æ•°æ‰§è¡Œå®Œ s_hBarrier.signal();
        s_oBarrier.wait();
        s_hBarrier.signal();  //å”¤é†’ä¸¤ä¸ªè¢«é˜»å¡çš„ hydrogen å‡½æ•°çš„ s_hBarrier.wait();
        s_hBarrier.signal();
        releaseOxygen();

        s_oIn.signal();//æ¢å¤ä¿¡å·é‡ï¼Œè¿›è¡Œä¸‹ä¸€è½®åˆæˆ
    }
};

ä½œè€…ï¼šzerotrac ğŸŒ¸
é“¾æ¥ï¼šhttps://leetcode.cn/problems/building-h2o/solutions/351324/c-shou-xie-xin-hao-liang-man-zu-ti-mu-yao-qiu-de-x/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚
```

```cpp
#include <semaphore.h>
class H2O {
    sem_t s1, s2;
    int state = 0;
public:
    H2O() {
        sem_init(&s1, 0, 2);
        sem_init(&s2, 0, 0);
        // sem_post(&s1);
    }

    void hydrogen(function<void()> releaseHydrogen) {
        sem_wait(&s1);
        state++;
        // releaseHydrogen() outputs "H". Do not change or remove this line.
        releaseHydrogen();
        if (state == 2) {
            sem_post(&s2);
        }
    }

    void oxygen(function<void()> releaseOxygen) {
        sem_wait(&s2);
        // releaseOxygen() outputs "O". Do not change or remove this line.
        releaseOxygen();
        state = 0;
        sem_post(&s1);
        sem_post(&s1);
    }
};

ä½œè€…ï¼šdestiny
é“¾æ¥ï¼šhttps://leetcode.cn/problems/building-h2o/solutions/955301/tiao-jian-bian-liang-xin-hao-liang-yuan-2cv85/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚
```
```cpp
class H2O {
    int hcount{0};
    bool ocount{false};
    mutex mtx;
    condition_variable cv;
public:
    H2O() {
        
    }

    void hydrogen(function<void()> releaseHydrogen) {
        unique_lock<mutex> lock(mtx);
        cv.wait(lock, [this](){return hcount<2; });
        // releaseHydrogen() outputs "H". Do not change or remove this line.
        releaseHydrogen();
        hcount++;
        if(hcount==2 && ocount==true){
            hcount=0;
            ocount=false;
            cv.notify_all();
        }
    }

    void oxygen(function<void()> releaseOxygen) {
        unique_lock<mutex> lock(mtx);
        cv.wait(lock, [this](){return !ocount; });
        
        // releaseOxygen() outputs "O". Do not change or remove this line.
        releaseOxygen();
        ocount=true;
        if(hcount==2 && ocount==true){
            hcount=0;
            ocount=false;
            cv.notify_all();
        }
    }
};
```

## leetcode 1195 äº¤æ›¿æ‰“å°å­—ç¬¦ä¸²

> ç¼–å†™ä¸€ä¸ªå¯ä»¥ä» 1 åˆ° n è¾“å‡ºä»£è¡¨è¿™ä¸ªæ•°å­—çš„å­—ç¬¦ä¸²çš„ç¨‹åºï¼Œä½†æ˜¯ï¼š
> 
> å¦‚æœè¿™ä¸ªæ•°å­—å¯ä»¥è¢« 3 æ•´é™¤ï¼Œè¾“å‡º "fizz"ã€‚
> å¦‚æœè¿™ä¸ªæ•°å­—å¯ä»¥è¢« 5 æ•´é™¤ï¼Œè¾“å‡º "buzz"ã€‚
> å¦‚æœè¿™ä¸ªæ•°å­—å¯ä»¥åŒæ—¶è¢« 3 å’Œ 5 æ•´é™¤ï¼Œè¾“å‡º "fizzbuzz"ã€‚
> ä¾‹å¦‚ï¼Œå½“ n = 15ï¼Œè¾“å‡ºï¼š 1, 2, fizz, 4, buzz, fizz, 7, 8, fizz, buzz, 11, fizz, 13, 14, > fizzbuzzã€‚
> 
> å‡è®¾æœ‰è¿™ä¹ˆä¸€ä¸ªç±»ï¼š
> 
> class FizzBuzz {
>   public FizzBuzz(int n) { ... }               // constructor
>   public void fizz(printFizz) { ... }          // only output "fizz"
>   public void buzz(printBuzz) { ... }          // only output "buzz"
>   public void fizzbuzz(printFizzBuzz) { ... }  // only output "fizzbuzz"
>   public void number(printNumber) { ... }      // only output the numbers
> }
> è¯·ä½ å®ç°ä¸€ä¸ªæœ‰å››ä¸ªçº¿ç¨‹çš„å¤šçº¿ç¨‹ç‰ˆ  FizzBuzzï¼Œ åŒä¸€ä¸ª FizzBuzz å®ä¾‹ä¼šè¢«å¦‚ä¸‹å››ä¸ªçº¿ç¨‹ä½¿ç”¨ï¼š
> 
> çº¿ç¨‹Aå°†è°ƒç”¨ fizz() æ¥åˆ¤æ–­æ˜¯å¦èƒ½è¢« 3 æ•´é™¤ï¼Œå¦‚æœå¯ä»¥ï¼Œåˆ™è¾“å‡º fizzã€‚
> çº¿ç¨‹Bå°†è°ƒç”¨ buzz() æ¥åˆ¤æ–­æ˜¯å¦èƒ½è¢« 5 æ•´é™¤ï¼Œå¦‚æœå¯ä»¥ï¼Œåˆ™è¾“å‡º buzzã€‚
> çº¿ç¨‹Cå°†è°ƒç”¨ fizzbuzz() æ¥åˆ¤æ–­æ˜¯å¦åŒæ—¶èƒ½è¢« 3 å’Œ 5 æ•´é™¤ï¼Œå¦‚æœå¯ä»¥ï¼Œåˆ™è¾“å‡º fizzbuzzã€‚
> çº¿ç¨‹Då°†è°ƒç”¨ number() æ¥å®ç°è¾“å‡ºæ—¢ä¸èƒ½è¢« 3 æ•´é™¤ä¹Ÿä¸èƒ½è¢« 5 æ•´é™¤çš„æ•°å­—ã€‚
 

**æ³¨æ„è®°å¾—åŠ ä¸Š (current > n) ï¼Œå¦åˆ™ä¼šæœ‰çº¿ç¨‹ä¸ä¼šé‡Šæ”¾ï¼Œä¸€ç›´å¡åœ¨waitä¸­ï¼›**
```cpp
#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>

class FizzBuzz {
private:
    int n;
    int current;
    std::mutex mtx;
    std::condition_variable cv;

public:
    FizzBuzz(int n) : n(n), current(1) {}

    // è¾“å‡º "fizz"
    void fizz(std::function<void()> printFizz) {
        while (true) {
            std::unique_lock<std::mutex> lock(mtx);
            // ç­‰å¾…è½®åˆ°å½“å‰çº¿ç¨‹å¤„ç†
            cv.wait(lock, [this] { return (current > n) || (current % 3 == 0 && current % 5 != 0); });
            if (current > n) break;
            printFizz();
            ++current;
            // é€šçŸ¥å…¶ä»–çº¿ç¨‹
            cv.notify_all();
        }
    }

    // è¾“å‡º "buzz"
    void buzz(std::function<void()> printBuzz) {
        while (true) {
            std::unique_lock<std::mutex> lock(mtx);
            // ç­‰å¾…è½®åˆ°å½“å‰çº¿ç¨‹å¤„ç†
            cv.wait(lock, [this] { return (current > n) || (current % 5 == 0 && current % 3 != 0); });
            if (current > n) break;
            printBuzz();
            ++current;
            // é€šçŸ¥å…¶ä»–çº¿ç¨‹
            cv.notify_all();
        }
    }

    // è¾“å‡º "fizzbuzz"
    void fizzbuzz(std::function<void()> printFizzBuzz) {
        while (true) {
            std::unique_lock<std::mutex> lock(mtx);
            // ç­‰å¾…è½®åˆ°å½“å‰çº¿ç¨‹å¤„ç†
            cv.wait(lock, [this] { return (current > n) || (current % 15 == 0); });
            if (current > n) break;
            printFizzBuzz();
            ++current;
            // é€šçŸ¥å…¶ä»–çº¿ç¨‹
            cv.notify_all();
        }
    }

    // è¾“å‡ºæ•°å­—
    void number(std::function<void(int)> printNumber) {
        while (true) {
            std::unique_lock<std::mutex> lock(mtx);
            // ç­‰å¾…è½®åˆ°å½“å‰çº¿ç¨‹å¤„ç†
            cv.wait(lock, [this] { return (current > n) || (current % 3 != 0 && current % 5 != 0); });
            if (current > n) break;
            printNumber(current);
            ++current;
            // é€šçŸ¥å…¶ä»–çº¿ç¨‹
            cv.notify_all();
        }
    }
};

// è¾…åŠ©å‡½æ•°ç”¨äºæ‰“å°
void printFizz() {
    std::cout << "fizz";
    if (std::this_thread::get_id() != std::thread::id()) {
        std::cout << ", ";
    }
}

void printBuzz() {
    std::cout << "buzz";
    if (std::this_thread::get_id() != std::thread::id()) {
        std::cout << ", ";
    }
}

void printFizzBuzz() {
    std::cout << "fizzbuzz";
    if (std::this_thread::get_id() != std::thread::id()) {
        std::cout << ", ";
    }
}

void printNumber(int num) {
    std::cout << num;
    if (std::this_thread::get_id() != std::thread::id()) {
        std::cout << ", ";
    }
}

int main() {
    int n = 15;
    FizzBuzz fb(n);

    // åˆ›å»ºå››ä¸ªçº¿ç¨‹
    std::thread t1(&FizzBuzz::fizz, &fb, printFizz);
    std::thread t2(&FizzBuzz::buzz, &fb, printBuzz);
    std::thread t3(&FizzBuzz::fizzbuzz, &fb, printFizzBuzz);
    std::thread t4(&FizzBuzz::number, &fb, printNumber);

    // ç­‰å¾…æ‰€æœ‰çº¿ç¨‹å®Œæˆ
    t1.join();
    t2.join();
    t3.join();
    t4.join();

    std::cout << std::endl;

    return 0;
}
```

ä¿¡å·é‡ï¼š
```cpp
#include <semaphore.h>
#include <functional>
#include <thread>
using namespace std;

class FizzBuzz {
private:
    int n;
    int cur;
    sem_t sem_fizz;
    sem_t sem_buzz;
    sem_t sem_fizz_buzz;
    sem_t sem_num;

public:
    FizzBuzz(int n) {
        this->n = n;
        cur = 0;
        sem_init(&sem_fizz, 0, 0);
        sem_init(&sem_buzz, 0, 0);
        sem_init(&sem_fizz_buzz, 0, 0);
        sem_init(&sem_num, 0, 1);
    }

    // printFizz() outputs "fizz".
    void fizz(function<void()> printFizz) {
        while(cur <= n){
            sem_wait(&sem_fizz);
            if(cur > n) break;
            printFizz();
            sem_post(&sem_num);
        }
    }

    // printBuzz() outputs "buzz".
    void buzz(function<void()> printBuzz) {
        while(cur <= n){
            sem_wait(&sem_buzz);
            if(cur > n) break;
            printBuzz();
            sem_post(&sem_num);
        }
    }

    // printFizzBuzz() outputs "fizzbuzz".
    void fizzbuzz(function<void()> printFizzBuzz) {
        while(cur <= n){
            sem_wait(&sem_fizz_buzz);
            if(cur > n) break;
            printFizzBuzz();
            sem_post(&sem_num);
        }
    }

    // printNumber(x) outputs "x", where x is an integer.
    void number(function<void(int)> printNumber) {
        while(++cur <= n){
            sem_wait(&sem_num);
            if(cur % 3 == 0 && cur % 5 == 0){
                sem_post(&sem_fizz_buzz);
            }else if(cur % 3 == 0){
                sem_post(&sem_fizz);
            }else if(cur % 5 == 0){
                sem_post(&sem_buzz);
            }else{
                printNumber(cur);
                sem_post(&sem_num);
            }
        }

        // ä»¥ä¸‹ä¸‰ä¸ªposté€šè¿‡æ›´æ–°sem_fizzç­‰ä¿¡å·é‡ï¼Œè°ƒåŠ¨å…¶ä»–çº¿ç¨‹è¿è¡Œï¼Œè¿›è€Œç»“æŸæ‰€æœ‰çº¿ç¨‹
        sem_post(&sem_fizz);
        sem_post(&sem_buzz);
        sem_post(&sem_fizz_buzz);
    }
};

ä½œè€…ï¼šNeo
é“¾æ¥ï¼šhttps://leetcode.cn/problems/fizz-buzz-multithreaded/solutions/199487/c-xin-hao-liang-by-litoneo/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚
```

## leetcode 1226 å“²å­¦å®¶è¿›é¤

>5 ä¸ªæ²‰é»˜å¯¡è¨€çš„å“²å­¦å®¶å›´ååœ¨åœ†æ¡Œå‰ï¼Œæ¯äººé¢å‰ä¸€ç›˜æ„é¢ã€‚å‰å­æ”¾åœ¨å“²å­¦å®¶ä¹‹é—´çš„æ¡Œé¢ä¸Šã€‚ï¼ˆ5 ä¸ªå“²å­¦å®¶ï¼Œ5 æ ¹å‰>å­ï¼‰
>
>æ‰€æœ‰çš„å“²å­¦å®¶éƒ½åªä¼šåœ¨æ€è€ƒå’Œè¿›é¤ä¸¤ç§è¡Œä¸ºé—´äº¤æ›¿ã€‚å“²å­¦å®¶åªæœ‰åŒæ—¶æ‹¿åˆ°å·¦è¾¹å’Œå³è¾¹çš„å‰å­æ‰èƒ½åƒåˆ°é¢ï¼Œè€ŒåŒä¸€æ ¹å‰å­åœ¨åŒä¸€æ—¶é—´åªèƒ½è¢«ä¸€ä¸ªå“²å­¦å®¶ä½¿ç”¨ã€‚æ¯ä¸ªå“²å­¦å®¶åƒå®Œé¢åéƒ½éœ€è¦æŠŠå‰å­æ”¾å›æ¡Œé¢ä»¥ä¾›å…¶ä»–å“²å­¦å®¶åƒé¢ã€‚åªè¦æ¡ä»¶å…è®¸ï¼Œå“²å­¦å®¶å¯ä»¥æ‹¿èµ·å·¦è¾¹æˆ–è€…å³è¾¹çš„å‰å­ï¼Œä½†åœ¨æ²¡æœ‰åŒæ—¶æ‹¿åˆ°å·¦å³å‰å­æ—¶ä¸èƒ½è¿›é£Ÿã€‚
>
>å‡è®¾é¢çš„æ•°é‡æ²¡æœ‰é™åˆ¶ï¼Œå“²å­¦å®¶ä¹Ÿèƒ½éšä¾¿åƒï¼Œä¸éœ€è¦è€ƒè™‘åƒä¸åƒå¾—ä¸‹ã€‚
>
>è®¾è®¡ä¸€ä¸ªè¿›é¤è§„åˆ™ï¼ˆå¹¶è¡Œç®—æ³•ï¼‰ä½¿å¾—æ¯ä¸ªå“²å­¦å®¶éƒ½ä¸ä¼šæŒ¨é¥¿ï¼›ä¹Ÿå°±æ˜¯è¯´ï¼Œåœ¨æ²¡æœ‰äººçŸ¥é“åˆ«äººä»€ä¹ˆæ—¶å€™æƒ³åƒä¸œè¥¿æˆ–æ€è€ƒçš„æƒ…å†µä¸‹ï¼Œæ¯ä¸ªå“²å­¦å®¶éƒ½å¯ä»¥åœ¨åƒé¥­å’Œæ€è€ƒä¹‹é—´ä¸€ç›´äº¤æ›¿ä¸‹å»ã€‚
>
>å“²å­¦å®¶ä» 0 åˆ° 4 æŒ‰ é¡ºæ—¶é’ˆ ç¼–å·ã€‚è¯·å®ç°å‡½æ•° void wantsToEat(philosopher, pickLeftFork, >pickRightFork, eat, putLeftFork, putRightFork)ï¼š
>
>+ philosopher å“²å­¦å®¶çš„ç¼–å·ã€‚
>+ pickLeftFork å’Œ pickRightFork è¡¨ç¤ºæ‹¿èµ·å·¦è¾¹æˆ–å³è¾¹çš„å‰å­ã€‚
>+ eat è¡¨ç¤ºåƒé¢ã€‚
>+ putLeftFork å’Œ putRightFork è¡¨ç¤ºæ”¾ä¸‹å·¦è¾¹æˆ–å³è¾¹çš„å‰å­ã€‚
>+ ç”±äºå“²å­¦å®¶ä¸æ˜¯åœ¨åƒé¢å°±æ˜¯åœ¨æƒ³ç€å•¥æ—¶å€™åƒé¢ï¼Œæ‰€ä»¥æ€è€ƒè¿™ä¸ªæ–¹æ³•æ²¡æœ‰å¯¹åº”çš„å›è°ƒã€‚
>
>ç»™ä½  5 ä¸ªçº¿ç¨‹ï¼Œæ¯ä¸ªéƒ½ä»£è¡¨ä¸€ä¸ªå“²å­¦å®¶ï¼Œè¯·ä½ ä½¿ç”¨ç±»çš„åŒä¸€ä¸ªå¯¹è±¡æ¥æ¨¡æ‹Ÿè¿™ä¸ªè¿‡ç¨‹ã€‚åœ¨æœ€åä¸€æ¬¡è°ƒç”¨ç»“æŸä¹‹å‰ï¼Œå¯èƒ½ä¼šä¸ºåŒä¸€ä¸ªå“²å­¦å®¶å¤šæ¬¡è°ƒç”¨è¯¥å‡½æ•°ã€‚


### https://blog.csdn.net/Yun_Ge/article/details/89177918

ä¸ºäº†å®ç°å¯¹ç­·å­çš„äº’æ–¥è®¿é—®ï¼Œå¯ä»¥ç”¨ä¸€ä¸ªä¿¡å·é‡è¡¨ç¤ºç­·å­ï¼Œç”±è¿™äº”ä¸ªä¿¡å·é‡æ„æˆä¿¡å·é‡æ•°ç»„

```cpp
semaphore chopstick[5] = {1,1,1,1,1};
while(true)
{
	/*å½“å“²å­¦å®¶é¥¥é¥¿æ—¶ï¼Œæ€»æ˜¯å…ˆæ‹¿å·¦è¾¹çš„ç­·å­ï¼Œå†æ‹¿å³è¾¹çš„ç­·å­*/
	wait(chopstick[i]);
	wait(chopstick[(i+1)%5]);

	// åƒé¥­
 
	/*å½“å“²å­¦å®¶è¿›é¤å®Œæˆåï¼Œæ€»æ˜¯å…ˆæ”¾ä¸‹å·¦è¾¹çš„ç­·å­ï¼Œå†æ”¾ä¸‹å³è¾¹çš„ç­·å­*/
	signal(chopstick[i]);
	signal(chopstick[(i+1)%5]);
}

```

ä¸Šè¿°çš„ä»£ç å¯ä»¥ä¿è¯ä¸ä¼šæœ‰ä¸¤ä¸ªç›¸é‚»çš„å“²å­¦å®¶åŒæ—¶è¿›é¤ï¼Œä½†å´å¯èƒ½å¼•èµ·æ­»é”çš„æƒ…å†µã€‚å‡å¦‚äº”ä½å“²å­¦å®¶åŒæ—¶é¥¥é¥¿è€Œéƒ½æ‹¿èµ·çš„å·¦è¾¹çš„ç­·å­ï¼Œå°±ä¼šä½¿äº”ä¸ªä¿¡å·é‡chopstickéƒ½ä¸º0ï¼Œå½“ä»–ä»¬è¯•å›¾å»æ‹¿å³æ‰‹è¾¹çš„ç­·å­æ—¶ï¼Œéƒ½å°†æ— ç­·å­è€Œé™·å…¥æ— é™æœŸçš„ç­‰å¾…ã€‚

> 1. æœ€å¤šåªå…è®¸4ä¸ªå“²å­¦å®¶åŒæ—¶è¿›é¤ï¼Œä»¥ä¿è¯è‡³å°‘æœ‰ä¸€ä¸ªå“²å­¦å®¶èƒ½å¤Ÿè¿›é¤ï¼Œæœ€ç»ˆæ€»ä¼šé‡Šæ”¾å‡ºä»–æ‰€ä½¿ç”¨è¿‡çš„ä¸¤æ”¯ç­·å­ï¼Œä»è€Œå¯ä½¿æ›´å¤šçš„å“²å­¦å®¶è¿›é¤ã€‚å®šä¹‰ä¿¡å·é‡countï¼Œåªå…è®¸4ä¸ªå“²å­¦å®¶åŒæ—¶è¿›é¤ï¼Œè¿™æ ·å°±èƒ½ä¿è¯è‡³å°‘æœ‰ä¸€ä¸ªå“²å­¦å®¶å¯ä»¥å°±é¤ã€‚

```cpp
semaphore chopstick[5]={1,1,1,1,1};
semaphore count=4; // è®¾ç½®ä¸€ä¸ªcountï¼Œæœ€å¤šæœ‰å››ä¸ªå“²å­¦å®¶å¯ä»¥è¿›æ¥
void philosopher(int i)
{
	while(true)
	{
		think();
		wait(count); //è¯·æ±‚è¿›å…¥æˆ¿é—´è¿›é¤ å½“countä¸º0æ—¶ ä¸èƒ½å…è®¸å“²å­¦å®¶å†è¿›æ¥äº†
		wait(chopstick[i]); //è¯·æ±‚å·¦æ‰‹è¾¹çš„ç­·å­
		wait(chopstick[(i+1)%5]); //è¯·æ±‚å³æ‰‹è¾¹çš„ç­·å­
		eat();
		signal(chopstick[i]); //é‡Šæ”¾å·¦æ‰‹è¾¹çš„ç­·å­
		signal(chopstick[(i+1)%5]); //é‡Šæ”¾å³æ‰‹è¾¹çš„ç­·å­
		signal(count); //ç¦»å¼€é¥­æ¡Œé‡Šæ”¾ä¿¡å·é‡
	}
}

```

```cpp
#include <iostream>
#include <mutex>
#include <functional>
#include <thread>
#include <vector>

class Semaphore{
    mutex mtx;
    condition_variable cv;
    int count;
public:
    Semaphore(int count=0) : count(count){}
    void Set(int count){
        this->count=count;
    }
    void Signal(){
        unique_lock<mutex> lock(mtx);
        ++count;
        cv.notify_one();
    }
    void Wait(){
        unique_lock<mutex> lock(mtx);
        if(count<=0){
            cv.wait(lock, [this](){return count>0;});
        }
        --count;
    }

};


class DiningPhilosophers {
    mutex lock[5];
    Semaphore guid;
public:
    DiningPhilosophers() {
        guid.Set(4);
    }

    void wantsToEat(int philosopher,
                    function<void()> pickLeftFork,
                    function<void()> pickRightFork,
                    function<void()> eat,
                    function<void()> putLeftFork,
                    function<void()> putRightFork) {
		int l=philosopher;
        int r=(philosopher+1)%5;
        
        guid.Wait();
        lock[l].lock();
        lock[r].lock();
        pickLeftFork();
        pickRightFork();
        eat();
        putRightFork();
        putLeftFork();
        lock[r].unlock();   
        lock[l].unlock();
        guid.Signal();
    }
};

// æ¨¡æ‹Ÿå“²å­¦å®¶è¿›é¤çš„å‡½æ•°
void simulatePhilosopher(DiningPhilosophers& dining, int philosopher) {
    auto pickLeftFork = [philosopher]() {
        std::cout << "Philosopher " << philosopher << " picked up left fork." << std::endl;
    };
    auto pickRightFork = [philosopher]() {
        std::cout << "Philosopher " << philosopher << " picked up right fork." << std::endl;
    };
    auto eat = [philosopher]() {
        std::cout << "Philosopher " << philosopher << " is eating." << std::endl;
    };
    auto putLeftFork = [philosopher]() {
        std::cout << "Philosopher " << philosopher << " put down left fork." << std::endl;
    };
    auto putRightFork = [philosopher]() {
        std::cout << "Philosopher " << philosopher << " put down right fork." << std::endl;
    };

    // æ¨¡æ‹Ÿå“²å­¦å®¶å¤šæ¬¡è¿›é¤
    for (int i = 0; i < 3; ++i) {
        dining.wantsToEat(philosopher, pickLeftFork, pickRightFork, eat, putLeftFork, putRightFork);
    }
}

int main() {
    DiningPhilosophers dining;
    std::vector<std::thread> threads;

    // åˆ›å»º 5 ä¸ªçº¿ç¨‹ï¼Œæ¯ä¸ªçº¿ç¨‹ä»£è¡¨ä¸€ä¸ªå“²å­¦å®¶
    for (int i = 0; i < 5; ++i) {
        threads.emplace_back(simulatePhilosopher, std::ref(dining), i);
    }

    // ç­‰å¾…æ‰€æœ‰çº¿ç¨‹å®Œæˆ
    for (auto& thread : threads) {
        thread.join();
    }

    return 0;
}
```

> 2. ä»…å½“å“²å­¦å®¶çš„å·¦å³ä¸¤æ”¯ç­·å­éƒ½å¯ç”¨æ—¶ï¼Œæ‰å…è®¸ä»–æ‹¿èµ·ç­·å­è¿›é¤ã€‚

å¯ä»¥åˆ©ç”¨AND å‹ä¿¡å·é‡æœºåˆ¶å®ç°ï¼Œä¹Ÿå¯ä»¥åˆ©ç”¨ä¿¡å·é‡çš„ä¿æŠ¤æœºåˆ¶å®ç°ã€‚åˆ©ç”¨ä¿¡å·é‡çš„ä¿æŠ¤æœºåˆ¶å®ç°çš„æ€æƒ³æ˜¯é€šè¿‡è®°å½•å‹ä¿¡å·é‡mutexå¯¹å–å·¦ä¾§å’Œå³ä¾§ç­·å­çš„æ“ä½œè¿›è¡Œä¿æŠ¤ï¼Œä½¿ä¹‹æˆä¸ºä¸€ä¸ªåŸå­æ“ä½œï¼Œè¿™æ ·å¯ä»¥é˜²æ­¢æ­»é”çš„å‡ºç°ã€‚æè¿°å¦‚ä¸‹ï¼š

```cpp
class DiningPhilosophers {
    mutex lock[5];
    mutex mtx;
public:
    DiningPhilosophers() {
        
    }

    void wantsToEat(int philosopher,
                    function<void()> pickLeftFork,
                    function<void()> pickRightFork,
                    function<void()> eat,
                    function<void()> putLeftFork,
                    function<void()> putRightFork) {
        int l=philosopher;
        int r=(philosopher+1)%5;

        mtx.lock();
        lock_guard<std::mutex> left(lock[l]);
        lock_guard<std::mutex> right(lock[r]);
        pickLeftFork();
        pickRightFork();
        mtx.unlock();

        eat();
        putLeftFork();
        putRightFork();
    }
};
```

ä½¿ç”¨ std::lock  åŒæ—¶é”ä½å¤šä¸ªäº’æ–¥é‡
std::lock å¯ä»¥ä¸€æ¬¡æ€§é”ä½å¤šä¸ªäº’æ–¥é‡ï¼Œå¹¶ä¸”ä»¥é¿å…æ­»é”çš„æ–¹å¼è¿›è¡ŒåŠ é”æ“ä½œã€‚

```cpp
#include <mutex>
#include <functional>

class DiningPhilosophers {
    std::mutex locks[5];

public:
    DiningPhilosophers() {}

    void wantsToEat(int philosopher,
                    std::function<void()> pickLeftFork,
                    std::function<void()> pickRightFork,
                    std::function<void()> eat,
                    std::function<void()> putLeftFork,
                    std::function<void()> putRightFork) {
        int left = philosopher;
        int right = (philosopher + 1) % 5;

        // åŒæ—¶é”ä½å·¦å³ç­·å­å¯¹åº”çš„äº’æ–¥é‡ï¼Œé¿å…æ­»é”
        std::lock(locks[left], locks[right]);

        // ä½¿ç”¨ std::adopt_lock è¡¨ç¤ºå·²ç»åŠ é”ï¼Œæ„é€ æ—¶ä¸å†åŠ é”
        std::lock_guard<std::mutex> leftLock(locks[left], std::adopt_lock);
        std::lock_guard<std::mutex> rightLock(locks[right], std::adopt_lock);

        pickLeftFork();
        pickRightFork();
        eat();
        putRightFork();
        putLeftFork();
    }
};
```



>  3. å¥‡å¶ç¼–å·ç­–ç•¥
è®©å¶æ•°ç¼–å·çš„å“²å­¦å®¶å…ˆæ‹¿å·¦è¾¹çš„ç­·å­ï¼Œå¥‡æ•°ç¼–å·çš„å“²å­¦å®¶å…ˆæ‹¿å³è¾¹çš„ç­·å­ï¼Œä»¥æ­¤æ‰“ç ´å¾ªç¯ç­‰å¾…çš„æ¡ä»¶ï¼Œé¿å…æ­»é”ï¼Œä»è€Œæœ‰å¯èƒ½è®©å¤šä¸ªå“²å­¦å®¶åŒæ—¶æ‹¿åˆ°ç­·å­ã€‚

```cpp
class DiningPhilosophers {
    std::mutex locks[5];

public:
    DiningPhilosophers() {}

    void wantsToEat(int philosopher,
                    std::function<void()> pickLeftFork,
                    std::function<void()> pickRightFork,
                    std::function<void()> eat,
                    std::function<void()> putLeftFork,
                    std::function<void()> putRightFork) {
        int left = philosopher;
        int right = (philosopher + 1) % 5;

        // å¶æ•°ç¼–å·çš„å“²å­¦å®¶å…ˆæ‹¿å·¦è¾¹çš„ç­·å­
        if (philosopher % 2 == 0) {
            std::lock_guard<std::mutex> leftLock(locks[left]);
            std::lock_guard<std::mutex> rightLock(locks[right]);
            pickLeftFork();
            pickRightFork();
            eat();
            putRightFork();
            putLeftFork();
        } 
        // å¥‡æ•°ç¼–å·çš„å“²å­¦å®¶å…ˆæ‹¿å³è¾¹çš„ç­·å­
        else {
            std::lock_guard<std::mutex> rightLock(locks[right]);
            std::lock_guard<std::mutex> leftLock(locks[left]);
            pickRightFork();
            pickLeftFork();
            eat();
            putLeftFork();
            putRightFork();
        }
    }
};
```




















