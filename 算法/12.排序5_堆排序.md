12. 堆排序
	**堆**
	将任意节点不大于其子节点的堆叫做最小堆或小根堆，而将任意节点不小于其子节点的堆叫做最大堆或大根堆。常见的堆有二叉堆、左倾堆、斜堆、二项堆、斐波那契堆等等。

	二叉堆：
	二叉堆是完全二元树或者是近似完全二元树，它分为两种：最大堆和最小堆。
	最大堆：父结点的键值总是大于或等于任何一个子节点的键值；最小堆：父结点的键值总是小于或等于任何一个子节点的键值。示意图如下：

	![](https://images0.cnblogs.com/i/497634/201403/182339209436216.jpg)


	二叉堆一般都通过"数组"来实现。数组实现的二叉堆，父节点和子节点的位置存在一定的关系。有时候，我们将"二叉堆的第一个元素"放在数组索引0的位置，有时候放在1的位置。当然，它们的本质一样(都是二叉堆)，只是实现上稍微有一丁点区别。
	假设"第一个元素"在数组中的索引为 0 的话，则父节点和子节点的位置关系如下：
	(01) 索引为i的左孩子的索引是 (2*i+1);
	(02) 索引为i的左孩子的索引是 (2*i+2);
	(03) 索引为i的父结点的索引是 floor((i-1)/2);

	![](https://images0.cnblogs.com/i/497634/201403/182342224903953.jpg)

	假设"第一个元素"在数组中的索引为 1 的话，则父节点和子节点的位置关系如下：
	(01) 索引为i的左孩子的索引是 (2*i);
	(02) 索引为i的左孩子的索引是 (2*i+1);
	(03) 索引为i的父结点的索引是 floor(i/2);

	![](https://images0.cnblogs.com/i/497634/201403/182343402241540.jpg)

	1. 实现：最大堆排序，这里使用的是从上向下调整

	```cpp
	#include<iostream>
	#include<vector>
	using namespace std;
	void HeapSort(vector<int>& a);
	void HeapAdjust(vector<int>& a, int i, int len);
	void swap(vector<int>& a,int i,int j);

	int main()
	{
		vector<int>a = { 9,1,5,8,3,7,4,6,2 };
		for (auto x : a) { cout << x << " "; };
		HeapSort(a);
		cout << endl;
		for (auto x : a) { cout << x << " "; };
		return 0;
	}
	// 最大堆排序
	void HeapSort(vector<int>& a)
	{
		int i;
		int len = a.size();
		//1.构建大顶堆，从(n/2-1) --> 0逐次遍历。遍历之后，得到的数组实际上是一个(最大)二叉堆。
		for (i = len / 2 - 1; i >= 0; i--)
			//从第一个非叶子结点从下至上，从右至左调整结构
			HeapAdjust(a, i,len);
		//2.调整堆结构+交换堆顶元素与末尾元素，从最后一个元素开始对序列进行调整，不断的缩小调整的范围直到第一个元素
		for (int j = len - 1; j > 0; j--)
		{
			// 交换a[0]和a[i]。交换后，a[i]是a[0...i]中最大的。
			swap(a, 0, j);//将堆顶元素与末尾元素进行交换
			// 调整a[0...i-1]，使得a[0...i-1]仍然是一个最大堆。
        	// 即，保证a[i-1]是a[0...i-1]中的最大值。
			HeapAdjust(a, 0,j);//重新对堆进行调整

		}

	}
	//这里的调整是从0开始，调整到0+len。这是因为，最大的值已经被放到堆末尾了，不能包含
	void HeapAdjust(vector<int>& a, int i, int len)
	{
		int temp, j;
		temp = a[i];//先取出当前元素i
		//从i结点的左子结点开始，也就是2i+1处开始
		for (j = 2 * i + 1; j < len; j = 2 * j + 1)
		{
			if (j + 1 < len && a[j] < a[j + 1]) //如果左子结点小于右子结点，j指向右子结点
				j++;
			if (a[j] > temp) //如果子节点大于父节点，将子节点值赋给父节点（不用进行交换）
			{
				a[i] = a[j];
				i = j;
			}
			else
			{
				break;
			}
		}
		a[i] = temp;//将temp值放到最终的位置
	}
	void swap(vector<int>& a, int i, int j)
	{
		int temp = a[i];
		a[i] = a[j];
		a[j] = temp;
	}
	```
	2. 实现：最小堆排序，这里使用的是从上向下调整，相交与最大堆排序，其实就只要更改调整数(最小)堆的向下调整算法
	```cpp
	void heapAdjust(vector<int>& a, int i, int len)
	{
		int temp, j;
		temp = a[i];//先取出当前元素i
		//从i结点的左子结点开始，也就是2i+1处开始
		for (j = 2 * i + 1; j < len; j = 2 * j + 1)
		{
			if (j + 1 < len && a[j] > a[j + 1]) //如果左子结点大于右子结点，j指向右子结点
				j++;
			if (a[j] < temp) //如果子节点小于父节点，将子节点值赋给父节点（不用进行交换）
			{
				a[i] = a[j];
				i = j;
			}
			else
			{
				break;
			}
		}
		a[i] = temp;//将temp值放到最终的位置
	}
	```

堆排序的时间复杂度和稳定性
堆排序时间复杂度
堆排序的时间复杂度是O(N*lgN)。
假设被排序的数列中有N个数。遍历一趟的时间复杂度是O(N)，需要遍历多少次呢？
堆排序是采用的二叉堆进行排序的，二叉堆就是一棵二叉树，它需要遍历的次数就是二叉树的深度，而根据完全二叉树的定义，它的深度至少是lg(N+1)。最多是多少呢？由于二叉堆是完全二叉树，因此，它的深度最多也不会超过lg(2N)。因此，遍历一趟的时间复杂度是O(N)，而遍历次数介于lg(N+1)和lg(2N)之间；因此得出它的时间复杂度是O(N*lgN)。

堆排序稳定性
堆排序是不稳定的算法，它不满足稳定算法的定义。它在交换数据的时候，是比较父结点和子节点之间的数据，所以，即便是存在两个数值相等的兄弟节点，它们的相对顺序在排序也可能发生变化。
算法稳定性 -- 假设在数列中存在a[i]=a[j]，若在排序之前，a[i]在a[j]前面；并且排序之后，a[i]仍然在a[j]前面。则这个排序算法是稳定的！




内容来自于博客：
转载请注明出处：http://www.cnblogs.com/skywang12345/p/3602162.html