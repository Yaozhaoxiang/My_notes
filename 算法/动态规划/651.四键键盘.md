# 题目
假设你有一个特殊的键盘包含下面的按键：
·A:在屏幕上打印一个'A.
·C-A:选中整个屏幕。
·C-C:复制选中区域到媛冲区。
·C-V:将缓冲区内客输出到上次输入的结束位置，井显示在屏幕上。
现在，你可以最多按键n次（使用上述四种按键，返回屏慕上最多可以显示'A”的个数。怎么写？

# 解

我们定义一个数组 dp，其中 dp[i] 表示按键 i 次后屏幕上最多能显示的 'A' 的数量。我们的目标是计算出 dp[n] 的值。

1. 初始状态：我们首先知道，若只用前 i 次按键用于连续按 "A" 键，则可以直接得到 dp[i] = i
2. 转移状态：对于大于某一值的 i，我们可以考虑使用 Ctrl-A、Ctrl-C 和 Ctrl-V 的组合操作。这些操作的关键在于找到合适的时机来复制并粘贴最大化 A 的数量。
  如果我们选择在 i 次按键中进行一次 Ctrl-A、Ctrl-C 和若干次 Ctrl-V，我们可以将某一个之前的结果进行多次粘贴。这时，可以用公式：
  `dp[i] = max(dp[i], dp[j] * (i - j + 1))`
  其中 j 表示选择进行 Ctrl-A 和 Ctrl-C 的时刻，而 i - j + 1 表示进行 Ctrl-V 的次数。

```cpp
#include <vector>
#include <algorithm>

int maxA(int n) {
    // 初始化 dp 数组，长度为 n+1，因为我们需要计算 dp[0] 到 dp[n]
    std::vector<int> dp(n + 1, 0);

    // 填充 dp 数组
    for (int i = 1; i <= n; ++i) {
        // 最基本的情况是按下 'A' 键
        dp[i] = dp[i - 1] + 1;
        
        // 尝试在第 j 次按键后进行 Ctrl-A, Ctrl-C, 和若干次 Ctrl-V
        for (int j = 2; j < i; ++j) {
            dp[i] = std::max(dp[i], dp[j - 2] * (i - j + 1));
        }
    }

    // 返回 dp[n]
    return dp[n];
}
```

查找最佳方案：接下来，我们对于每一个 i，尝试所有可能的在 j 时刻进行复制和粘贴的操作。我们计算 dp[j - 2] * (i - j + 1)，并更新最大值。

可能会有一个疑问，这样是不是只有一次 ca?
  其实不是，之前的 dp[0~i-1] 是已经求出来的，其中可能已经包含多个 ca了，而第二次 for，只是在此基础上 再尝试找一处ca，使得 dp[i]最大。



