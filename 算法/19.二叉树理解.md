参考：labuladong的算法笔记

**综上，遇到一道二叉树的题目时的通用思考过程是：**

1、是否可以通过遍历一遍二叉树得到答案？如果可以，用一个 traverse 函数配合外部变量来实现。

2、是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值。

3、无论使用哪一种思维模式，你都要明白二叉树的每一个节点需要做什么，需要在什么时候（前中后序）做。





二叉树的模式分为两类：

+ 1、是否可以通过遍历一遍二叉树得到答案？如果可以，用一个 traverse 函数配合外部变量来实现，这叫「遍历」的思维模式。

+ 2、是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值，这叫「分解问题」的思维模式。

无论使用哪种思维模式，你都需要思考：
 + 如果单独抽出一个二叉树节点，它需要做什么事情？需要在什么时候（前/中/后序位置）做？其他的节点不用你操心，递归函数会帮你在所有节点上执行相同的操作。

递归框架：
```cpp
void traverse(TreeNode* root) {
    if (root == nullptr) {
        return;
    }
    // 前序位置
    traverse(root->left);
    // 中序位置
    traverse(root->right);
    // 后序位置
}
```
单看 traverse 函数，其实它就是一个能够遍历二叉树所有节点的一个函数；


**前中后序是遍历二叉树过程中处理每一个节点的三个特殊时间点**

  前序位置的代码在刚刚进入一个二叉树节点的时候执行；

  后序位置的代码在将要离开一个二叉树节点的时候执行；

  中序位置的代码在一个二叉树节点左子树都遍历完，即将开始遍历右子树的时候执行。

画成图，前中后序三个位置在二叉树上是这样：

![](./图片/二叉树前中后时间节点.jpeg)

可以发现每个节点都有「唯一」属于自己的前中后序位置，所以说前中后序遍历是遍历二叉树过程中处理每一个节点的三个特殊时间点。


为什么多叉树没有中序位置？
>我们知道中序·遍历是发生在从左节点到右节点的过程，因为二叉树的每个节点只会进行唯一一次左子树切换右子树，而多叉树节点可能有很多子节点，会多次切换子树去遍历，所以多叉树节点没有「唯一」的中序遍历位置。


二叉树的所有问题，就是让你在前中后序位置注入巧妙的代码逻辑，去达到自己的目的，你只需要单独思考每一个节点应该做什么，其他的不用你管，抛给二叉树遍历框架，递归会在所有节点上做相同的操作。


## 两种解题思路
二叉树题目的递归解法可以分两类思路，第一类是**遍历一遍二叉树**得出答案，第二类是通过**分解问题计算出答案**，这两类思路分别对应着 回溯算法核心框架 和 动态规划核心框架。

>二叉树中用遍历思路解题时函数签名一般是 void traverse(...)，没有返回值，靠更新外部变量来计算结果，而用分解问题思路解题时函数名根据该函数具体功能而定，而且一般会有返回值，返回值是子问题的计算结果。

比如说：
```cpp
class Solution {
public:
    // 记录最大深度
    int res = 0;
    // 记录遍历到的节点的深度
    int depth = 0;

    // 主函数
    int maxDepth(TreeNode* root) {
        traverse(root);
        return res;
    }

    // 二叉树遍历框架
    void traverse(TreeNode* root) {
        if (root == nullptr) {
            return;
        }
        // 前序位置
        depth++;
        if (root->left == nullptr && root->right == nullptr) {
            // 到达叶子节点，更新最大深度
            res = std::max(res, depth);
        }
        traverse(root->left);
        traverse(root->right);
        // 后序位置
        depth--;
    }
};
```

```cpp
class Solution {
public:
    // 定义：输入根节点，返回这棵二叉树的最大深度
    int maxDepth(TreeNode* root) {
        if (root == nullptr) {
            return 0;
        }
        // 利用定义，计算左右子树的最大深度
        int leftMax = maxDepth(root->left);
        int rightMax = maxDepth(root->right);
        // 整棵树的最大深度等于左右子树的最大深度取最大值，
        // 然后再加上根节点自己
        int res = std::max(leftMax, rightMax) + 1;

        return res;
    }
};
```


综上，遇到一道二叉树的题目时的通用思考过程是：

1、是否可以通过遍历一遍二叉树得到答案？如果可以，用一个 traverse 函数配合外部变量来实现。

2、是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值。

3、无论使用哪一种思维模式，你都要明白二叉树的每一个节点需要做什么，需要在什么时候（前中后序）做。


## 后序位置的特殊之处

>前序位置的代码只能从函数参数中获取父节点传递来的数据。
>中序位置的代码不仅可以获取参数数据，还可以获取到左子树通过函数返回值传递回来的数据。
>后序位置的代码最强，不仅可以获取参数数据，还可以同时获取到左右子树通过函数返回值传递回来的数据。
>所以，某些情况下把代码移到后序位置效率最高；有些事情，只有后序位置的代码能做。


1、如果把根节点看做第 1 层，如何打印出每一个节点所在的层数？

2、如何打印出每个节点的左右子树各有多少节点？

```cpp
// 二叉树遍历函数
void traverse(TreeNode* root, int level) {
    if (root == nullptr) {
        return;
    }
    // 前序位置
    printf("Node %d at level %d", root->val, level);
    traverse(root->left, level + 1);
    traverse(root->right, level + 1);
}

// 这样调用
traverse(root, 1);
```

```cpp
// 定义：输入一棵二叉树，返回这棵二叉树的节点总数
int count(TreeNode* root) {
    if (root == nullptr) {
        return 0;
    }
    int leftCount = count(root->left);
    int rightCount = count(root->right);
    // 后序位置
    printf("节点 %p 的左子树有 %d 个节点，右子树有 %d 个节点",
            root, leftCount, rightCount);

    return leftCount + rightCount + 1;
}
```

一个节点在第几层，你从根节点遍历过来的过程就能顺带记录，用递归函数的参数就能传递下去；而以一个节点为根的整棵子树有多少个节点，你必须遍历完子树之后才能数清楚，然后通过递归函数的返回值拿到答案。

结合这两个简单的问题，你品味一下后序位置的特点，只有后序位置才能通过返回值获取子树的信息。

那么换句话说，一旦你发现题目和子树有关，那大概率要给函数设置合理的定义和返回值，在后序位置写代码了。

## 以树的视角看动归/回溯/DFS算法的区别和联系

动归/DFS/回溯算法都可以看做二叉树问题的扩展，只是它们的关注点不同：

+ 动态规划算法属于分解问题（分治）的思路，它的关注点在整棵「子树」。
+ 回溯算法属于遍历的思路，它的关注点在节点间的「树枝」。
+ DFS 算法属于遍历的思路，它的关注点在单个「节点」。


















