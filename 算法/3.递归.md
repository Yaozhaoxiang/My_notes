## 23 递归

递归三大要素(切记深入想递归过程，利用整体思路)

1. 明确这个函数要干什么
对于递归，我觉得很重要的一个事就是，这个函数的功能是什么，他要完成什么样的一件事，而这个，是完全由你自己来定义的。也就是说，我们先不管函数里面的代码什么，而是要先明白，你这个函数是要用来干什么。

例如，我定义了一个函数
```cpp
// 算 n 的阶乘(假设n不为0)
int f(int n){

}
```
这个函数的功能是算 n 的阶乘。好了，我们已经定义了一个函数，并且定义了它的功能是什么，接下来我们看第二要素。

2. 寻找递归结束条件
所谓递归，就是会在函数内部代码中，`调用这个函数本身`，所以，我们必须要找出递归的结束条件，不然的话，会一直调用自己，进入无底洞。也就是说，我们需要`找出当参数为啥时`，递归结束，之后直接把结果返回，请注意，这个时候我们必须能根据这个参数的值，能够直接知道函数的结果是什么。

例如，上面那个例子，当 n = 1 时，那你应该能够直接知道 f(n) 是啥吧？此时，f(1) = 1。完善我们函数内部的代码，把第二要素加进代码里面，如下

```cpp
// 算 n 的阶乘(假设n不为0)
int f(int n){
    if(n == 1){
        return 1;
    }
}
```

3. 找出函数的等价关系式
第三要素就是，我们要不断`缩小参数的范围`，缩小之后，我们可以通过一些辅助的变量或者操作，使原函数的结果不变。

例如，f(n) 这个范围比较大，我们可以让 f(n) = n * f(n-1)。这样，范围就由 n 变成了 n-1 了，范围变小了，并且为了原函数f(n) 不变，我们需要让 f(n-1) 乘以 n。

说白了，就是要找到原函数的一个等价关系式，f(n) 的等价关系式为 n * f(n-1)，即
f(n) = n * f(n-1)。

找出了这个等价，继续完善我们的代码，我们把这个等价式写进函数里。如下：
```CPP
// 算 n 的阶乘(假设n不为0)
int f(int n){
    if(n <= 2){
        return n;
    }
    // 把 f(n) 的等价操作写进去
    return f(n-1) * n;
}
```




也就是假设该函数可以完成功能，还差最后一步改怎么执行；
再举一个例子：

>反转单链表。例如链表为：1->2->3->4。反转后为 4->3->2->1

链表的节点定义如下：
```cpp
class Node{
    int date;
   Node next;
}
```

第一步：定义递归函数功能
假设 reverseList(head)的功能是反转单链表，其中head表示链表的头节点
```cpp
Node reverseList(Node head){

}
```
第二步：寻找结束条件
当链表只有一个节点，或者如果是空表的话。直接啥也不用干，直接把 head 返回呗
```cpp
Node reverseList(Node head){
   if(head == null || head.next == null){
       return head;
   }
}
```
第三步：寻找等价关系
假如，输入单链表：1->2->3->4
假设该递归函数能完成功能；
已经反转了2->3->4 --》》4->3->2;
这时候，应该反转1和2了
```cpp
Node reverseList(Node head){
   if(head == null || head.next == null){
       return head;
   }
   Node newList=reverseList(head->next);//假设可以完成head->next后面的反转，这时候就只剩下1和next了
    Node t1= head.next;
    t1.next=head;//2节点指向1节点
    head.next=null;//1节点指向空，不要深入考虑细节
    return newList;
}
```







