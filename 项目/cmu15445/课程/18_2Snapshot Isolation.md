https://zhuanlan.zhihu.com/p/579519381

在数据库和事务处理（事务管理）中，**快照隔离**保证在事务中进行的所有读取都将看到数据库的一致快照（实际上，它读取启动时存在的最后提交的值），并且只有当事务本身所做的更新与自该快照以来所做的任何并发更新没有冲突时，事务本身才会成功提交。

从这个定义上来看，snapshot isolation 就是为每个事务的读准备一个系统的快照（snapshot），这个快照一旦建立就不会再被修改，从而达到了 isolation 的作用。但在事务提交时，如果系统当前状态与它的读快照不符了，这就是经典的 read-modify-write 的冲突，事务本身就要 abort。

我们可以将这句话拆成几部分：
+ 生成一个快照
+ 修改系统的状态
+ 冲突检测

## 不用 MVCC 可以实现 snapshot isolation 吗

常见的系统都是用 MVCC 来实现 snapshot isolation 的。我们来探讨一下其它方法为什么不行。

### 原地修改
对于原地修改的系统，一个新的修改会破坏一个已有的 snapshot。这样为了不破坏当前事务的运行，我们就只能阻止其它可能冲突的事务运行。

方法大家肯定都会，加锁呗。暴力点的就所有事务串行执行，温柔点的就把锁的粒度变小，把相互冲突的事务给串行化，不冲突的放行。

但通常我们管这个叫 serializable，不叫 snapshot isolation。

### copy-modify-write
如果将系统的状态复制出来，之后本地修改，最后再应用回系统，我们至少保证了事务的执行阶段是相互独立的，不影响并发度。

比如对于一个 LSM store，只要将 MemTable 和 Manifest 完整复制下来，就生成了一个显然正确的快照。说得好，但有点不好的地方：

1. 数据量大的时候复制成本过高。
2. 为了保证系统状态一致，复制阶段需要避免有人修改系统状态，通常这意味着加锁。于是系统的并发又上不去了。地球不欢迎这样的 snapshot isolation。

我们可以想办法降低复制的粒度，降到刚好是事务可能访问的数据集。但还是有些小问题：
> 交互式事务不那么容易获得准确的数据集。
> 大事务的复制成本依然非常高。
> 依然意味着要加锁（取决于数据集大小）。

另一个方向是降低复制的开销。比如对于上面的 LSM store，我们知道所有 SST file 是 immutable 的，持有 Manifest 就意味着一个不变的 view。而持有 Manifest 的开销是非常低的：只需要复制每个 SST 的 shared_ptr 之类的东西。这样复制开销主要就是复制 MemTable 了。如果我们将 MemTable 实现为 immutable 结构，就可以以非常低的开销复制出来一个 MemTable。

copy-modify-write 接下来会遇到的问题是，如何检测冲突？
 + 逐一对比 snapshot 中的每个值，一方面开销大，另一方面还会有 ABA 问题：我们怎么区分一个值没变和被修改多次最后回到了初始值呢？
 + 分布式系统中检测本身会发生在多个节点上，为了避免一个节点检测通过之后又有新的写入破坏 snapshot，我们还是要回到加锁上来。

上面第一个问题，如果不能直接检测值本身的变化，一个很自然的想法就是记录一个版本号来保留修改的痕迹。于是我们得到了 MVCC。

## MVCC
实际上，snapshot isolation 暗含了 happen-before 关系，也就是 time。那很自然的想法就是把 time 保存到系统状态中，也就是 MVCC。

我们保证系统中的每次状态修改都附带 timestamp，则 timestamp 本身就意味着一个 snapshot。

timestamp 从哪来?










