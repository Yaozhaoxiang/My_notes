

## 1 实现了基于LRU-K的缓冲池
缓冲池负责将物理页面在主内存和磁盘之间来回移动，缓冲池采用LRU-K算法淘汰数据页，使用RAII封装数据页的读写接口。实现磁盘调度器组件，维护一个后台线程实现磁盘与缓冲池之间的数据读写。

首先第一部分：为数据库管理构建一个面向磁盘的存储管理器，也就是实现一个缓冲池，它的作用就是将物理页面在内存和磁盘之间来回切换。这样就会使得数据库管理系统能够支持比系统可用内存更大的数据库。缓冲池的操作对其他部分是透明的。例如，系统通过一个唯一的 page_id向缓冲池请求页面，而无需知道该页面是否已经在内存中，或者系统是否需要从磁盘检索它。

主要实现以下存储管理器组件：

+ LRU-K 替换策略
+ 磁盘调度程序
+ 缓冲池管理器

### 1. LRU-K 替换策略
该组件负责跟踪缓冲池中的页面使用情况。当我们需要从缓冲池中替换一个页面的时候，通过LRU-K来选择删除的页面。

为什么使用LRU-K
普通的LRU，也就是LRU-1是删除未使用页面最久的哪个页面，但是这是不合理的，因为这回忽略页面的访问频率，容易受到顺序扫描，比如说一个页面是使用了50次了，这个时候我们需要遍历一个数据，但是这个数据很大，当遍历的时候，我们就可能替换掉这个曾经经常访问的数据，这是不合理的。所以才使用LRU-K这个替换策略。

LRU-K原理
跟踪每个页面最后K次引用的历史作为时间戳，并计算连续访问之间的间隔。这个距离怎么算的呢？当前时间戳与第 k 次之前访问的时间戳之间的差；对于历史访问少于 k 次的帧，其向后 k 距离为 +inf。当多个帧的向后 k 距离为 +inf 时，替换器将驱逐整体时间戳最早的帧（即记录访问时间最久的帧）。

怎么实现的：
因为维护的是帧，所以定义一个 LRUNode，这里面保存一个history数组，它的大小就是k，当访问过一次，就把当前的时间戳从后向前加到这个数组中。也就是说history数组的前面就是第k次访问的时间戳，这个值越小，也就意味着离当前越久，则先删除这个。用两个链表维护，一个是访问次数小于k的，一个大于k；


### 2. 磁盘调度程序
这个组件负责在 DiskManager 上调度读写操作，当上层请求读或者写一个页面时，会生成一个请求对象。调度器维护一个后台工作线程，该线程使用磁盘管理器处理已调度的请求。

盘调度器将利用一个**共享队列**来**调度和处理 DiskRequest**。一个线程将向队列添加请求，而磁盘调度器的后台工作线程将处理排队的请求。


### 3. 缓冲池管理器
缓冲池管理器负责通过 DiskScheduler 从磁盘获取数据库页面并将其存储在内存中。

内存页面是由page对象表示的。这个page是什么呢？
 Page 对象只是缓冲池中内存的容器，因此并不特定于某一唯一页面。也就是说，每个 Page 对象包含一块内存，DiskManager 将使用该内存位置来复制从磁盘读取的物理页面的内容。缓冲池管理器会重用相同的 Page 对象来存储数据，因为它在磁盘与内存之间来回移动。这意味着同一个 Page 对象在系统生命周期内可能包含不同的物理页面。Page 对象的标识符（page_id）用于跟踪其包含的物理页面；如果 Page 对象不包含物理页面，则其 page_id 必须设置为 INVALID_PAGE_ID。


##  实现了基于可扩展哈希表的哈希索引：
支持并发的索引查找和插入操作。


































