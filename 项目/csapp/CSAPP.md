## ***********************************************##
# csapp

## datalab

1. 使用 dlc 编译器（./dlc）自动检查 bits.c 版本是否符合编码准则。使用 -e 参数运行 dlc：

`unix> ./dlc -e bits.c`
可让 dlc 打印每个函数使用的运算符数目。

2. 有了合法解答，就可以使用 ./btest 程序测试它的正确性。

`btest.c`是测试代码的工具，编译它（使用终端`make btest`）我们可以获得可执行文件，执行它会对你的代码进行测试，注意每次修改完代码之后都需要重新编译。

btest.c使用make编译btest文件，要编译并运行 btest 程序，请键入：

```Linux
make clean
unix> make btest
unix> ./btest [optional cmd line args]
```
每次更改 bits.c 程序时，都需要重新编译 btest。

测试所有功能的正确性并打印出错误消息：
`unix> ./btest`

以紧凑的形式测试所有函数，不含错误消息：
`unix> ./btest -g`

测试函数 foo 的正确性：
`unix> ./btest -f foo`

使用特定参数测试函数 foo 的正确性：
`unix> ./btest -f foo -1 27 -2 0xf`

btest 不会检查你的代码是否符合代码准则，需使用 dlc。

## ***********************************************##

# GCC编辑器
gcc编译程序主要经过四个过程：

1.预处理（Pre-Processing）
2.编译 （Compiling）
3.汇编 （Assembling）
4.链接 （Linking）

![](https://pic4.zhimg.com/80/v2-38aedd85719aa8828ba5ab912b7591b3_720w.webp)

预处理实际上是将头文件、宏进行展开。编译阶段，gcc调用不同语言的编译器，例如c语言调用编译器ccl。gcc实际上是个工具链，在编译程序的过程中调用不同的工具。汇编阶段，gcc调用汇编器进行汇编。链接过程会将程序所需要的目标文件进行链接成可执行文件。汇编器生成的是可重定位的目标文件，学过操作系统，我们知道，在源程序中地址是从0开始的，这是一个相对地址，而程序真正在内存中运行时的地址肯定不是从0开始的，而且在编写源代码的时候也不能知道程序的绝对地址，所以重定位能够将源代码的代码、变量等定位为内存具体地址。下面以一张图来表示这个过程，注意过程中文件的后缀变化，编译选项和这些后缀有关。
这是GCC编译的四个步骤。

来看一下gcc常用选项

![](https://pic4.zhimg.com/80/v2-8bbcf9bd395c31f8cbb75feec08d7b7b_720w.webp)

现在我们有源文件hello.c，下面是一些gcc的使用示例：
```CPP
gcc -E hello.c -o hello.i   对hello.c文件进行预处理，生成了hello.i 文件
gcc -S hello.i -o hello.s    对预处理文件进行编译，生成了汇编文件
gcc -c hello.s -o hello.o  对汇编文件进行编译，生成了目标文件
gcc hello.o -o hello 对目标文件进行链接，生成可执行文件
gcc hello.c -o hello 直接编译链接成可执行目标文件
gcc -c hello.c 或 gcc -c hello.c -o hello.o 编译生成可重定位目标文件
```
要查看机器代码文件的内容，可以用反汇编器，代码如下：
`objdump -d ctarget > ctarget.asm` 文件通常是汇编语言代码的文件扩展名，包含了汇编指令以及对应的注释。这些文件可以由汇编器（如NASM、MASM等）处理，将其转换为可执行文件或目标文件。



# GDB调试器
1. 
```cpp
　　r  运行程序

　　b <*0x某某某>    在某个地址设置断点，具体哪里，可以看反汇编的代码，可以根据那个直接复制粘贴设断点的

　　d 删除所有断点

　　d <断点号>    删除指定断点

　　info b    查看所有断点信息

　　continue 从断点处继续执行

　　display <$寄存器>    跟踪寄存器，碰到断点停下时会显示出所有跟踪的寄存器的当前值，非常好用的一个命令，注意的是gdb中表示寄存器的话前面用的不是百分符号%，而是美元符号$

　　x/参数 <地址>    访问地址的内存，其实就是间接访问，也是很好用的指令，关于参数，s是输出为字符串，d为输出为十进制，x为输出为十六进制，b、w、l、q控制输出字节，默认是w，四字节，s字符串不受这个控制除外。
    info stack 显示当前调用栈（call stack）的详细信息
　　info r    查看所有寄存器的值
　　print (可加强制转换符号)<数字>	跟C语言的基本性质一样的，理解即可
    disas function_name 查看反汇编
```
2. 
在 GDB 中，`x/8xg 0x402470` 指令用于以 8 个 64 位十六进制格式显示从地址 0x402470 开始的内存内容。具体解释如下：
    x 是 GDB 的一个命令，用于检查内存。
    /8 指定显示的内存单元数，这里是 8 个单元。(显示8个数，这8个数根据g定)
    x 表示内存单元的显示格式为十六进制。
    g 指定每个内存单元的大小为 8 字节（64 位）。(w是每4个字节显示)
    0x402470 是要查看的内存起始地址。
3. 
`x/5i $pc`这个命令将显示当前程序计数器（PC）指向的位置开始的五条指令的汇编代码
    x 是 GDB 的一个命令，用于检查内存。
    /5i 指定显示的指令数，这里是五条指令。
    $pc 表示当前程序计数器（PC）指向的地址，即正在执行的指令的地址。
所以x/5i $pc 命令的作用是以汇编代码的形式显示当前执行指令的附近几条指令。

4. layout
layout 是 GDB（GNU 调试器）提供的一个命令，用于在调试会话期间显示源代码和汇编代码的布局。它可以帮助程序员更方便地理解代码的执行过程，以及当前执行点在源代码和汇编代码中的位置。

```cpp
layout src：显示源代码布局，将源代码显示在顶部窗格中。
layout asm：显示汇编代码布局，将当前函数的汇编代码显示在顶部窗格中。
layout split：显示源代码布局和汇编代码布局，分别在顶部和底部窗格中显示。
layout next：切换到下一个布局模式，比如从源代码布局切换到汇编代码布局，或者反之。
layout prev：切换到上一个布局模式。
layout regs：显示寄存器窗格，显示当前寄存器的值。
```

### 进入gdb调试模式命令： `gdb your_executable`,`your_executable` 通常是指可执行文件，也就是经过编译后的程序文件。
在大多数情况下，GDB 用于调试以下类型的文件：
1. 可执行文件（Executable Files）：这是最常见的类型，例如通过 gcc 或 g++ 编译 C 或 C++ 源代码后生成的文件。在 Windows 上，这类文件通常有 .exe 扩展名；在 Unix/Linux 系统上，通常没有特定扩展名。
2. 共享库文件（Shared Libraries）：也可以用 GDB 调试动态链接库，例如 .so 文件（在 Unix/Linux 系统上）或 .dll 文件（在 Windows 上）。
要确保 GDB 能有效调试你的程序，最好在编译时包含调试信息。这通常通过添加 `-g` 选项来完成。例如：
`gcc -g -o your_executable your_source.c`


### GDB 调试常用命令
启动 GDB：`gdb your_executable`(终端运行)
运行程序：`run`
设置断点：
`break main `      # 在主函数处设置断点
`break filename:line_number`  # 在特定文件的特定行设置断点
单步执行：
`step`  # 单步执行，进入函数内部
`next`  # 单步执行，跳过函数调用
继续执行：`continue`
查看变量：`print variable_name`
查看调用栈：`backtrace`
退出 GDB：`quit`



## ***********************************************##
#   课本

2.1.3 寻址和字节顺序
    多字节对象被存储为来纳许的字节序列，对象的地中为所使用字节中最小的地址；
    大端法：最高有效字节在最前面；也就是说高位字节在首地址，比如0x0123,01在地址0x100，而23则在地址0x101；
    小端法：最底有效字节在最前面；也就是说低位字节在首地址，比如0x0123,23在地址0x100，而01则在地址0x101；
    
2.1.7 c语言的位级运算 
    |,&,~,^;或，与，取反，异或。（注意这些都是对每一位二进制操作）；
2.1.8 c语言的逻辑运算符    
    ||，&&，！；逻辑运算符认为所有非零的参数都表示true，而参数0表示false；他们返回0和1；
    所以说，按位运算只有在特殊情况中，也就是参数被限制为0或者1时，才与对应的逻辑运算有相同的行为；
    逻辑运算符&&和||与他们对应的位运算符|，|之间的第二个重要的的区别时。如果对第一个参数求值就能确定表达式的结果，那忙逻辑运算符就不会对第二个参数求值。例如，a&&5/a讲不会造成被零除，而表达式p&&*p++也不会导致简介引用空指针；
2.2.2 无符号数编码
    即一个w位的向量，看成二进制表示，求的值就是无符号数。也就是每一位看成二进制。进而1+2+4+....；用B2U.
2.2.3 补码编码
    因为无符号数编码的只能是正数，但是有时候我们需要负数值，而最常见的有符号数的表示方式就是补码形式。补码定义：将最高位解释位负权（B2T），也就是最高一位表示负值，所以加的时候，最后一项是-2^n
    用来表示有符号整数；
2.2.4 有符号数和无符号数之间的转换
    数值可能回改变，但是位模式不变；

2.2.5在C语言中，int类型的负值在计算机内部是使用补码来表示的。这是因为补码可以简化二进制的加减运算，特别是涉及到负数的情况。补码的计算方法是将负数的原码除符号位外各位取反，然后在最后一位加1。例如，如果我们有一个int类型的负数-5，它的表示过程如下：
    5的原码是00000000 00000000 00000000 00000101。
    -5的原码是在5的原码基础上最高位（符号位）变为1，即10000000 00000000 00000000 00000101。
    -5的反码是除符号位外其他位取反，即11111111 11111111 11111111 11111010。
    -5的补码是反码基础上最后一位加1，即11111111 11111111 11111111 11111011。
    因此，当你在C语言中处理int类型的负数时，它们在内存中是以补码的形式存储的。这样做的好处是可以将减法运算转换为加法运算，简化了计算机的硬件设计1。

    当指向一个运算时，如果它一个运算数是有符号的而另一个是无符号的，那么c语言会隐式的讲有符号参数强制类型转换为无符号的，并假设这两个数都是无符号的。

## 第三章
    gcc的全称是GNU Compiler Collection，它是一个能够编译多种语言的·编译器·。最开始gcc是作为C语言的编译器（GNU C Compiler），现在除了c语言，还支持C++、java、Pascal等语言。gcc支持多种硬件平台。
    GUN环境包括GCC编辑器、GDB调试器、汇编器、链接器、处理二进制文件的工具以及其他一些部件。

    **格式的注解**GCC产生的汇编代码，所有以‘.’开头的行都是汇编器和链接器的伪指令。通常可以忽略这些行。
**寄存器和内存的区别**
1. 寄存器：寄存器是位于CPU内部的存储单元，用于临时存储数据和执行指令。寄存器的访问速度非常快，因为它们位于CPU内部，可以直接被CPU访问。每个CPU架构都有一组固定数量的寄存器，用于不同的用途，例如存储临时数据、指针等。通常，寄存器的命名以字母（如eax, ebx, ecx等）或数字（如r0, r1, r2等）表示
2. 内存：内存是位于计算机系统内部的主要存储设备，用于存储程序和数据。内存的访问速度相对较慢，因为它们位于CPU之外，需要通过总线进行访问。内存由一组连续的地址单元组成，每个地址单元可以存储一个或多个字节的数据。内存的访问通常需要指定地址（如0x1234）或者通过寄存器间接访问。

**操作数指示符**
1. 立即数：用来表示常数值，立即数的书写方式是'$'后面跟一个用标准c表示的整数；
2. 寄存器：表示某个寄存器的内容
3. 内存引用：根据计算出来的地址访问某个内存位置。因为将内存看成一个很大的字节数组
c语言中的指针其实就是指针，间接引用指针就是将该指针放在一个寄存器中，然后在内存引用中使用这个寄存器。其次，局部变量通常保存在寄存器中，而不是内存中。

**`%rsp` 和 `(%rsp)` 有着不同的含义和用途**
1. `%rsp`
这是一个寄存器名，表示的是堆栈指针寄存器（Stack Pointer Register）。它存储了当前栈顶的内存地址。
直接使用 %rsp 表示对寄存器的值进行操作。例如，mov %rsp, %rax 会将堆栈指针寄存器的值复制到 rax 寄存器。
2. `(%rsp)`
这是一种间接寻址模式，表示访问 %rsp 寄存器所指向的内存地址处的值。
使用 (%rsp) 表示对栈顶地址处的内存单元进行操作。例如，mov (%rsp), %rax 会将栈顶地址处的值复制到 rax 寄存器。

示例
假设 `%rsp` 的值是 `0x7fffffffeff0`，且该地址处的内存内容是 `0x12345678`：
`mov %rsp, %rax`
将 `0x7fffffffeff0`（%rsp的值）复制到 `rax` 寄存器。
`mov (%rsp), %rax`
将 `0x12345678`（%rsp指向的内存地址处的值）复制到 `rax` 寄存器。
```cpp
mov $0x7fffffffeff0, %rsp  ; 假设堆栈指针寄存器的值为0x7fffffffeff0
mov $0x12345678, (%rsp)    ; 将0x12345678存储到%rsp指向的内存地址处

mov %rsp, %rax             ; %rax 现在为 0x7fffffffeff0
mov (%rsp), %rax           ; %rax 现在为 0x12345678

```
指令 `movq $1, 24(%rsp)`的作用是将常数 1 存储到 %rsp 寄存器加上 24 偏移量所指向的内存地址中。以下是这条指令的具体含义和作用：
假设 %rsp 寄存器当前的值是 0x7fffffffeff0，则 24(%rsp) 表示的内存地址是 0x7fffffffeff0 + 24 = 0x7fffffffeff0 + 0x18 = 0x7fffffffeff8。
movq $1, 24(%rsp)  ; 将64位的值1存储到地址(%rsp + 24)处






