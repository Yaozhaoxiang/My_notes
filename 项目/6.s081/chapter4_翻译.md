### 第4章 中断和系统调用

有三种事件会导致 CPU 暂停普通指令的执行并强制控制权转移到处理该事件的特殊代码。一种情况是**系统调用**，即用户程序执行 `ecall` 指令请求内核为其做某事。另一种情况是**异常**：指令（无论是用户还是内核）做了非法的事情，比如除以零或使用无效的虚拟地址。第三种情况是**设备中断**，即设备发出信号表示需要关注，例如磁盘硬件完成读写请求。

本书使用“中断”作为这些情况的通用术语。通常，无论何时发生中断，**之后需要恢复执行中断前的代码**，而且不应该让其意识到发生了特殊情况。也就是说，我们经常希望中断是透明的；对于设备中断来说尤其如此，因为被中断的代码通常不会预期到这种情况。典型的**序列**是：中断迫使控制权转移到内核；内核保存寄存器和其他状态以便恢复执行；内核执行适当的处理代码（例如系统调用实现或设备驱动程序）；内核恢复保存的状态并从中断返回；原始代码从中断点继续执行。

Xv6 在内核中处理所有中断；中断不会传递给用户代码。在内核中处理中断对于系统调用是自然的。对于中断也是合理的，因为隔离性要求只有内核才能使用设备，而且内核是共享设备给多个进程的方便机制。对于异常也是如此合理，因为 Xv6 对所有来自用户空间的异常都通过终止出错程序来响应。

Xv6 的中断处理分为四个阶段：RISC-V CPU 执行的硬件动作、准备内核 C 代码的汇编指令、决定如何处理中断的 C 函数以及系统调用或设备驱动程序的服务例程。尽管三种中断类型之间的共通之处暗示内核可以用单一代码路径处理所有中断，但事实证明，为三种不同情况（来自用户空间的中断、来自内核空间的中断和定时器中断）分别编写代码更加方便。处理中断的内核代码（汇编或 C 代码）通常称为处理器；最初的处理器指令通常用汇编语言编写（而不是 C 语言），有时也称为向量。

#### 4.1 RISC-V 中断机制

每个 RISC-V CPU 都有一组**控制寄存器**，内核可以写入这些寄存器来告诉 CPU 如何处理中断，也可以读取这些寄存器来了解已发生的中断。完整的细节可以在 RISC-V 文档中找到 [1]。`riscv.h`（`kernel/riscv.h:1`）包含了 Xv6 使用的定义。以下是**最重要的寄存器**概述：

- `stvec`：内核在此处写入中断处理程序的地址；RISC-V 跳转到 `stvec` 中的地址来处理中断。
- `sepc`：当中断发生时，RISC-V 将**程序计数器保存在这里**（因为随后程序计数器会被 `stvec` 中的值覆盖）。`sret`（从中断返回）指令将 `sepc` 复制到程序计数器。内核可以通过写入 `sepc` 来控制 `sret` 返回的位置。
- `scause`：RISC-V 在这里放置一个数字，描述**中断的原因**。
- `sscratch`：内核在此处放置一个值，该值在中断处理程序的非常早期阶段很有用。
- `sstatus`：`sstatus` 中的 SIE 位控制是否启用设备中断。如果内核清除 SIE，RISC-V 将推迟设备中断直到内核设置 SIE。SPP 位指示中断来自用户模式还是超级用户模式，并控制 `sret` 返回到哪个模式。

上述寄存器与在超级用户模式下处理的中断相关，不能在用户模式下读取或写入。对于在机器模式下处理的中断，还有一组类似的控制寄存器；Xv6 仅在处理定时器中断的特殊情况下使用它们。多核芯片上的每个 CPU 都有自己的这一组寄存器，而且在任何给定时间可以有多个 CPU 处理中断。当中断需要被强制发生时，RISC-V 硬件会对所有类型的中断（除了定时器中断）执行以下操作：
1. 如果中断是一个设备中断，且 `sstatus` 中的 SIE 位被清除，则不执行以下任何操作。
2. 通过清除 `sstatus` 中的 SIE 位来禁用中断。
3. 将程序计数器复制到 `sepc`。
4. 将当前模式（用户模式或超级用户模式）保存在 `sstatus` 的 SPP 位中。
5. 设置 `scause` 以反映中断的原因。
6. 将模式设置为超级用户模式。
7. 将 `stvec` 复制到程序计数器。
8. 从新的程序计数器地址开始执行。

请注意，CPU 不会切换到内核页表，不会切换到内核中的栈，也不会保存除程序计数器以外的任何寄存器。这些任务必须由内核软件完成。CPU 在中断期间执行最少的工作是为了给软件提供灵活性；例如，有些操作系统在某些情况下省略页表切换以提高中断性能。

值得思考的是，上述步骤中是否有任何可以省略的，也许是为了追求更快的中断。尽管在某些情况下简单的序列可以工作，但许多步骤在一般情况下省略将是危险的。例如，假设 CPU 不切换程序计数器。那么，来自用户空间的中断可以在仍然执行用户指令的情况下切换到超级用户模式。这些用户指令可能会破坏用户/内核隔离，例如通过修改指向允许访问所有物理内存的页表的 `satp` 寄存器。因此，CPU 切换到内核指定的指令地址，即 `stvec`，这一点非常重要。



#### 4.2 用户空间中断

Xv6 根据是在内核中还是在用户代码中执行而不同地处理中断。以下是用户代码中断的故事；第 4.5 节描述了内核代码中断。

当中断发生在用户空间执行时，可能是用户程序执行了系统调用（`ecall` 指令）、做了非法操作，或者设备中断。用户空间中断的高级路径是 `uservec`（`kernel/trampoline.S:16`），然后是 `usertrap`（`kernel/trap.c:37`）；当返回时，是 `usertrapret`（`kernel/trap.c:90`），然后是 `userret`（`kernel/trampoline.S:88`）。

Xv6 中断处理设计的一个主要约束是 RISC-V 硬件在强制中断时不切换页表。这意味着 `stvec` 中的中断处理程序地址必须在用户页表中有有效的映射，因为中断处理代码开始执行时生效的就是这个页表。此外，Xv6 的中断处理代码需要切换到内核页表；为了在切换后能够继续执行，内核页表也必须有 `stvec` 指向的处理程序的映射。

Xv6 通过使用 trampoline  跳板页来满足这些要求。跳板页包含 `uservec`，即 `stvec` 指向的 Xv6 中断处理代码。跳板页在每个进程的页表中都映射到地址 `TRAMPOLINE`，该地址位于虚拟地址空间的末尾，以便高于程序为自己使用的内存。跳板页也在内核页表中映射到地址 `TRAMPOLINE`。参见图 2.3 和图 3.3。因为跳板页在用户页表中映射，并带有 `PTE_U` 标志，所以中断可以在超级用户模式下从那里开始执行。因为**跳板页在同一地址映射到内核地址空间**，所以中断处理程序可以在切换到内核页表后继续执行。

`uservec` 中断处理程序的代码在 `trampoline.S`（`kernel/trampoline.S:16`）中。当 `uservec` 开始时，所有 32 个寄存器都包含被中断的用户代码拥有的值。这 32 个值需要保存在内存中的某个地方，以便在中断返回用户空间时可以恢复。将数据存储到内存需要使用寄存器来保存地址，但在这一点上没有任何通用寄存器可用！幸运的是，RISC-V 提供了 `sscratch` 寄存器的帮助。`uservec` 开始处的 `csrrw` 指令交换了 `a0` 和 `sscratch` 的内容。现在用户的 `a0` 值保存在 `sscratch` 中；`uservec` 有一个寄存器（`a0`）可以使用；并且 `a0` 包含内核先前放在 `sscratch` 中的值。

`uservec` 的下一个任务是保存 32 个用户寄存器。在进入用户空间之前，内核将 `sscratch` 设置为指向每个进程的陷阱帧结构，该结构（除其他外）有空间保存 32 个用户寄存器（`kernel/proc.h:44`）。因为 `satp` 仍然指向用户页表，所以 `uservec` 需要陷阱帧在用户地址空间中映射。在创建每个进程时，Xv6 分配一个页面用于进程的陷阱帧，并安排其始终映射到用户虚拟地址 `TRAPFRAME`，该地址紧挨着 `TRAMPOLINE` 下方。进程的 `p->trapframe` 也指向陷阱帧，不过是指向其物理地址，这样内核可以通过内核页表使用它。

因此，在交换 `a0` 和 `sscratch` 之后，`a0` 持有当前进程的陷阱帧的指针。`uservec` 现在在那里保存所有用户寄存器，包括从 `sscratch` 读取的用户的 `a0`。陷阱帧包含当前进程的内核栈地址、当前 CPU 的 `hartid`、用户陷阱函数的地址和内核页表的地址。`uservec` 获取这些值，切换 `satp` 到内核页表，并调用 `usertrap`。`usertrap` 的任务是确定中断的原因，处理它并返回（`kernel/trap.c:37`）。

它首先改变 `stvec`，使得在内核中的中断将由 `kernelvec` 而不是 `uservec` 处理。它保存 `sepc` 寄存器（保存的用户程序计数器），因为 `usertrap` 可能会调用 `yield` 切换到另一个进程的内核线程，而那个进程可能会返回用户空间，在此过程中会修改 `sepc`。


### 4.3 代码：调用系统调用

如果中断是一个系统调用，`usertrap` 会调用 `syscall` 来处理它；如果是设备中断，会调用 `devintr`；否则，这是一个异常，内核会杀死出错的进程。

系统调用路径会在保存的用户程序计数器上加 4，因为在系统调用的情况下，RISC-V 会将程序指针留在 `ecall` 指令上，但用户代码需要从后续指令开始执行。

在返回过程中，`usertrap` 会检查进程是否已被杀死或应该让出 CPU（如果这次中断是定时器中断）。

返回用户空间的第一步是调用 `usertrapret`（`kernel/trap.c:90`）。这个函数设置 RISC-V 控制寄存器，为未来的用户空间中断做准备。这包括将 `stvec` 改为指向 `uservec`，准备 `uservec` 依赖的陷阱帧字段，并将 `sepc` 设置为之前保存的用户程序计数器。最后，`usertrapret` 调用映射在用户和内核页表中的跳板页上的 `userret`；原因是 `userret` 中的汇编代码会切换页表。`usertrapret` 调用 `userret` 时传递 `TRAPFRAME` 在 `a0` 中和指向进程用户页表的指针在 `a1` 中（`kernel/trampoline.S:88`）。`userret` 将 `satp` 切换到进程的用户页表。

回想一下，用户页表映射了跳板页和 `TRAPFRAME`，但不映射内核的其他部分。跳板页在用户和内核页表中映射到相同的虚拟地址，这就是为什么 `uservec` 在更改 `satp` 后可以继续执行的原因。`userret` 将陷阱帧中保存的用户 `a0` 复制到 `sscratch`，为稍后与 `TRAPFRAME` 交换做准备。从这一点开始，`userret` 可以使用的唯一数据是寄存器内容和陷阱帧内容。接下来，`userret` 从陷阱帧中恢复保存的用户寄存器，进行最终的 `a0` 和 `sscratch` 交换以恢复用户 `a0` 并保存 `TRAPFRAME` 以备下次中断，然后执行 `sret` 返回用户空间。

### 4.4 代码：系统调用参数

内核中的系统调用实现需要找到用户代码传递的参数。由于用户代码调用系统调用包装函数，参数最初位于 RISC-V C 调用约定指定的位置：寄存器中。

内核陷阱代码将用户寄存器保存到**当前进程的陷阱帧**中，内核代码可以在那里找到它们。内核函数 `argint`、`argaddr` 和 `argfd` 从陷阱帧中检索第 n 个系统调用参数，分别为整数、指针或文件描述符。它们都调用 `argraw` 来检索适当的保存用户寄存器（`kernel/syscall.c:35`）。

一些系统调用传递指针作为参数，内核必须使用这些指针读取或写入用户内存。例如，`exec` 系统调用传递一个指针数组，这些指针引用用户空间中的字符串参数。这些指针带来两个挑战。首先，用户程序可能有 bug 或恶意，可能会传递无效指针或试图诱使内核访问内核内存而不是用户内存的指针。其次，xv6 内核页表映射与用户页表映射不同，因此内核不能使用普通指令从用户提供的地址加载或存储数据。

内核实现了安全传输数据到用户提供的地址和从用户提供的地址传输数据的功能。`fetchstr` 是一个例子（`kernel/syscall.c:25`）。文件系统调用如 `exec` 使用 `fetchstr` 从用户空间检索字符串文件名参数。`fetchstr` 调用 `copyinstr` 来完成这项工作。`copyinstr`（`kernel/vm.c:398`）从用户页表 `pagetable` 中的虚拟地址 `srcva` 复制最多 `max` 字节到 `dst`。由于 `pagetable` 不是当前页表，`copyinstr` 使用 `walkaddr`（调用 `walk`）查找 `srcva` 在 `pagetable` 中的位置，得到物理地址 `pa0`。内核将每个物理 RAM 地址映射到相应的内核虚拟地址，因此 `copyinstr` 可以直接从 `pa0` 复制字符串字节到 `dst`。`walkaddr`（`kernel/vm.c:104`）检查用户提供的虚拟地址是否属于进程的用户地址空间，以防止程序诱使内核读取其他内存。类似的功能 `copyout` 将数据从内核复制到用户提供的地址。

### 4.5 内核空间的中断

v6根据CPU当前执行的是用户代码还是内核代码，在配置CPU陷阱寄存器时有所不同。当CPU执行内核代码时，xv6将`stvec`指向位于`kernelvec`的汇编代码（kernel/kernelvec.S:10）。由于xv6已经在内核中运行，`kernelvec`可以依赖于`satp`设置为内核页表，并且栈指针指向有效的内核栈。`kernelvec`将所有32个寄存器压入中断的内核线程栈中，稍后将它们恢复，以便中断的内核代码可以无干扰地继续执行。`kernelvec`将寄存器保存在中断的内核线程栈上是有道理的，因为这些寄存器值属于该线程。

如果陷阱导致切换到不同的线程，这一点尤为重要——在这种情况下，陷阱将实际从新线程的堆栈返回，从而安全地将中断的线程的保存寄存器留在其堆栈上。保存寄存器后，`kernelvec`跳转到`kerneltrap`（kernel/trap.c:134）。`kerneltrap`准备处理两种类型的陷阱：设备中断和异常。它调用d`evintr`（kernel/trap.c:177）来检查和处理设备相关的陷阱。如果陷阱不是设备中断，则必须是异常，在`xv6`内核中，异常总是致命错误；内核会调用`panic`并停止执行。

如果由于定时器中断而调用了`kerneltrap`，并且某个进程的内核线程正在运行（而不是调度器线程），则`kerneltrap`会调用`yield`以让其他线程有机会运行。随后，当其他线程之一调用`yield`时，被中断的线程及其`kerneltrap`将可以恢复执行。第7章详细解释了yield的过程。

当`kerneltrap`完成其任务后，它需要返回到被陷阱中断的代码。由于`yield`可能会影响`sepc`和`sstatus`中的先前模式，`kerneltrap`在开始时保存了这些值。然后，它恢复这些控制寄存器，并返回到`kernelvec`（kernel/kernelvec.S:48）。

在`kernelvec`中，从堆栈中弹出保存的寄存器，并执行`sret`。`sret`将`sepc`复制到`pc`并恢复被中断的内核代码的执行。值得注意的是，如果`kerneltrap`由于定时器中断而调用`yield`，则需要仔细考虑陷阱返回的过程。当CPU从用户空间进入内核时，xv6将该CPU的`stvec`设置为`kernelvec`；你可以在`usertrap`中看到这一点（kernel/trap.c:29）。在内核开始执行但`stvec`仍然设置为`uservec`时存在一个时间窗口，此时不应发生设备中断。幸运的是，RISC-V在开始处理陷阱时总是禁用中断，并且在设置完`stvec`之前，xv6不会再次启用中断。


### 4.6 页面故障异常

xv6 对异常的响应相当单调：如果异常发生在用户空间，内核会杀死出错的进程；如果异常发生在内核中，内核会触发恐慌。而真正的操作系统通常会以更加多样化的方式应对这些情况。例如，许多内核利用页面故障来实现写时复制（Copy-On-Write, COW）的 `fork` 功能。为了理解写时复制的 `fork`，可以参考第 3 章中描述的 xv6 的 `fork`。`fork` 导致子进程的初始内存内容与父进程在 `fork` 时刻相同。xv6 使用 `uvmcopy`（位于 `kernel/vm.c:301`）实现 `fork`，该函数为子进程分配物理内存并将其父进程的内存内容复制进去。如果子进程和父进程能够共享父进程的物理内存，效率会更高。然而，这种直接实现方法不可行，因为这会导致父进程和子进程通过写入共享的栈和堆来相互干扰。通过适当地使用页表权限和页面故障，父进程和子进程可以安全地共享物理内存。

当使用的虚拟地址在页表中没有映射，或者映射的 PTE_V 标志位被清除，或者映射的权限位（PTE_R, PTE_W, PTE_X, PTE_U）禁止了尝试进行的操作时，CPU 会触发页面故障异常。RISC-V 区分了三种类型的页面故障：加载页面故障（当加载指令无法转换其虚拟地址时发生）、存储页面故障（当存储指令无法转换其虚拟地址时发生），以及指令页面故障（当程序计数器中的地址无法转换时发生）。`scause` 寄存器指示页面故障的类型，而 `stval` 寄存器则包含无法转换的地址。

写时复制 `fork` 的**基本策略**是让父进程和子进程最初共享所有的物理页面，但每个进程都以只读方式（PTE_W 标志位被清除）映射这些页面。这样，父进程和子进程可以从共享的物理内存中读取数据。如果任一进程试图写入某个页面，RISC-V CPU 将触发页面故障异常。内核的陷阱处理程序将响应此异常，通过分配新的物理内存页面，并将故障地址映射到的物理页面内容复制到新页面中。然后，内核更改出错进程页表中相关的 PTE，使其指向新复制的页面，并允许读写操作，之后恢复出错进程在导致故障的指令处执行。由于 PTE 允许写入，重新执行的指令现在可以无故障执行。

**写时复制需要记录来帮助决定何时可以释放物理页面**，因为每个页面可能被不同数量的页表引用，这取决于 `fork`、页面故障、`exec` 和退出的历史。这种记录允许一个重要优化：如果一个进程发生存储页面故障，且物理页面仅被该进程的页表引用，则不需要复制。写时复制使 `fork` 更快，因为它不需要复制内存。虽然一些内存最终会被写入时复制，但很多时候大多数内存实际上从未被复制过。一个常见的例子是 `fork` 后跟 `exec`：`fork` 后可能会有几页被写入，但随后子进程的 `exec` 会释放从父进程继承的大部分内存。写时复制 `fork` 消除了永远不必复制这部分内存的需求。此外，写时复制是透明的：应用程序无需任何修改即可受益于这项技术。

页表和页面故障的结合不仅限于写时复制 `fork`，还开启了广泛的可能性。另一个广泛使用的特点是**懒惰分配**，它分为两部分。首先，当应用程序通过调用 `sbrk` 请求更多内存时，内核记录增加的大小，但不会立即分配物理内存或为新的虚拟地址范围创建 PTE。其次，在这些新地址上的页面故障发生时，内核分配物理内存页面并将其映射到页表中。像写时复制 `fork` 一样，内核可以对应用程序透明地实现懒惰分配。由于应用程序经常请求比实际需要更多的内存，懒惰分配是一个胜利点：对于应用程序从未使用的页面，内核完全不需要做任何工作。此外，如果应用程序请求大幅扩展地址空间，那么没有懒惰分配的 `sbrk` 是昂贵的：如果应用程序请求 1GB 的内存，内核必须分配并初始化 262,144 个 4096 字节的页面。懒惰分配使得这一成本可以随时间分散。另一方面，懒惰分配带来了额外的页面故障开销，这涉及内核/用户切换。操作系统可以通过每次页面故障分配一批连续的页面而不是单个页面，以及专门化内核入口/出口代码来减少这种成本。

另一个利用页面故障的广泛使用的功能是**按需分页**。在 `exec` 中，xv6 急切地将应用程序的所有文本和数据加载到内存中。由于应用程序可能很大，而从磁盘读取数据很昂贵，这种启动成本对用户来说可能是明显的：当用户从命令行启动大型应用程序时，可能需要很长时间才能看到响应。为了提高响应速度，现代内核为用户地址空间创建页表，但将页面的 PTE 标记为无效。当页面故障发生时，内核从磁盘读取页面内容并将其映射到用户地址空间。像写时复制 `fork` 和懒惰分配一样，内核可以对应用程序透明地实现这一功能。运行在计算机上的程序可能需要比计算机可用的 RAM 更多的内存。为了优雅地应对这种情况，操作系统可能会实现磁盘分页。其想法是在 RAM 中仅存储一小部分用户页面，而其余部分则存储在磁盘上的分页区域中。内核将对应于存储在分页区域中的内存的 PTE 标记为无效。如果应用程序试图使用已被换出到磁盘的一个页面，应用程序将触发页面故障，此时需要将页面换入：内核陷阱处理程序将分配一个物理 RAM 页面，从磁盘读取页面内容到 RAM 中，并修改相关的 PTE 以指向 RAM。

如果需要换入一个页面，但没有空闲的物理 RAM 可用，会发生什么？在这种情况下，内核必须首先通过将页面换出或将现有页面驱逐到磁盘上的分页区域来释放一个物理页面，并将指向前述物理页面的 PTE 标记为无效。驱逐是昂贵的，因此当应用程序只使用它们内存页面的一部分，且这些部分的联合能适应 RAM 时，分页表现最佳。这一属性通常被称为具有良好的局部性引用。与其他许多虚拟内存技术一样，内核通常以对应用程序透明的方式实现磁盘分页。无论硬件提供的 RAM 多少，计算机通常都在几乎没有或没有空闲物理内存的情况下运行。例如，云提供商在同一台机器上多路复用许多客户，以有效地使用他们的硬件。另一个例子是用户在少量物理内存上运行多个应用程序的智能手机。在这样的环境中，分配页面可能需要先驱逐一个现有页面。因此，当空闲物理内存稀缺时，分配变得昂贵。当空闲内存稀缺时，懒惰分配和按需分页尤其有利。急切地在 `sbrk` 或 `exec` 中分配内存会产生额外的成本，即驱逐以释放内存。此外，急切工作的风险在于，应用程序在使用页面之前，操作系统可能已经将其驱逐，从而浪费了急切的工作。其他结合了分页和页面故障的功能包括自动扩展栈和内存映射文件。


### 4.7 现实世界

跳板（trampoline）和陷阱帧（trapframe）可能看起来过于复杂。推动这一设计的主要原因是 RISC-V 在触发陷阱时有意尽可能少地做事，以便实现非常快速的陷阱处理，这一点最终被证明非常重要。

因此，内核陷阱处理程序的前几条指令实际上需要在用户环境中执行：使用用户的页表和用户寄存器的内容。并且，陷阱处理程序最初不知道一些有用的信息，比如正在运行的进程的身份或内核页表的地址。解决这个问题的方法是利用 RISC-V 提供的一些受保护的地方，内核可以在进入用户空间之前将信息存放在这些地方：`sscratch` 寄存器，以及指向内核内存但因缺乏 PTE_U 标志位而受到保护的用户页表项。

xv6 的跳板和陷阱帧利用了这些 RISC-V 特性。如果内核内存被映射到每个进程的用户页表中（使用适当的 PTE 权限标志），就可以消除对特殊跳板页面的需求。这也将消除从用户空间进入内核时切换页表的需要。反过来，这将允许内核中的系统调用实现利用当前进程的用户内存已映射的事实，使内核代码可以直接解引用用户指针。许多操作系统已经使用了这些想法来提高效率。xv6 避免使用这些技术是为了降低由于意外使用用户指针而导致内核中出现安全漏洞的风险，并减少确保用户和内核虚拟地址不重叠所需的一些复杂性。生产操作系统实现了写时复制 `fork`、懒惰分配、按需分页、磁盘分页、内存映射文件等功能。此外，生产操作系统会尽量使用所有物理内存，无论是用于应用程序还是缓存（例如文件系统的缓冲区缓存，我们将在第 8.2 节中详细讨论）。相比之下，xv6 在这方面显得较为天真：您希望操作系统充分利用您购买的物理内存，但 xv6 却没有做到这一点。此外，如果 xv6 内存不足，它会向运行中的应用程序返回错误或杀死该应用程序，而不是采取其他措施，如驱逐另一个应用程序的一页内存。