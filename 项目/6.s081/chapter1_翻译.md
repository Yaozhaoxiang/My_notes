exec抽象内存，每次运行都会传入文件名
file抽象了内存，应用程序不会直接读写再计算机上的磁盘本身，通过file交互

## 1.4 File system
xv6 文件系统提供了数据文件，其中包含未经解释的字节数组，以及目录，其中包含对数据文件和其他目录的命名引用。目录形成了一个树状结构，从一个称为根的特殊目录开始。路径如 /a/b/c 指向根目录 / 中名为 a 的目录内的名为 b 的目录内的名为 c 的文件或目录。不以 / 开头的路径相对于调用进程的当前目录进行解析，当前目录可以通过 chdir 系统调用来更改。以下这两段代码片段打开了相同的文件（假设所有涉及的目录都存在）：

```cpp
chdir("/a"); 
chdir("b"); 
open("c", O_RDONLY);
open("/a/b/c", O_RDONLY);
```

第一段代码将进程的当前目录更改为 `/a/b`；第二段代码既不引用也不改变进程的当前目录。有一些系统调用来创建新的文件和目录：`mkdir` 创建一个新的目录，`open` 使用 `O_CREATE` 标志创建一个新的数据文件，`mknod` 创建一个新的设备文件。以下示例展示了这三种操作：

```cpp
mkdir("/dir");
fd = open("/dir/file", O_CREATE | O_WRONLY);
close(fd);
mknod("/console", 1, 1);
```

`mknod` 创建一个引用设备的特殊文件。与设备文件相关联的是主设备号和次设备号（`mknod` 的两个参数），它们唯一标识一个内核设备。当进程稍后打开设备文件时，内核会将读写系统调用重定向到内核设备实现，而不是传递给文件系统。

文件的名称与其本身是不同的；同一个底层文件（称为 inode）可以有多个名称，称为链接。每个链接由目录中的一个条目组成，该条目包含文件名和对 inode 的引用。inode 包含关于文件的元数据，包括其类型（文件、目录或设备）、长度、文件内容在磁盘上的位置以及文件的链接数。

`fstat` 系统调用从文件描述符引用的 inode 中检索信息。它填充一个在 `stat.h`（`kernel/stat.h`）中定义的 `struct stat`，如下所示：

```c
#define T_DIR 1 // 目录
#define T_FILE 2 // 文件
#define T_DEVICE 3 // 设备

struct stat {
    int dev; // 文件系统的磁盘设备
    uint ino; // inode 编号
    short type; // 文件类型
    short nlink; // 文件的链接数
    uint64 size; // 文件大小（字节）
};
```

`link` 系统调用创建另一个引用与现有文件相同的 inode 的文件系统名称。以下代码片段创建了一个名为 `a` 和 `b` 的新文件：

```cpp
open("a", O_CREATE | O_WRONLY);
link("a", "b");
```

读取或写入 `a` 与读取或写入 `b` 是相同的。每个 inode 由唯一的 inode 编号标识。在上述代码序列之后，可以通过检查 `fstat` 的结果来确定 `a` 和 `b` 引用的是相同的基础内容：两者将返回相同的 inode 编号（`ino`），并且链接计数（`nlink`）将设置为 2。

`unlink` 系统调用从文件系统中删除一个名称。只有当文件的链接计数为零且没有文件描述符引用它时，文件的 inode 和磁盘空间才会被释放。因此，如果在上述代码序列的末尾添加 `unlink("a")`，inode 和文件内容仍可以通过 `b` 访问。此外，

```cpp
fd = open("/tmp/xyz", O_CREATE | O_RDWR);
unlink("/tmp/xyz");
```

是一种惯用方法，用于创建一个没有名称的临时 inode，该 inode 在进程关闭 `fd` 或退出时会被清理。

Unix 提供了一些可以从 shell 调用的文件实用程序，例如 `mkdir`、`ln` 和 `rm`。这种设计允许任何人通过添加新的用户级程序来扩展命令行接口。回过头来看，这个计划似乎是显而易见的，但在 Unix 时代设计的其他系统通常将这样的命令内置到 shell 中（甚至将 shell 内置到内核中）。一个例外是 `cd`，它被内置到 shell 中（`user/sh.c:160`）。`cd` 必须更改 shell 自身的当前工作目录。如果 `cd` 作为常规命令运行，shell 会派生一个子进程，子进程会运行 `cd`，`cd` 会更改子进程的工作目录，而父进程（即 shell）的工作目录不会改变。


# 1.5 现实世界

Unix 将“标准”文件描述符、管道和方便的 shell 语法结合在一起，用于操作这些文件描述符，这是编写通用可重用程序的一个重大进步。这一理念激发了一种“软件工具”的文化，这种文化是 Unix 功能强大和受欢迎的主要原因之一，而 shell 成为了第一个所谓的“脚本语言”。Unix 系统调用接口在今天的 BSD、Linux 和 macOS 等系统中依然存在。Unix 系统调用接口已经通过可移植操作系统接口（POSIX）标准进行了标准化。然而，xv6 并不符合 POSIX 标准：它缺少许多系统调用（包括基本的 `lseek`），并且许多提供的系统调用与标准不同。我们的主要目标是使 xv6 简单明了，同时提供一个简单的类 Unix 系统调用接口。一些人已经通过增加一些更多的系统调用和一个简单的 C 库来扩展 xv6，以便运行基本的 Unix 程序。然而，现代内核提供了比 xv6 更多的系统调用和更多种类的内核服务。例如，它们支持网络、窗口系统、用户级线程、多种设备的驱动程序等。现代内核持续快速地发展，并提供了许多超出 POSIX 的功能。

Unix 通过一组统一的文件名和文件描述符接口访问多种资源（文件、目录和设备）。这一理念可以扩展到更多种类的资源；一个很好的例子是 Plan 9 [14]，它将“资源是文件”的概念应用于网络、图形等领域。然而，大多数基于 Unix 的操作系统并没有沿着这条路发展。文件系统和文件描述符一直是强大的抽象模型。即便如此，还有其他的操作系统接口模型。Unix 的前身 Multics 以一种使其看起来像内存的方式来抽象文件存储，产生了截然不同的接口风格。Multics 设计的复杂性直接影响了 Unix 设计者，他们试图构建一个更简单的系统。xv6 不提供用户的概念，也不保护一个用户免受另一个用户的干扰；用 Unix 的术语来说，所有 xv6 进程都以 root 用户身份运行。

本书探讨了 xv6 如何实现其类 Unix 接口，但这些理念和概念不仅适用于 Unix。任何操作系统都必须将进程多路复用到底层硬件上，隔离进程，提供受控的进程间通信机制。学习了 xv6 之后，你应该能够查看其他更复杂的操作系统，并在这些系统中看到 xv6 的基础概念。

