# xv6 book

驱动程序是操作系统中管理特定设备的代码：它配置设备硬件，指示设备执行操作，处理由此产生的中断，并与可能等待设备I/O的进程交互。驱动程序代码可能很棘手，因为驱动程序与它管理的设备并发执行。此外，驱动程序必须了解设备的硬件接口，这可能复杂且文档不充分。

需要操作系统关注的设备通常可以配置为生成中断，中断是一种陷阱。内核陷阱处理代码能够识别设备何时引发中断，并调用驱动程序的中断处理程序；在 xv6 中，这种调度发生在 devintr 中（kernel/trap.c:177）。

许多设备驱动程序在两种上下文中执行代码：在进程内核线程中运行的上半部分和在中断时执行的下半部分。上半部分通过系统调用（如 read 和 write）被调用，这些调用希望设备执行 I/O。这段代码可能会要求硬件启动一个操作（例如，要求磁盘读取一个块）；然后代码等待操作完成。最终设备完成操作并引发中断。驱动程序的中断处理程序作为下半部分，确定完成了什么操作，必要时唤醒等待的进程，并告诉硬件开始处理任何等待的下一个操作。

1. 控制台输入
控制台驱动程序(kernel/console.c)，是一个简单的驱动结构实例。控制台驱动程序通过链接RISC-V的UART串行端口硬件接受人类输入的字符。控制台驱动程序一次积累一行的输入，处理像退格和control-u等特殊输入字符。用户进程（shell）**使用read系统调用从控制台获取输入行**。当你在QEMU中向xv6输入时，你的按键通过QEMU模拟的UART硬件传递给xv6.

驱动程序与之通信的UART硬件是由QEMU模拟的16550芯片。在真实计算机上，16550芯片将管理连接到终端或其他计算机的RS232串行链接。在运行QEMU时，它连接到你的键盘和显示器。

**UART硬件对软件来说表现为一组内存映射寄存器。**也就是说，有一些物理地址由PISC-V硬件连接到UART设备上，使得加载和存储操作与设备交互，而不是与RAM交互。UART的内存映射地址从at 0x10000000, or UART0。UART有少量的寄存器，每个寄存器的宽度为**一字节**。他们相对于UART0的偏移量定义。例如，`LSR`寄存器包含的位指示是否有输入字符等待被软件读取。这些字符（如果有的话）可以从`RHR`寄存器读取。每次读取一个字符时，UART硬件从等待字符的内部`FIFO`中删除它，并在`FIFO`为空时清楚`LSR`中的`ready`位。UART发送硬件与接受硬件基本独立；如果软件向`THR`写入一个字符，UART会发送该字符。  

xv6的`main`函数调用`consoleinit`来初始化UART硬件。这个代码配置UART以在每接受一个输入字节时生成一个接受中断，并在每次完成发送一个输出字节时生成一个发送完成中断(kernel/uart.c:53)。

xv6的shell通过由`init.c`打开打开的文件描述符从控制台读取。对`read`系统调用的调用通过内核传递到`consoleread`。`consoleread`等待输入到达(通过中断)并缓存在`cons.buf`中，将输入复制到用户空间，并在整行到达后返回给用户进程。如果用户尚未输入完整的一行，任何读取进程将会在`sleep`调用中等待。

当用户输入一个字符时，UART硬件请求RISC-V触发一个中断，从而激活xv6的陷阱处理程序。陷阱处理程序调用`devintr`，它查看RISC-V的`scause`寄存器，发现中断来自外部设备。然后，它请求一个名位PLIVC的硬件单元告知是那台设备触发了中断。如果是UART触发了中断，`devintr`会调用`uartintr`。

`uartintr`从UART硬件读取所有等待的输入字符，并将他们交给`consoleintr`；它不会等待字符，因为未来的输入会触发新的中断。`consoleintr`的任务是将输入字符累积到`cons,buf`中，直到整行到达。`consoleintr`特别处理退格和其他几个字符。当新行到达时，`consoleread`唤醒正在等待的`consoleread`（如果有的话）。

一旦被唤醒，`consoleread`将在`con.buf`中看到完整的一行，将其复制到用户空间，并返回（通过系统调用机制）到用户空间

2. 控制台输出
对连接到控制台的文件描述符进行的`write`系统调用最终到达`uartputc`。设备驱动程序维护一个输出缓冲区`uart_tx_buf`,以便写入进程不必等待UART完成发送操作；相反，`uartpusc`将每个字符附加到缓冲区，调用`uartstart`启动设备传输（如果设备还未在传输），然后返回。唯一使`uartputs`需要等待的情况使缓冲区已经满了。

每次UART发送完一个字节时，它会生成一个中断。`uartintr`调用`uartstart`，后者检查设备是否确实完成了发送，并将下一个缓冲输出字符交给设备。因此，如果一个进程向控制台写入多个字节，通常第一个字节会通过`uartputc`调用`uartstart`发送。


一个需要注意的一般模式是通过缓冲和中断实现设备活动和进程活动的解耦。即使没有进程在等待读取，控制台驱动程序也可以处理输入；后续的读取操作将看到这些输入。同样，进程可以发送输出而无需等待设备。这种解耦可以通过允许进程与设备i/o并发执行来提高性能，当设备速度较慢或需要立即处理（如回显输入字符）时，这尤其重要。这种想法被称为I/O并发。

3. 驱动程序中的并发性

你可能已经注意到在 `consoleread` 和 `consoleintr` 中调用了 `acquire`。这些调用获取一个锁，用于保护控制台驱动程序的数据结构免受并发访问的影响。这里存在三种并发危险：不同 CPU 上的两个进程可能会同时调用 consoleread；硬件可能会在某个 CPU 正在执行 consoleread 时请求该 CPU 处理控制台（实际上是 UART）中断；硬件可能会在 consoleread 执行期间在不同的 CPU 上触发控制台中断。这些危险可能会导致竞争条件或死锁。第六章探讨了这些问题以及锁如何解决这些问题。

并发在驱动程序中需要注意的另一个方面是，一个进程可能正在等待来自设备的输入，而输入到达的中断信号可能在不同的进程（或者根本没有进程）运行时到达。因此，中断处理程序不允许考虑它们中断的进程或代码。例如，中断处理程序不能安全地调用 copyout 并使用当前进程的页表。中断处理程序通常执行相对较少的工作（例如，只是将输入数据复制到缓冲区），并唤醒上半部分代码来完成其余工作。

4. 定时中断
xv6使用定时器中断来维护其时钟并允许在计算密集型进程之间进行切换；在`usertrap`和`kerneltrap`中的`yield`调用引发这种切换。定时器中断来自连接到每个RISC-V CPU的时钟硬件。xv6对这些时钟硬件进行编程，使其定期中断每个CPU。

RISC-V要求定时器中断在机器模式下处理，而不是在监管模式下。RISC-V机器模式执行时不使用分页，并使用单独的控制寄存器集，因此在机器模式下运行xv6内核代码时不现实的。因此，xv6完全独立于上述的陷阱机制处理定时中断。

在`start.c`中的机器模式代码（在`main`之前）设置接受定时器中断。其中一部分工作是配置CLINT硬件（核内部中断控制器），在一定延迟后生成的中断。另一部分是设置一个类似于`trapframe`的临时区域，用于帮助定时器中断处理程序保存寄存器和CLINT寄存器的地址。最后`start`将`mtvec`设置为`timervec`并启用定时器中断。
      
定时器中断可以在用户或内核代码执行时的任何时刻发生；内核无法在关键操作期间禁用定时器中断。因此，定时器中断处理程序必须以一种不会干扰被中断代码的方式执行其工作。基本策略是让处理程序请求RISC-V发起一个软中断，然后立即返回。RISC-V使用普通的陷阱机制将软中断传递给内核，并允许内核禁用他们。定时器中断引发的软中断处理代码可以在`devintr`中看到。

机器模式的定时器中断处理程序是`timervec`。它在`start`准备的临时区域中保存几个寄存器，告知CLINT下次生成定时器中断的时间，请求RISC-V 发起软中断，恢复寄存器并返回。定时器中断处理程序中没有 C 代码。


Xv6允许在内核执行时以及执行用户程序时发生设备和定时器中断。即使在内核执行时，定时器中断也会从定时器中断处理程序中强制进行线程切换（调用yield）。在内核线程之间公平地对CPU进行时间切片是有用的，特别是当内核线程在计算时花费大量时间而不返回用户空间时。然而，内核代码需要意识到可能会因定时器中断而被挂起，并且稍后在不同的CPU上恢复，这是xv6中某些复杂性的源泉（请参见第6.6节）。如果设备和定时器中断仅在执行用户代码时发生，内核可能会变得更简单。

支持典型计算机上所有设备的全功能是很大的工作，因为设备种类繁多，设备具有许多特性，并且设备与驱动程序之间的协议可能复杂且文档不足。在许多操作系统中，驱动程序的代码量比核心内核还要多。

UART驱动程序通过读取UART控制寄存器逐字节检索数据；这种模式称为编程I/O，因为软件驱动数据移动。编程I/O简单，但在高数据率下使用过于缓慢。需要以高速移动大量数据的设备通常使用直接内存访问（DMA）。DMA设备硬件直接将传入的数据写入RAM，并从RAM中读取传出的数据。现代磁盘和网络设备使用DMA。DMA设备的驱动程序将在RAM中准备好的数据，然后使用单个写操作向控制寄存器发送指令，以告知设备处理准备好的数据。当设备需要在不可预测的时间内获得注意时，中断是有意义的，但中断会带来较高的CPU开销。因此，高速设备（如网络和磁盘控制器）使用减少中断需求的技巧。其中一个技巧是为整批传入或传出请求触发单个中断。另一个技巧是驱动程序完全禁用中断，并定期检查设备是否需要处理。这种技术称为轮询。

如果设备执行操作非常快，则轮询是有意义的，但如果设备大部分时间处于空闲状态，则会浪费CPU时间。一些驱动程序根据当前设备负载动态切换在轮询和中断之间。

UART驱动程序首先将传入数据复制到内核中的缓冲区，然后再复制到用户空间。这在低数据率时是有意义的，但对于生成或消耗数据速度非常快的设备，这种双重复制会显著降低性能。一些操作系统能够直接在用户空间缓冲区和设备硬件之间移动数据，通常使用DMA。如第1章所述，控制台对应用程序看起来像一个常规文件，应用程序使用读取和写入系统调用读取输入和写入输出。应用程序可能希望控制一些无法通过标准文件系统调用表达的设备特性（例如，在控制台驱动程序中启用/禁用行缓冲）。Unix操作系统支持ioctl系统调用来处理这些情况。一些计算机使用情景要求系统必须在有界时间内做出响应。例如，在安全关键系统中，错过截止时间可能导致灾难。

Xv6不适合硬实时环境设置。硬实时操作系统通常是库，可以与应用程序链接，以便分析确定最坏情况下的响应时间。同样，Xv6也不适合软实时应用程序，因为偶尔错过截止时间是可以接受的，而Xv6的调度程序过于简单，并且其内核代码路径中中断被禁用的时间太长。






