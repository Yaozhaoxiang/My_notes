# 陷阱和系统调用

**(xv6book上的内容)**

>有三种情况会发生陷阱
    1. 系统调用：用户程序执行`ecall`
    2. 异常
    3. 设备中断
   
当陷阱发生的时候，陷阱强制将控制权转移到内核；内核保存寄存器和其他状态，用于稍后恢复；内核执行处理程序；内核恢复保存的状态并从陷阱中返回；原始代码从中断中恢复执行。

所有的陷阱都是在内核中完成的；
为用户空间陷阱、内核空间陷阱和定时器中断分别使用不同的代码；

## 1. 一些寄存器
每个cpu都有一组控制寄存器，内核可以向这些寄存器写入信息，告诉cpu如何处理陷阱，同时内核也可以从这些寄存器中获取信息，了解发生的陷阱情况。
`stvec`:内核将其陷阱处理程序的地址写入stvec寄存器中；当RISC-V处理陷阱时，会跳转到stvec中的地址执行相应的处理。
`sepc`: 当发生陷阱时，RISC-V会将程序计数器（PC）的值保存到sepc寄存器中（因为此时PC会被stvec中的值覆盖）。sret（从陷阱返回）指令会将sepc的值复制回PC。内核可以写入sepc来控制ret返回的位置
`scause`: RISC-V将描述陷阱原因的编号存放在这里。
`sscratch`内核在陷阱处理程序的开头往这里放置一个值，这个值在处理陷阱的最开始非常有用。
`sstatus`在sstatus寄存器中，SIE位控制设备中断是否被允许。如果内核清除了SIE，RISC-V会推迟设备中断，直到内核设置了SIE。SPP位指示陷阱是来自用户模式还是监管者模式，并控制ret返回到哪种模式。

执行一个陷阱的步骤：
  1. 如果陷阱是设备中断，并且`sstatus`寄存器中的SIE位被清除，那么不执行以下操作：
  2. 清除`sstatus`寄存器中的SIE位，禁用中断。
  3. 将当前程序计数器（`PC`）的值复制到`sepc`寄存器中
  4. 在`sstatus`寄存器的`SPP`位中保存当前模式（用户模式或监管者模式）
  5. 将`scause`寄存器设置为反映陷阱原因的值
  6. 设置模式为监管者模式。
  7. 将`stvec`寄存器的值复制到程序计数器（`PC`）中，开始执行陷阱处理程序的新地址。
  8. 在新的`pc`开始执行

注意;CPU在处理陷阱时不会切换到内核页表，也不会切换到内核的堆栈，并且除了保存程序计数器（PC）外，不会保存任何其他寄存器的状态。这些任务必须由内核软件来完成。

## 2. 来自用户空间的陷阱

从用户空间发生陷阱的高级路径是通过以下几个步骤：
  1. `uservec`（kernel/trampoline.S:16）：这是一个汇编代码，用于处理从用户空间进入内核的初始阶段。
  2. `usertrap`（kernel/trap.c:37）：这是内核中的一个C函数，负责处理从用户空间发生的陷阱事件。
  3. `usertrapret`（kernel/trap.c:90）：这个函数处理从内核返回用户空间时的相关任务，如恢复状态等。
  4. `userret`（kernel/trampoline.S:88）：这是在处理完陷阱后，从内核返回到用户空间的最终阶段的汇编代码。

v6的陷阱处理设计中的一个重要限制是，当RISC-V硬件强制执行陷阱时，不会切换页表。这意味着在处理陷阱代码开始执行时，`stvec`中的陷阱处理程序地址必须在用户页表中有有效的映射，因为这是陷阱处理代码执行时生效的页表。此外，xv6的陷阱处理代码需要切换到内核页表；为了能够在切换后继续执行，内核页表必须也对`stvec`指向的处理程序有映射。

在xv6中，通过使用一个跳板页（`trampoline page`）来满足这些需求。跳板页包含了`uservec`，也就是`stvec`指向的xv6陷阱处理代码。跳板页在每个进程的页表中都被映射到地址`TRAMPOLINE`，这个地址位于虚拟地址空间的末尾，因此它位于程序自身使用的内存上方。跳板页也在内核页表中被映射到地址`TRAMPOLINE`。由于跳板页在用户页表中被映射，并且带有`PTE_U`标志，因此陷阱可以以监管者模式开始执行。由于跳板页在内核地址空间中的相同地址也有映射，因此在切换到内核页表后，陷阱处理程序可以继续执行。

在xv6中，用于处理用户陷阱的`uservec`代码位于`trampoline.S`文件中（`kernel/trampoline.S:16`）。当`uservec`开始执行时，所有32个寄存器都包含被中断的用户代码拥有的值。这32个值需要被保存到内存的某个地方，以便在陷阱返回到用户空间时能够恢复它们。将数据存储到内存需要使用一个寄存器来保存地址，但在这个时刻，没有可用的通用寄存器！幸运的是，RISC-V提供了一个帮助手段，就是`sscratch`寄存器。在`uservec`开始时，`csrrw`指令会交换`a0`寄存器和`sscratch`寄存器的内容。现在用户代码的a0被保存在`sscratch`中；`uservec`有一个寄存器`（a0）`可供使用；而`a0`中包含了内核之前放置在`sscratch`中的值。

在xv6中，`uservec`接下来的任务是保存这32个用户寄存器的值。**在进入用户空间之前，内核会设置`sscratch`指向每个进程的`trapframe`结构体**。这个结构体中包含了保存这32个用户寄存器值所需的空间，以及其他必要的信息（参见kernel/proc.h:44）。由于satp寄存器仍然引用用户页表，因此`uservec`需要在用户地址空间中映射`trapframe`结构体。
> 在进入用户空间之前，内核会设置`sscratch`指向每个进程的`trapframe`结构体

上面这个过程:这通常是在上下文切换（context switch）过程中完成的。具体来说，这一步操作通常在进程调度函数中进行，以下是一个典型的实现步骤：
  1. 定义 `trapframe` 结构体：`trapframe` 结构体保存了进程的CPU寄存器状态，用于在进程切换时保存和恢复进程的状态。
  2. 进程切换函数：在进程切换函数（例如 `scheduler()` 或 `switch()`）中，内核会将即将运行的进程的 `trapframe` 地址写入 `sscratch` 寄存器，以便在发生陷阱或中断时能够快速访问进程的状态。
   ```cpp
  //进程结构体
  struct proc {
  struct trapframe *trapframe;  // 指向进程的trapframe结构体
  // 其他进程相关的信息
    };

  //进程切换函数
    void switch_to(struct proc *p) {
    // 将进程p的trapframe地址写入sscratch寄存器
    w_sscratch((uint64)p->trapframe);
    
    // 恢复进程p的寄存器状态
    // 这里假设有一个汇编函数restore_context来恢复寄存器状态
    restore_context(p->trapframe);
    }
   ```
   3. 恢复上下文的汇编函数
  ```cpp
    restore_context:
    // 恢复寄存器状态（这里只是示例，实际可能更复杂）
    ld ra, 0(sp)
    ld sp, 8(sp)
    // ...
    ret
  ```
  4. w_sscratch 内联函数
  ```cpp
    static inline void w_sscratch(uint64 x) {
    asm volatile("csrw sscratch, %0" : : "r" (x));
    }
  ```
  5. 调度函数
  ```cpp
    void scheduler() {
    struct proc *p;
    
    while (1) {
        // 选择下一个要运行的进程p
        p = pick_next_process();
        
        // 切换到进程p
        switch_to(p);
    }
    }
  ```
  6. 通过这种方式，当发生中断或陷阱时，处理程序可以通过 sscratch 寄存器快速找到当前进程的 trapframe 结构体，并保存或恢复进程的状态。


在创建每个进程时，xv6会为进程的`trapframe`分配一页内存，并且始终将其映射到用户虚拟地址`TRAPFRAME`，这个地址位于`TRAMPOLINE`的正下方。进程的`p->trapframe`指针也指向这个`trapframe`，尽管它指向的是物理地址，因此内核可以通过内核页表访问它。

因此，在交换`a0`和`sscratch`之后，`a0`持有当前进程的`trapframe`指针。`uservec`现在将所有用户寄存器的值保存到`trapframe`中，包括从`sscratch`中读取的用户的`a0`。

>`trapframe`包含以下信息:   
>>当前进程的内核栈地址; 当前CPU的`hartid`;
`usertrap`函数的地址;
内核页表的地址;
  
`uservec`从`trapframe`中检索这些值，切换`satp`寄存器到内核页表，并调用`usertrap`函数。
步骤：
> 1. a0持有当前进程的trapframe指针。
> 2. 将所有32个用户寄存器的值保存到trapframe中
> 3. 从trapframe中获取当前进程的内核栈地址、当前CPU的hartid、usertrap函数的地址和内核页表的地址
> 4. 切换satp寄存器到内核页表。
> 5. 调用usertrap函数，以处理具体的陷阱。

`usertrap`的任务是确定陷阱的原因、处理它并返回。它首先更改`stvec`寄存器，使得在内核中的陷阱将由`kernelvec`而不是`uservec`来处理。它保存了`sepc`寄存器（保存了用户程序计数器），因为`usertrap`可能会调用`yield`切换到另一个进程的内核线程，而该进程可能会返回到用户空间，在此过程中会修改`sepc`。

如果陷阱是系统调用，`usertrap`会调用`syscall`函数来处理它；如果是设备中断，则调用`devintr`函数；否则，它是一个异常，内核会杀死出错的进程。系统调用路径会在保存的用户程序计数器上加4，因为在系统调用的情况下，RISC-V会让程序指针指向`ecall`指令，但用户代码需要从下一条指令开始执行。

在返回的过程中，`usertrap`会检查该进程是否已被杀死或是否应当让出CPU（如果这个陷阱是一个定时器中断）。以下是`usertrap`的具体步骤：
> 1. 更改stvec寄存器，使得内核中的陷阱由kernelvec处理
> 2. 保存sepc寄存器的值，以防在调用yield时切换到另一个进程
>3. 根据陷阱的类型进行处理：
     如果是系统调用，调用syscall函数。
     如果是设备中断，调用devintr函数。
     如果是其他异常，杀死出错的进程。
>  4. 对于系统调用路径，保存的用户程序计数器加4，以使用户代码从下一条指令开始执行。
>  5. 在返回之前，检查进程是否已被杀死或是否应当让出CPU。

返回用户空间的第一步是调用`usertrapret`函数。这个函数设置RISC-V控制寄存器，为将来来自用户空间的陷阱做准备。在最后，`usertrapret`调用`userret`，这个函数位于跳板页上，并且在用户和内核页表中都被映射。这样做的原因是`userret`中的汇编代码将会切换页表。以下是具体步骤：
  1. 设置`stvec`寄存器：将`stvec`设置为指向`uservec`，以便处理将来的用户空间陷阱。
  2. 准备`trapframe`字段：初始化`trapframe`中`uservec`所需的字段。
  3. 设置`sepc`寄存器：将`sepc`设置为之前保存的用户程序计数器值，以便返回用户空间时从正确的位置继续执行
  4. 调用`userret`：`usertrapret`调用`userret`，该函数位于跳板页上，负责切换页表并返回用户空间

`usertrapret`调用`userret`时，会将`TRAPFRAME`的地址传递给`a0`，并将指向进程的用户页表的指针传递给`a1`（参见kernel/trampoline.S:88）。`userret`函数会将`satp`切换到进程的用户页表。回忆一下，用户页表映射了跳板页和`TRAPFRAME`，但没有映射内核的其他部分。跳板页在用户和内核页表中被映射到相同的虚拟地址，这使得`uservec`在更改`satp`后仍然可以继续执行。

3. 系统调用

看一下用户调用如何到达内核中`exec`系统调用的实现。`initcode.S`将`exec`的参数放置在寄存器`a0`和`a1`中，并将系统调用号放置在`a7`中。系统调用号与`syscalls`数组中的条目相匹配，该数组是一个函数指针表`.ecall`指令将陷阱转入内核，并依次执行`uservec`、`usertrap`和s`yscall.syscall`函数（kernel/syscall.c:133）从`trapframe`中保存的`a7`寄存器中检索系统调用号，并使用该号作为索引查找`syscalls`数组。对于第一个系统调用，`a7`包含`SYS_exec`（kernel/syscall.h:8），这将导致调用系统调用实现函数`sys_exec`。当`sys_exec`返回时，`syscall`会将其返回值记录在`p->trapframe->a0`中。这将导致原始的用户空间调用`exec()`返回该值，因为RISC-V的C调用约定将返回值放在`a0`中。系统调用通常返回负数以指示错误，返回零或正数以表示成功。如果系统调用号无效，`syscall`会打印错误并返回-1
步骤：
  1. 参数传递：`initcode.S`将`exec`系统调用的参数放置在寄存器`a0`和`a1`中，将系统调用号放置在`a7`中
  2. 陷阱指令：`ecall`指令触发陷阱，控制权转移到内核
  3. 处理陷阱：内核首先执行`uservec`，然后是`usertrap`，最终到达`syscall`函数。
  4. 系统调用分派：`syscall`函数根据系统调用号查找并调用相应的系统调用处理函数。系统调用号与`syscalls`数组中的条目相匹配，该数组是一个包含所有系统调用函数指针的表（kernel/syscall.c:108）。
  5. 调用系统调用实现函数：对于`SYS_exec`调用`sys_exec`函数。
  6. 保存返回值：`sys_exec`返回后，`syscall`将返回值保存到`p->trapframe->a0`中。
  7. 返回用户空间：保存的返回值将被传递回用户空间的`exec()`调用
  8. 错误处理：如果系统调用号无效，`syscall`会打印错误并返回-1。

5. 内核空间陷阱
v6根据CPU当前执行的是用户代码还是内核代码，在配置CPU陷阱寄存器时有所不同。当CPU执行内核代码时，xv6将`stvec`指向位于`kernelvec`的汇编代码（kernel/kernelvec.S:10）。由于xv6已经在内核中运行，`kernelvec`可以依赖于`satp`设置为内核页表，并且栈指针指向有效的内核栈。`kernelvec`将所有32个寄存器压入中断的内核线程栈中，稍后将它们恢复，以便中断的内核代码可以无干扰地继续执行。`kernelvec`将寄存器保存在中断的内核线程栈上是有道理的，因为这些寄存器值属于该线程。

如果陷阱导致切换到不同的线程，这一点尤为重要——在这种情况下，陷阱将实际从新线程的堆栈返回，从而安全地将中断的线程的保存寄存器留在其堆栈上。保存寄存器后，`kernelvec`跳转到`kerneltrap`（kernel/trap.c:134）。`kerneltrap`准备处理两种类型的陷阱：设备中断和异常。它调用d`evintr`（kernel/trap.c:177）来检查和处理设备相关的陷阱。如果陷阱不是设备中断，则必须是异常，在`xv6`内核中，异常总是致命错误；内核会调用`panic`并停止执行。

如果由于定时器中断而调用了`kerneltrap`，并且某个进程的内核线程正在运行（而不是调度器线程），则`kerneltrap`会调用`yield`以让其他线程有机会运行。随后，当其他线程之一调用`yield`时，被中断的线程及其`kerneltrap`将可以恢复执行。第7章详细解释了yield的过程。

当`kerneltrap`完成其任务后，它需要返回到被陷阱中断的代码。由于`yield`可能会影响`sepc`和`sstatus`中的先前模式，`kerneltrap`在开始时保存了这些值。然后，它恢复这些控制寄存器，并返回到`kernelvec`（kernel/kernelvec.S:48）。

在`kernelvec`中，从堆栈中弹出保存的寄存器，并执行`sret`。`sret`将`sepc`复制到`pc`并恢复被中断的内核代码的执行。值得注意的是，如果`kerneltrap`由于定时器中断而调用`yield`，则需要仔细考虑陷阱返回的过程。当CPU从用户空间进入内核时，xv6将该CPU的`stvec`设置为`kernelvec`；你可以在`usertrap`中看到这一点（kernel/trap.c:29）。在内核开始执行但`stvec`仍然设置为`uservec`时存在一个时间窗口，此时不应发生设备中断。幸运的是，RISC-V在开始处理陷阱时总是禁用中断，并且在设置完`stvec`之前，xv6不会再次启用中断。

6. 异常

v6对异常的响应相当简单：如果异常发生在用户空间，内核会终止发生异常的进程。如果异常发生在内核中，内核会发生恐慌。真正的操作系统通常会以更加有趣的方式响应异常。
举个例子，许多内核使用页面故障来实现写时复制（Copy-On-Write, COW）的`fork`操作。为了解释写时复制的`fork`，可以考虑一下xv6中第3章描述的`fork`操作。`fork`会使子进程的初始内存内容与父进程在`fork`时的内存内容相同。xv6通过`uvmcopy`（kernel/vm.c:301）来实现`fork`，它为子进程分配物理内存，并将父进程的内存内容复制到其中。然而，如果子进程和父进程可以共享父进程的物理内存，那将更加高效。然而，一个直接的实现方式将无法正常工作，因为它会导致父进程和子进程在共享的堆栈和堆上进行写操作时互相干扰。

父进程和子进程可以通过适当使用页表权限和页故障来安全地共享物理内存。当虚拟地址在页表中没有映射、或者映射的`PTE_V`标志被清除、或者映射的权限位（`PTE_R`、`PTE_W`、`PTE_X`、`PTE_U`）禁止尝试的操作时，CPU会引发页面故障异常。RISC-V区分三种类型的页面故障：加载页面故障（当加载指令无法翻译其虚拟地址时）、存储页面故障（当存储指令无法翻译其虚拟地址时）、以及指令页面故障（当程序计数器中的地址无法翻译时）。`scause`寄存器指示页面故障的类型，而`stval`寄存器包含无法翻译的地址。

Copy-on-write（COW）fork允许父进程和子进程最初共享所有物理页面，但每个进程将它们映射为只读（`PTE_W`标志清除）。父进程和子进程都可以从共享的物理内存中读取数据。如果任一进程尝试向共享页面写入数据，RISC-V CPU会引发页面故障异常。内核的陷阱处理程序随后会响应此异常，分配新的物理内存页面，并将引起故障的虚拟地址对应的原始物理页面内容复制到新页面中。内核更新引起故障进程的页表条目（`PTE`），使其指向新副本，并允许读取和写入操作，然后恢复引起故障的进程从引起故障的指令继续执行。由于`PTE`允许写入操作，重新执行的指令现在可以正常执行而无需引发故障。`Copy-on-write`需要进行簿记，以便在决定何时可以释放物理页面时提供帮助，因为每个页面可能会被多个页表引用，具体取决于`fork`、页面故障、`exec`和`exit`的历史记录。这种簿记允许一个重要的优化：如果一个进程发生存储页面故障，并且物理页面仅被该进程的页表引用，那么不需要进行复制操作。


Copy-on-write（COW）使得`fork`操作更快，因为`fork`操作无需复制内存。一些内存在写入时需要稍后进行复制，但通常大部分内存根本不需要复制。一个常见的例子是`fork`后紧接着`exec`：在`fork`之后可能会写入少量页面，但子进程的`exec`会释放从父进程继承的大部分内存。`Copy-on-write fork`消除了永远复制此内存的需要。此外，`COW fork`是透明的：应用程序无需进行任何修改即可获得这些好处。

页表和页面故障的组合不仅打开了`COW fork`等一系列有趣的可能性。另一个广泛使用的特性是称为延迟分配（`lazy allocation`）的功能，它包括两个部分。首先，当应用程序通过调用`sbrk`请求更多内存时，内核会记录大小的增加，但不会分配物理内存，也不会为新的虚拟地址范围创建页表项（`PTE`）。其次，如果在这些新地址中发生页面故障，内核会分配一个物理页面并将其映射到页表中。与`COW fork`类似，内核可以透明地为应用程序实现延迟分配。

延迟分配的优势在于当应用程序请求的内存超过实际使用时，内核避免了不必要的工作。当应用程序调用`sbrk`请求更多内存时，内核并不立即分配物理内存或创建新虚拟地址范围的页表项（`PTE`）。相反，这些操作推迟到发生页面错误（`page fault`）时再进行处理。这种方法的优点包括：
  1. 效率高: 内核不会为应用程序从未访问过的页面分配物理内存或创建页表项，从而节省了计算资源和内存开销。
  2. 成本分摊: 当应用程序请求大量内存时，传统的分配方式会立即分配并清零大量页面。而延迟分配能够将这种成本分摊到时间上，只有在需要时才会逐页进行分配。
然而，延迟分配也引入了页面错误的额外开销。每次页面错误都会触发内核与用户空间之间的切换，内核通过分配物理页面和更新页表来处理这些错误。为了减少这种开销，操作系统可以通过以下方式进行优化： 
  1. 批量分配: 每次页面错误时一次性分配一批连续的页面，而不是单独处理每个页面错误，从而减少内核与用户空间之间切换的频率。
  2. 优化的入/出口代码: 专门为处理页面错误而优化内核代码，以最小化内核与用户模式之间切换的开销。

程序在计算机上运行时可能需要的内存超过了计算机实际拥有的`RAM`。为了优雅地处理这种情况，操作系统可以实现将页面分页到磁盘的技术。其基本思想是，只将用户页面的一部分存储在`RAM`中，将其余部分存储在磁盘的分页区域中。内核将对应于存储在分页区域中的内存的页表项（`PTE`）标记为无效。如果应用程序尝试使用已经分页到磁盘的页面之一，应用程序将触发页面错误（`page fault`）。内核的陷阱处理程序将分配一块物理`RAM`页面，将页面从磁盘读入`RAM`，并修改相关的PTE以指向`RAM`。

如果需要将页面分页到内存中，但没有空闲的物理`RAM`怎么办？在这种情况下，内核必须首先释放一个物理页面，将其分页到磁盘或驱逐到磁盘的分页区域，并将引用该物理页面的`PTE`标记为无效。由于驱逐操作代价高昂，因此分页技术的性能最佳情况下是不频繁发生的：如果应用程序只使用其内存页面的一个子集，并且这些子集的总和适合于`RAM`。这种属性通常被称为具有良好的引用局部性。

与许多虚拟内存技术类似，内核通常以对应用程序透明的方式实现页面分页到磁盘。

计算机经常在几乎没有或没有空闲物理内存的情况下运行，无论硬件提供了多少`RAM`。例如，云服务提供商通常在单台机器上多路复用多个客户，以有效利用他们的硬件成本。另一个例子是用户在智能手机上运行多个应用程序，这些设备通常只有少量的物理内存可用。

在这些情况下，分配新的内存页面可能需要先将当前存储在`RAM`中的页面驱逐或交换出去。因此，当物理内存空闲不足时，内存分配变得昂贵且低效。在这种情况下，像延迟分配和需求分页这样的技术尤为有利。

延迟分配，例如在函数如`sbrk`或`exec`中使用的方式，会带来特别的优势。









