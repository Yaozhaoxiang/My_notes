>你将使用一个叫做 E1000 的网络设备来处理网络通信。对于 xv6（以及你编写的驱动程序）来说，E1000 看起来像是一个连接到实际以太网局域网（LAN）的真实硬件。实际上，你的驱动程序将与的 E1000 是 qemu 提供的一个仿真器，连接到一个同样由 qemu 仿真的局域网。在这个仿真的局域网中，xv6（"客户机"）的 IP 地址是 10.0.2.15。Qemu 还安排使运行 qemu 的计算机在局域网上显示为 IP 地址 10.0.2.2。当 xv6 使用 E1000 向 10.0.2.2 发送数据包时，qemu 会将数据包传送到运行 qemu 的（真实）计算机上的适当应用程序（"主机"）。
你将使用 QEMU 的“用户模式网络堆栈”。关于用户模式堆栈的更多信息可以在 QEMU 的文档中找到。我们已经更新了 Makefile，以启用 QEMU 的用户模式网络堆栈和 E1000 网络卡。
Makefile 配置 QEMU 记录所有传入和传出的数据包到你实验目录中的文件 packets.pcap。查看这些记录可能有助于确认 xv6 是否在发送和接收你期望的数据包。要显示记录的数据包，请使用：
tcpdump -XXnr packets.pcap
我们已经在 xv6 仓库中为这个实验添加了一些文件。文件 kernel/e1000.c 包含了 E1000 的初始化代码，以及用于发送和接收数据包的空函数，你需要在其中实现这些功能。文件 kernel/e1000_dev.h 包含了 E1000 定义的寄存器和标志位的定义，这些定义在 Intel E1000 软件开发者手册中有所描述。文件 kernel/net.c 和 kernel/net.h 包含了一个简单的网络栈，实现了 IP、UDP 和 ARP 协议。这些文件还包含了一个灵活的数据结构来保存数据包，称为 mbuf。最后，文件 kernel/pci.c 包含了在 xv6 启动时搜索 PCI 总线上的 E1000 卡的代码。


# Your Job (hard)

>Your job is to complete e1000_transmit() and e1000_recv(), both in kernel/e1000.c, so that the driver can transmit and receive packets. You are done when make grade says your solution passes all the tests.

浏览一下 E1000 软件开发者手册。这本手册涵盖了几种紧密相关的以太网控制器。QEMU 模拟的是 82540EM。现在快速浏览第 2 章，以了解设备的基本情况。要编写驱动程序，你需要熟悉第 3 章和第 14 章，以及第 4.1 节（但不包括第 4.1 节的子部分）。你还需要参考第 13 章。其他章节主要涉及 E1000 的组件，你的驱动程序不需要与这些组件交互。开始时不要担心细节；只需了解文档的结构，以便后续查找相关内容。E1000 有许多高级功能，大多数你可以忽略。完成这个实验只需要一小部分基本功能。

我们在 e1000.c 中提供的 e1000_init() 函数将 E1000 配置为从 RAM 中读取要传输的数据包，并将接收到的数据包写入 RAM。这种技术称为 DMA（直接内存访问），它指的是 E1000 硬件直接从/向 RAM 读写数据包。

由于数据包可能会以比驱动程序处理速度更快的速度到达，e1000_init() 为 E1000 提供了多个缓冲区，用于写入数据包。E1000 需要这些缓冲区通过 RAM 中的“描述符”数组进行描述；每个描述符包含一个在 RAM 中的地址，E1000 可以在该地址写入接收到的数据包。struct rx_desc 描述了描述符的格式。描述符的数组称为接收环（receive ring）或接收队列（receive queue）。它是一个循环环，即当卡或驱动程序到达数组的末尾时，会回到开始的位置。e1000_init() 为 E1000 分配了 mbuf 数据包缓冲区，用于 DMA 操作，使用 mbufalloc() 函数。还有一个发送环（transmit ring），驱动程序将要发送的包放入其中。e1000_init() 将这两个环的大小配置为 RX_RING_SIZE 和 TX_RING_SIZE

当 net.c 中的网络栈需要发送数据包时，它会调用 e1000_transmit()，传入一个包含要发送的数据包的 mbuf。你的传输代码必须在 TX（传输）环中的一个描述符中放置指向数据包数据的指针。struct tx_desc 描述了描述符的格式。你需要确保每个 mbuf 最终被释放，但只有在 E1000 完成数据包传输之后（E1000 会在描述符中设置 E1000_TXD_STAT_DD 位来指示这一点）才能释放。

当 E1000 从以太网接收每个数据包时，它首先将数据包 DMA 到由下一个 RX（接收）环描述符指向的 mbuf 中，然后生成一个中断。你的 e1000_recv() 代码必须扫描 RX 环，并通过调用 net_rx() 将每个新数据包的 mbuf 传递给网络栈（在 net.c 中）。然后你需要分配一个新的 mbuf 并将其放入描述符中，以便当 E1000 再次到达 RX 环中的那个位置时，它会找到一个新的缓冲区来 DMA 一个新的数据包。

除了读取和写入 RAM 中的描述符环外，你的驱动程序还需要通过其内存映射的控制寄存器与 E1000 交互，以检测何时有接收到的数据包可用，并通知 E1000 驱动程序已填充了一些 TX 描述符用于发送数据包。全局变量 regs 保存了指向 E1000 第一个控制寄存器的指针；你的驱动程序可以通过将 regs 作为数组进行索引来访问其他寄存器。你特别需要使用 E1000_RDT 和 E1000_TDT 索引。

要测试你的驱动程序，在一个窗口中运行 make server，在另一个窗口中运行 make qemu 然后在 xv6 中运行 nettests。nettests 中的第一个测试尝试将一个 UDP 数据包发送到主机操作系统，地址指向 make server 运行的程序。如果你尚未完成实验，E1000 驱动程序实际上不会发送数据包，结果不会有太多变化。

完成实验后，E1000 驱动程序将会发送数据包，qemu 会将其传递到你的主机计算机，make server 会看到数据包，并发送一个响应数据包，E1000 驱动程序和 nettests 将会看到响应数据包。然而，在主机发送回复之前，它会向 xv6 发送一个“ARP”请求数据包，以查找其 48 位以太网地址，并期待 xv6 以 ARP 回复作出回应。一旦你完成了 E1000 驱动程序的工作，kernel/net.c 将会处理这一过程。如果一切顺利，nettests 将会打印 testing ping: OK，make server 会打印来自 xv6! 的消息。

hits:

1. e1000_transmit
首先，通过读取 E1000_TDT 控制寄存器来询问 E1000 正在期待下一个数据包的 TX 环索引。

然后检查环是否溢出。如果在由 E1000_TDT 索引的描述符中 E1000_TXD_STAT_DD 位没有被设置，说明 E1000 尚未完成之前的传输请求，因此返回错误。

否则，使用 mbuffree() 释放最后一个从该描述符传输的数据包（如果有的话）。

接着填充描述符。m->head 指向数据包在内存中的内容，m->len 是数据包的长度。设置必要的命令标志（请参见 E1000 手册的第 3.3 节），并保存一个指向 mbuf 的指针，以便后续释放。

最后，通过将 E1000_TDT 加 1 并对 TX_RING_SIZE 取模来更新环的位置。

如果 e1000_transmit() 成功将 mbuf 添加到环中，则返回 0。如果失败（例如，没有可用的描述符来传输 mbuf），则返回 -1，以便调用者知道需要释放 mbuf。

2.  e1000_recv
首先，通过获取 E1000_RDT 控制寄存器的值并加 1 对 RX_RING_SIZE 取模，询问 E1000 下一个等待接收的数据包（如果有的话）所在的环索引。

然后，通过检查描述符的状态部分中的 E1000_RXD_STAT_DD 位来检查是否有新数据包可用。如果没有，停止操作。

否则，将 mbuf 的 m->len 更新为描述符中报告的长度。使用 net_rx() 将 mbuf 交给网络栈。

接着，使用 mbufalloc() 分配一个新的 mbuf 来替换刚才交给 net_rx() 的那个。将新 mbuf 的数据指针（m->head）设置到描述符中。将描述符的状态位清零。

最后，将 E1000_RDT 寄存器更新为已处理的最后一个环描述符的索引。

e1000_init() 用 mbufs 初始化 RX 环，你可以查看它是如何完成这一操作的，并可能借用一些代码。

请确保你的代码能够处理总到达的数据包数量超过环大小（16）的情况。

## `e1000_transmit(struct mbuf *m)`
根据提示写：
`e1000_transmit`负责将一个数据包从`mbuf`发送到网络中。
1. 首先获取锁，确保在访问数据时发生竞争
2. 获取下一个数据的描述符
   数据描述符存放在`rx_ring`中，所以首先要获取其索引。而`E1000_TDT`是一个控制寄存器，用于指示下一个可用的传输描述符索引
3. 检测描述符的状态是否已经完成传输。`E1000_TXD_SYAY_DO`位表示传输完成。如果没有设置该位，说明描述符还在使用中，缓冲区满
4. 检查是否有未释放的mbuf在描述符位置。如果有，则释放，以便可用重用这个缓冲区
5. 设置描述符的地址位要发送的数据包在内存中的地址，设置描述符的长度位数据包的数据长度。设置描述符的命令字段
6. 记录当前描述符的mbuf指针，以便后序处理。更新 TX ring 中下一个要使用的描述符索引。使用模运算确保索引在环形缓冲区大小范围内。
```cpp
int
e1000_transmit(struct mbuf *m)
{
  acquire(&e1000_lock);
//找到下一个数据包的索引
uint32 ind = regs[E1000_TDT];
//找到描述符
struct tx_desc *desc = &tx_ring[ind];

//查看是否传输完成
if(!(desc->status & E1000_TXD_STAT_DD)){
    release(&e1000_lock);
    return -1;
}

//如果该下标仍有之前发送完毕但没有释放的mbuf，则释放
if(tx_mbufs[ind]){
    mbuffree(tx_mbufs[ind]);
    tx_mbufs[ind]=0;
}
//设置描述符的地址字段为要发送的数据包在内存的地址
desc->addr=(uint64)m->head;
//设置描述符的长度为数据包的长度
desc->length=m->len;
//设置描述符的命令字段
desc->cmd=E1000_TXD_CMD_EOP | E1000_TXD_CMD_RS;
//记录当前描述符的指针
tx_mbufs[ind]=m;
//更新 TX ring 中下一个要使用的描述符索引
regs[E1000_TDT] = (regs[E1000_TDT]+1)%TX_RING_SIZE;

  release(&e1000_lock);
  return 0;
}
```


## `e1000_recv(void)`

e1000_recv() 函数实现了从 E1000 网卡接收数据包的操作
e1000_recv() 的目标是检查接收描述符环（RX ring），处理已接收到的数据包，并为下一次接收准备新的缓冲区。

```cpp
static void
e1000_recv(void)
{
while(1) { // 每次 recv 可能接收多个包
//计算下一个接收描述符的索引。E1000_RDT 控制寄存器存储了当前接收描述符的索引
uint32 ind = (regs[E1000_RDT] + 1) % RX_RING_SIZE;

struct rx_desc *desc = &rx_ring[ind];
// 如果需要接收的包都已经接收完毕，则退出
if(!(desc->status & E1000_RXD_STAT_DD)) {
    return;
}

rx_mbufs[ind]->len = desc->length;
//mbuf 传递给网络栈的 net_rx() 函数。网络栈会处理数据包并负责释放 mbuf。
net_rx(rx_mbufs[ind]); 

// 分配并设置新的 mbuf，供给下一次轮到该下标时使用
rx_mbufs[ind] = mbufalloc(0); 
desc->addr = (uint64)rx_mbufs[ind]->head;
desc->status = 0;

regs[E1000_RDT] = ind;
}

}
```




