## 1. cmake

### 1.1 只有源文件

#### 1.1.1 共处一室

文件名: CMakeLists.txt

```c
cmake_minimum_required(VERSION 3.15)  
project(test)
add_executable(test1 test1.cpp test_src)
```

+ cmake_minimum_required:指定使用cmake的最低版本
+ project：定义工程名称
+ add_executable：定义工程会生成一个可执行程序

cmake命令执行：
  cmake CMakeLists.txt文件所在路径

执行完后会生成makefile文件，然后再执行 ：make，生成目标文件，即可允许

```cpp
$ tree
.
├── add.c
├── div.c
├── head.h
├── main.c
├── mult.c
└── sub.c
```

```cpp
cmake_minimum_required(VERSION 3.0) 
project(CALC)
add_executable(app add.c div.c main.c mult.c sub.c)
```

> 1. cmake .  生成makefile
> 2. make  生成可执行文件

#### 1.1.2 VIP 包房

把 cmake 生成的中间件 放到 build 下：

```bash
$ mkdir build
$ cd build
$ cmake ..
```

当命令执行完毕之后，在build目录中会生成一个makefile文件

```cpp
$ tree build -L 1
build
├── CMakeCache.txt
├── CMakeFiles
├── cmake_install.cmake
└── Makefile

1 directory, 3 files
```

这样就可以在build目录中执行make命令编译项目，生成的相关文件自然也就被存储到build目录中了。这样通过cmake和make生成的所有文件就全部和项目源文件隔离开了，各回各家，各找各妈。

### 1.2 私人订制

#### 1.2.1 定义变量

在上面的例子中一共提供了5个源文件，假设这五个源文件需要反复被使用，每次都直接将它们的名字写出来确实是很麻烦，此时我们就需要定义一个变量，将文件名对应的字符串存储起来，在cmake里定义变量需要使用set。

```cpp
# SET 指令的语法是：
# [] 中的参数为可选项, 如不需要可以不写

SET(VAR [VALUE] [CACHE TYPE DOCSTRING [FORCE]])
```

```cpp
# 方式1: 各个源文件之间使用空格间隔
# set(SRC_LIST add.c  div.c   main.c  mult.c  sub.c)

# 方式2: 各个源文件之间使用分号 ; 间隔
set(SRC_LIST add.c;div.c;main.c;mult.c;sub.c)
add_executable(app  ${SRC_LIST})
```

#### 1.2.2 指定使用的C++标准

在编写C++程序的时候，可能会用到C++11、C++14、C++17、C++20等新特性，那么就需要在编译的时候在编译命令中制定出要使用哪个标准：

```BASH
$ g++ *.cpp -std=c++11 -o app
```

上面的例子中通过参数-std=c++11指定出要使用c++11标准编译程序，C++标准对应有一宏叫做DCMAKE_CXX_STANDARD。在CMake中想要指定C++标准有两种方式：

1. 在 CMakeLists.txt 中通过 set 命令指定

```bash
#增加-std=c++11
set(CMAKE_CXX_STANDARD 11)
#增加-std=c++14
set(CMAKE_CXX_STANDARD 14)
#增加-std=c++17
set(CMAKE_CXX_STANDARD 17)
```

2. 在执行 cmake 命令的时候指定出这个宏的值

```bash
#增加-std=c++11
cmake CMakeLists.txt文件路径 -DCMAKE_CXX_STANDARD=11
#增加-std=c++14
cmake CMakeLists.txt文件路径 -DCMAKE_CXX_STANDARD=14
#增加-std=c++17
cmake CMakeLists.txt文件路径 -DCMAKE_CXX_STANDARD=17

```

#### 1.2.3 指定输出的路径

在CMake中指定可执行程序输出的路径，也对应一个宏，叫做EXECUTABLE_OUTPUT_PATH，它的值还是通过set命令进行设置:

```bash
set(HOME /home/yzx0111/project/test/cmake_study/)
# set(HOME ../)
set(EXECUTABLE_OUTPUT_PATH ${HOME}/bin)
```

+ 第一行：定义一个变量用于存储一个绝对路径
+ 第二行：将拼接好的路径值设置给EXECUTABLE_OUTPUT_PATH宏
  + 如果这个路径中的子目录不存在，会自动生成，无需自己手动创建

由于可执行程序是基于 cmake 命令生成的 makefile 文件然后再执行 make 命令得到的，所以如果此处指定可执行程序生成路径的时候使用的是相对路径 ./xxx/xxx，那么这个路径中的 ./ 对应的就是 makefile 文件所在的那个目录。

```bash
.
├── CMakeLists.txt
├── add.c
├── bin
│   └── app
├── build
│   ├── CMakeCache.txt
│   ├── CMakeFiles
│   ├── Makefile
│   └── cmake_install.cmake
├── div.c
├── head.h
├── main.c
├── mult.c
└── sub.c

```

### 1.3 搜索文件

如果一个项目里边的源文件很多，在编写CMakeLists.txt文件的时候不可能将项目目录的各个文件一一罗列出来，这样太麻烦也不现实。所以，在CMake中为我们提供了搜索文件的命令，可以使用aux_source_directory命令或者file命令。

#### 1.3.1 方式1

在 CMake 中使用aux_source_directory 命令可以查找某个路径下的所有源文件，命令格式为：

```cpp
cmake_minimum_required(VERSION 3.0)

project(CALC)

# 标准
set(CMAKE_CXX_STANDARD 11)
# 输出路径
set(HOME ../)
set(EXECUTABLE_OUTPUT_PATH ${HOME}/bin)
# 搜索路径
include_directories(${PROJECT_SOURCE_DIR}/include)
aux_source_directory(${CMAKE_CURRENT_SOURCE_DIR}/src SRC_LIST)
# 设置变量
add_executable(app  ${SRC_LIST})
```

```bash
aux_source_directory(< dir > < variable >)
```

dir：要搜索的目录
variable：将从dir目录下搜索到的源文件列表存储到该变量中

```cpp
aux_source_directory(${CMAKE_CURRENT_SOURCE_DIR}/src SRC_LIST)
```
+ ${CMAKE_CURRENT_SOURCE_DIR} 是 CMake 内置的一个变量，它代表当前正在处理的 CMakeLists.txt 文件所在的目录。在 CMake 处理不同层级的 CMakeLists.txt 文件时，这个变量的值会随之改变，它总是指向当前 CMakeLists.txt 文件所在的具体目录。
+ 这行代码的作用是将 ${CMAKE_CURRENT_SOURCE_DIR}/src 目录下的所有源文件的文件名收集到变量 SRC_LIST 中。

### 1.4 包含头文件

```bash
include_directories(${PROJECT_SOURCE_DIR}/include)
```
+ ${PROJECT_SOURCE_DIR} 是 CMake 内置的一个变量，它代表项目的根源代码目录，也就是包含顶层 CMakeLists.txt 文件的那个目录。在整个项目的构建过程中，这个变量的值是固定不变的。
+ 这行代码的作用是将 ${PROJECT_SOURCE_DIR}/include 目录添加到编译器的头文件搜索路径中。这样，在源文件中使用 #include 指令包含头文件时，编译器就会在这个目录中查找相应的头文件。

### 1.5 制作动态库或静态库

#### 1.5.1 制作静态库

```cpp
add_library(库名称 STATIC 源文件1 [源文件2] ...) 
```

在Linux中，静态库名字分为三部分：lib+库名字+.a，此处只需要指定出库的名字就可以了，另外两部分在生成该文件的时候会自动填充。


```cpp
.
├── build
├── CMakeLists.txt
├── include           # 头文件目录
│   └── head.h
├── main.cpp          # 用于测试的源文件
└── src               # 源文件目录
    ├── add.cpp
    ├── div.cpp
    ├── mult.cpp
    └── sub.cpp
```

```cpp
cmake_minimum_required(VERSION 3.0)
project(CALC)
# 标准
set(CMAKE_CXX_STANDARD 11)
# 输出路径
set(HOME ../)
set(EXECUTABLE_OUTPUT_PATH ${HOME}/bin)  // 仅对可执行文件有用
# 搜索路径
include_directories(${PROJECT_SOURCE_DIR}/include)
aux_source_directory(${CMAKE_CURRENT_SOURCE_DIR}/src SRC_LIST)
# 生成静态库
add_library(calc STATIC ${SRC_LIST})
```

> EXECUTABLE_OUTPUT_PATH 是 CMake 中的一个变量，它专门用于指定可执行文件的输出目录。
> LIBRARY_OUTPUT_PATH 变量来指定静态库和动态库的输出目录。

生成静态库怎么使用?
```cpp
cmake_minimum_required(VERSION 3.0)
project(CALC)
# 标准
set(CMAKE_CXX_STANDARD 11)
# 输出路径
set(HOME ../)
set(EXECUTABLE_OUTPUT_PATH ${HOME}/bin)
set(LIBRARY_OUTPUT_PATH ${HOME}/bin/lib)
# 搜索路径
include_directories(${PROJECT_SOURCE_DIR}/include) # 可执行文件
aux_source_directory(${CMAKE_CURRENT_SOURCE_DIR}/src SRC_LIST) # 库
# 生成静态库
add_library(calc STATIC ${SRC_LIST})


# 添加可执行文件
add_executable(main main.c)
# 链接静态库
target_link_libraries(main PRIVATE calc)
# 设置库的搜索路径
target_link_directories(main PRIVATE ${LIBRARY_OUTPUT_PATH})

```

+ PRIVATE 表明该链接信息（如链接的库、库的搜索路径等）仅对当前目标（这里是 main 可执行文件）有效，不会传递给依赖于当前目标的其他目标。
+ PUBLIC 当使用 PUBLIC 时，链接信息不仅对当前目标有效，还会传递给依赖于当前目标的其他目标。也就是说，依赖于当前目标的其他目标会自动继承这些链接信息。
+ INTERFACE 表示链接信息仅传递给依赖于当前目标的其他目标，而当前目标本身不会使用这些链接信息。通常用于定义接口库的链接需求。例如：





## 2. 使用set

定义一个变量，将文件名对应的字符串存储起来，在cmake里定义变量需要使用set

```c
# SET 指令的语法是：
# [] 中的参数为可选项, 如不需要可以不写
SET(VAR [VALUE] [CACHE TYPE DOCSTRING [FORCE]])
```

+ var: 变量名
+ value： 变量值，都是字符串；用空格分开

取变量值： ${VAR}

**指定输出路径**
在CMake中指定可执行程序输出的路径，也对应一个宏，叫做EXECUTABLE_OUTPUT_PATH，它的值还是通过set命令进行设置:

```c
set(HOME /home/robin/Linux/Sort)
set(EXECUTABLE_OUTPUT_PATH ${HOME}/bin)
```

+ 第一行：定义一个变量用于存储一个绝对路径
+ 第二行：将拼接好的路径值设置给EXECUTABLE_OUTPUT_PATH宏
  + 如果这个路径中的子目录不存在，会自动生成，无需自己手动创建

**指定使用的C++标准**
在编写C++程序的时候，可能会用到C++11、C++14、C++17、C++20等新特性，那么就需要在编译的时候在编译命令中制定出要使用哪个标准：

+ 在 CMakeLists.txt 中通过 set 命令指定

```c
#增加-std=c++11
set(CMAKE_CXX_STANDARD 11)
```

+ 在执行 cmake 命令的时候指定出这个宏的值
 `cmake CMakeLists.txt文件路径 -DCMAKE_CXX_STANDARD=11`

## 3. 搜索文件
如果一个项目里边的源文件很多，在编写CMakeLists.txt文件的时候不可能将项目目录的各个文件一一罗列出来，这样太麻烦也不现实。所以，在CMake中为我们提供了搜索文件的命令，可以使用`aux_source_directory`命令或者`file`命令。

1. 在 CMake 中使用`aux_source_directory `命令可以查找某个路径下的所有源文件，命令格式为

```c
aux_source_directory(dir variable)
```

+ dir: 要搜索的目录
+ variable: 将从dir目录搜索到的源文件列表存储到该变量中

```c
cmake_minimum_required(VERSION 3.15)

project(test)

# set(SRC test1.cpp test_src)
aux_source_directory(${PROJECT_SOURCE_DIR} SRC)

# 输出路径
set(HOME /home/yzx0111/project/webt/cmake/)
set(EXECUTABLE_OUTPUT_PATH ${HOME}/bin)

add_executable(test1 ${SRC})
```

+ PROJECT_SOURCE_DIR 是 CMake 中的一个变量，用于存储当前项目的源代码目录的绝对路径。

2. 使用 file

```c
file(GLOB/GLOB_RECURSE 变量名 要搜索的文件路径和文件类型)
```

+ GLOB: 将指定目录下搜索到的满足条件的所有文件名生成一个列表，并将其存储到变量中。
+ GLOB_RECURSE: 递归搜索指定目录，将搜索到的满足条件的文件名生成一个列表，并将其存储到变量中。

```cmake
file(GLOB MAIN_SRC ${CMAKE_CURRENT_SOURCE_DIR}/src/*.cpp)
file(GLOB MAIN_HEAD ${CMAKE_CURRENT_SOURCE_DIR}/include/*.h)
```

+ CMAKE_CURRENT_SOURCE_DIR 宏表示当前访问的 CMakeLists.txt 文件所在的路径。

## 4. 包含头文件

在编译项目源文件的时候，很多时候都需要将源文件对应的头文件路径指定出来，这样才能保证在编译过程中编译器能够找到这些头文件，并顺利通过编译。在CMake中设置要包含的目录也很简单，通过一个命令就可以搞定了，他就是include_directories:

```cmake
include_directories(headpath)
```

```cpp
$ tree
.
├── build
├── CMakeLists.txt
├── include
│   └── head.h
└── src
    ├── add.cpp
    ├── div.cpp
    ├── main.cpp
    ├── mult.cpp
    └── sub.cpp

3 directories, 7 files
```

CMakeLists.txt文件内容如下:

```cmake
cmake_minimum_required(VERSION 3.0)
project(CALC)
set(CMAKE_CXX_STANDARD 11)
set(HOME /home/robin/Linux/calc)
set(EXECUTABLE_OUTPUT_PATH ${HOME}/bin/)
include_directories(${PROJECT_SOURCE_DIR}/include)
file(GLOB SRC_LIST ${CMAKE_CURRENT_SOURCE_DIR}/src/*.cpp)
add_executable(app  ${SRC_LIST})
```

## 5. 






