
**页**：一个固定长度的数据块，存储在二级存储器中（如磁盘）。数据项可以临时复制入内存中的页框中
**段**：一个变长的数据块，存储在二级存储器中。整个段可以临时复制到内存的一个可用区域内（分段），或者可以将一个段分为许多页，将每页单独复制到内存中（分段和分页相结合）

1. 内存管理的需求
  对内存提出了5点需求：重定位、保护、共享、逻辑组织、物理组织
  
  1. 重定位
    在多道程序设计系统中，可用的内存空间通常被多个进程共享。通常情况下，程序员并不能知道某个程序执行期间会有哪些程序驻留在内存中。此为还希望通过一个巨大的就绪进程池，能够把活动进程换入换出内存，以便使处理器的利用率最大化。一旦程序被换出到磁盘，当下一次被换入时，如果必须放到和被患处前相同的内存区域，那么这将会是一个很大的限制。为了避免这种限制，我们需要把进程**重定位**到内存的不同区域。

    因此，我们事先不知道程序将会被放置到那个区域，并且我们需要允许程序通过交换技术在内存中移动。这关系到一些寻址相关的技术问题。假设进程映像占据内存中的一段相邻的区域。显然，操作系统需要知道进程控制信息和执行栈的位置，以及该进程开始执行程序的入口。由于操作系统管理内存并负责把进程放入内存，因此可以很容易地访问到这些地址。此外，处理器必须处理程序内部的内存访问。跳转指令包含下一步将要执行的指令的地址，数据访问指令包含被访问数据的字节或字的地址。处理器硬件和操作系统软件必须能够通过某种方式把程序代码中的内存访问换成物理内存地址，并反映程序在内存中的当前位置。
  2. 保护
    每个进程都应该受到保护，以免被其他进程有意或无意地干涉。由于程序在内存中的位置是不可预测的，因而在编译时不可能检查绝对地址来保护。并且大多数程序设计语言允许在运行时进行地址的动态计算。因此，必须在运行时检查进程产生的所有内存访问，以确保他们只访问了分配给该进程的存储空间。

    通常，用户进程不能访问操作系统的任何部分，不论是程序还是数据。并且，一个进程中的程序通常不能跳转到另一个进程中的指令。如果没有特别的许可，一个进程中的程序不能访问其他进程的数据区。处理器必须能够在执行时终止这样的指令。

    注意，内存保护的需求必须由处理器来满足，而不是由操作系统满足。这是因为操作系统不能预测程序可能产生的所有内存访问；即使可以预测，提前审查每个进程中可能存在的内存违法访问也是非常耗时的。因此，只能在指令访问内存时来判断这个内存访问是否违法（存取数据或跳转）。为了实现这一点，处理器硬件必须具有这个能力
  3. 共享 
    任何保护机制都必须巨有一定的灵活性，以允许多个进程访问内存的统一部份。例如，如果多个进程正在执行同一个程序，则允许每个进程访问改程序的同一个副本要比让每个进程有自己单独的副本更有优势。
  4. 逻辑组织
    计算机系统中的内存总是被组织成线性的地址空间，并且地址空间是由一系列字节或字组成的。外部存储器（外存）在物理层上也是按类似方式组织的。尽管这种组织方式类似于实际的机器硬件，但它并不符合程序构造的典型方式。大多数程序被组织成模块，某些模块是不可修改的，某些模块包含可以修改的数据。如果操作系统和计算机硬件能够有效地处理以某种模块的方式组织用户的程序和数据，则会很方便：
      1. 可以单独地编辑和编译模块，系统在运行时解析从一个模块到其他模块的所有引用
      2. 通过适度的额外开销，可以给不同的模块以不同的保护级别（只读、只执行）
      3. 可以引入某种机制，使得模块可以被多个进程共享。在模块级提供共享的优点在于它符合用户看待问题的方式，因此用户也可以很容易地指定需要的共享
   最容易满足这些需求的工具就是**分段**
  5. 物理组织
    计算机存储器至少被组织成两级，成为内存和外存。内存提供快速的访问，并且内存时易失性的，也就是说不能提供永久存储。外存，容量大且不易失性的。所以外存可以用于长期存储程序和数据，而内存用于保存当前使用的程序和数据。
      1. 可供程序和数据使用的内存可能不足。在这种情况下，程序员必须采用覆盖技术来组织程序和数据。不同的模块被分配到内存中同一块区域，主程序负责在需要时换入或换出模块。
      2. 在多道程序设计环境中，程序员在编写代码时并不知道可用空间的大小和位置
    显然，在两级存储器间移动信息的任务应该是一种系统责任，而改任务恰恰就是存储管理的本质所在。

2. 内存分区
   内存管理最基本的操作就是由处理器把程序装入内存中执行。在大部分现代多道程序设计系统中，这往往还涉及一种称为虚拟内存的精密方案。虚拟内存又基于分段和分页这两种基本技术或其中一种。

   **简单分页**：内存被划分成许多大小相等的页框；每个进程被划分成许多大小与页框相等的页；要装入进程，需要把进程包含的所有页都装到内存中不一定连续的某些页框中。优势：没有外部碎片；缺点：有少量的内部碎片
   **简单分段**：每个进程被划分成许多段；要装入进程，需要把进程包含的所有段都要装入到内存中不一定连续的某些动态分区中。没有内部碎片，但是存在外部碎片
   **虚拟内存分页**：除了不需要装入进程的所有页之外与简单分页一样；非驻留页在以后需要时自动调入内存。优点：没有外部碎片，支持更高道数的多道程序设计，巨大的虚拟内存空间。缺点：复杂的内存管理开销
   **虚拟内存分段**：除了不需要装入进程的所有段之外与简单分段一样；非驻留段在以后需要时自动调入内存。优点：没有内部碎片，支持更高道数的多道程序设计，巨大的虚拟内存空间，支持保护和共享。缺点：复杂的内存管理开销

   1. 重定位
   当进程被换入或者在内存中移动时，指令和数据单元的位置会发生改变。为了解决这个问题，需要对几种地址类型进行区分。**逻辑地址**是指与当前数据在内存中的物理地址无关的访问地址，在执行对内存的访问之前必须把它转换为物理地址。**相对地址**是逻辑地址的一个特例，是相对与某些已知点（通常是程序开始处）的存储单元。**物理地址**或绝对地址是数据在内存中的实际位置

   系统采用运行时动态加载的方式把使用相对地址的程序加载到内存。通常情况下，被加载进程中的所有内存访问都相对于程序的开始点。因此，在执行包括这类访问的指令时，需要一个硬件机制把相对地址转化为物理地址。

   实现这类地址转化的方式。当进程处于运行态时，基址寄存器存储的是程序在内存的起始地址。还有一个界限寄存器指明程序的终止位置。当程序被装入内存或该进程的映射被换入时，必须设置这两个寄存器。在进程执行过程中会遇到相对地址，包括指令寄存器的内容、跳转或调用指令中的指令地址以及加载和存储指令中的数据地址。每个这样的相对地址都经过两步操作。首先，基址寄存器中的值加上相对地址产生一个绝对地址；然后，得到的结果与界限寄存器的值比较，如果这个地址在界限范围内，则继续该指令的执行；否则，向操作系统中发出一个中断信号，操作系统必须以某种方式对这个错误做出反应。

3. 分页
   内存被划分成大小相等的块，且块相对比较小，每个进程也被分成同样大小相等的块，那么进程中称为页的块可以指定到内存中称为页框的可用块。使用分页技术在内存中为每个进程浪费的空间仅仅是进程最后一页的一小部分形成的内部碎片，没有外部碎片。

   在某个给定的时间，内存中的某些页框正在被使用，某些页框是空闲的的，操作系统维护空闲页框的列表。
   同时，操作系统也要为每个进程维护一个**页表**。页表给出了该进程的每一页对应的页框位置。

4. 虚拟内存的分配过程

虚拟地址是操作系统为每个进程提供的地址空间，使得每个进程都认为它有自己独立的、连续的内存空间

在现代操作系统中，当程序被加载到内存中时，代码段、数据段和堆栈段等都会被映射到虚拟地址空间

地址转换过程：
  1. 编译和链接：编译器和链接器在生成可执行文件时，将代码和数据的地址设定为虚拟地址。
  2. 加载：当操作系统加载程序时，会为程序分配虚拟地址空间，并将可执行文件中的代码和数据映射到这个空间中。
  3. 运行：CPU 使用虚拟地址，通过 MMU 和页表转换为物理地址，从而访问实际的内存

加载程序和分配虚拟地址空间的过程
  1. 可执行文件：当一个程序被编译和链接后，会生成一个可执行文件，比如 ELF 文件（在 Unix-like 系统中常见）。
  2. 进程创建：当用户或系统调用（如 exec 系列系统调用）请求执行这个可执行文件时，操作系统会创建一个新的进程。
  3. 分配虚拟地址空间：操作系统为新进程分配虚拟地址空间，并初始化页表
1. 可执行文件加载
   读取可执行文件：操作系统从存储设备中读取可执行文件的头部信息，解析文件格式（如 ELF 格式）。
   段信息：解析可执行文件中的段信息，比如代码段（.text）、数据段（.data）、未初始化数据段（.bss）等。
2. 分配虚拟地址空间
   创建进程控制块（PCB）：操作系统创建进程控制块，用于管理新进程的信息。
   初始化页表：操作系统为新进程初始化页表，设置页表基地址等信息。
   映射段：根据可执行文件中的段信息，将每个段映射到虚拟地址空间中的适当位置。通常代码段和数据段的起始地址是在可执行文件中指定的。
3. 内存分配
   加载段到内存：将代码段和数据段从可执行文件中加载到物理内存中，并建立相应的虚拟地址到物理地址的映射。
   未初始化数据段（.bss）：为未初始化数据段分配内存，并将其初始化为零。
4. 设置堆栈和堆
   堆栈：操作系统为进程分配堆栈空间，通常从高地址向低地址增长。初始化堆栈指针（SP）。
   堆：为动态内存分配（malloc 等）预留堆空间，通常从低地址向高地址增长。  
5. 设置程序入口点
   程序入口点：根据可执行文件中的入口点信息，设置程序计数器（PC）指向入口点，通常是 main 函数的地址。
6. 切换到新进程
   上下文切换：操作系统完成对新进程的初始化后，进行上下文切换，将 CPU 控制权交给新进程，开始执行新进程的代码。