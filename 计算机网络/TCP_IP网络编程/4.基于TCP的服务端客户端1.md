# 基于TCP的服务端/客户端

## 1. 理解TCP和UDP

TCP套接字是面向连接的，所以又称为基于流的套接字；

TCP/IP协议栈分为4层，可以理解为数据收发分为4个层次化过程。应用层、TCP层、IP层、链路层；

把协议分为多个层次具有哪些有点？
  协议设计更容易。
  可以通过标准化操作设计开放式系统。
  
1. 链路层
   链路层是物理连接领域标准化的结果。若两台主机通过网络进行数据交换，则需要物理连接，链路层就负责这些标准；

2. IP层
   负责数据包的路由和转发，确定数据包的路径
   向目标传输数据需要经过哪条路径？解决此问题的就是IP层，该层使用的协议就是IP
   IP本身是面向消息的、不可靠的协议。每次传输数据时会帮我们选择路径，但并不一致。如果传输中发生路径错误，则选择其他路径；但如果发生数据丢失或错误，则无法解决，

3. TCP/IP层
   IP层解决数据传输中的路径选择问题，只需照此路径传输数据即可。TCP和UDP层以IP层提供的路径信息为基础完成实际的数据传输，故该层又称传输层。

   IP层只关注一个数据包（数据传输的基本单位）的传输过程。因此，即使传输多个数据包，每个数据包也是由IP层实际传输的，也就是说传输顺序及传输本身是不可靠的。若指利用Ip层传输数据，则有可能导致后传输的数据包比先传输的数据包A提早到达。另外，传输的数据包ABC，有可能只收到AC，甚至C可能受损。

4. 应用层
  提供网络服务和应用程序接口，如 HTTP、FTP、SMTP、DNS 等。
  作用：处理应用程序和用户之间的交互，生成应用数据，并将其交给传输层处理


## 2. 实现基于TCP的服务端/客户端

TCP服务端：socket()->bind()->listen()->accept()->read()/write()->close

TCP客户端：socket()->connect()->read()/write()->close()

socket() 函数
  服务器端：创建一个套接字，准备进行网络通信。
  客户端：同样需要创建一个套接字来发起连接请求。

bind() 函数
  服务器端：将套接字与本地地址（IP 地址和端口号）绑定。
  客户端：通常不需要显式调用 bind() 函数，因为操作系统会自动为客户端分配一个临时端口。

listen() 函数
  服务器端：调用 listen() 函数将套接字设置为监听状态，准备接受连接请求。listen() 函数的作用是通知操作系统，这个套接字将用于接收客户端的连接请求。

accept() 函数
  服务器端：调用 accept() 函数接受来自客户端的连接请求。accept() 函数会阻塞，直到有客户端连接请求到来。一旦接受连接，accept() 函数返回一个新的套接字，用于与客户端进行通信。

客户端的 connect() 函数
   客户端：在服务器端调用 listen() 后，客户端可以调用 connect() 函数来发起连接请求。

### write与read
交互产生的问题：

客户端代码：
```cpp
while (1)
{
    fputs("Input message(Q to quit):", stdout);
    fgets(message, BUF_SIZE, stdin);

    if (!strcmp(message, "q\n") || !strcmp(message, "Q\n"))
        break;
    
    write(client_sock, message, strlen(message));
    str_len = read(client_sock, message, BUF_SIZE - 1);
    message[str_len] = 0;
    printf("Message from server: %s", message);
}

```
服务端
```cpp
while ((str_len = read(client_sock, message, BUF_SIZE)) != 0)
{
    write(client_sock, message, str_len);
    printf("a\n");
}
```
`fgets() 读取到的输入包含换行符（\n）`，这在客户端和服务端之间的交互中可能会引起问题。如果服务端将收到的消息直接写回客户端，消息中包含的换行符也会被发送回客户端。
使用 strlen() 来计算消息长度，但这只计算了实际字符的长度，不包括可能的换行符。

数据以流的形式传输，没有明确的消息边界。这意味着，当客户端通过 TCP 发送多个消息时，服务端可能会一次性接收到这些消息的组合，而不是每条消息单独处理。
  客户端发送数据：当客户端连续调用 write 发送多个数据块时，操作系统将这些数据块发送到网络中。由于 TCP 是流式协议，这些数据块可能会被组合成一个大的数据流发送到服务端。
  一次性读取：当服务端调用 read 函数时，它会从接收缓冲区读取数据。由于接收缓冲区可能包含多个客户端发送的数据块，read 可能会一次性读取到多个数据块的组合。

`read:`
  `ssize_t read(int fd, void *buf, size_t count);`
  fd：文件描述符，表示要读取数据的文件或套接字。
  buf：指向一个缓冲区的指针，读取的数据将存储在该缓冲区中。
  count：要读取的字节数。

  返回：
  成功时，返回实际读取的字节数。
  如果到达文件末尾（对于文件）或套接字关闭（对于套接字），返回 0。
  如果发生错误，返回 -1，并设置 errno 以指示错误原因

`write：`
  `ssize_t write(int fd, const void *buf, size_t count);`
  fd：文件描述符，表示要写入数据的文件或套接字。
  buf：指向包含要写入数据的缓冲区的指针。
  count：要写入的字节数。

  返回值：
  成功时，返回实际写入的字节数。
  如果发生错误，返回 -1，并设置 errno 以指示错误原因。
  
客户端：调用 write 后，数据会被放入客户端的发送缓冲区，并等待被发送到服务端。客户端的 read 操作在服务端的 write 操作完成并且数据传输到客户端之后才会成功。

服务端：调用 read 后，服务端会从接收缓冲区中读取数据。如果没有数据，read 会阻塞直到数据到达。服务端的 write 操作将数据发送到客户端的发送缓冲区。

阻塞行为：
  write 函数：通常是非阻塞的，意味着它会将数据放入缓冲区后立即返回，具体的数据传输由系统在后台进行。

  read 函数：通常是阻塞的，意味着它会等待直到有数据可读或连接关闭。

strlen 函数用于计算 C 字符串的长度，它返回的是字符串中字符的数量，不包括字符串结尾的空字符（'\0'）

**解决方案：**
1. 处理换行符：
  在客户端和服务端中处理消息时，可以去除换行符，确保消息的完整性和一致性
  `message[strcspn(message, "\n")] = 0; // 去除换行符`
2. 使用定界符：
  在消息的结尾添加特定字符（如 \n），服务端根据这些字符来分隔消息。
  ```cpp
    // 客户端代码示例
    snprintf(message, BUF_SIZE, "Hello\n");
    write(client_sock, message, strlen(message));
    snprintf(message, BUF_SIZE, "World\n");
    write(client_sock, message, strlen(message));
  ```
  ```cpp
    // 服务端代码示例
    char buffer[BUF_SIZE];
    while ((str_len = read(client_sock, buffer, BUF_SIZE - 1)) > 0) {
        buffer[str_len] = 0; // 添加终止符
        char *msg = strtok(buffer, "\n");
        while (msg != NULL) {
            printf("Received message: %s\n", msg);
            msg = strtok(NULL, "\n");
        }
    }
  ```


# 习题
1. 请说明TCP/IP的4层协议栈，并说明TCP和UDP套接字经过的层级结构差异
   主要是传输层不同
   TCP 是面向连接的协议，提供可靠的、按顺序的、无差错的数据传输服务。TCP 套接字在传输层有额外的处理来保证数据的完整性和顺序。
   UDP 是无连接的协议，提供简单的、尽力而为的服务。UDP 套接字没有额外的处理来保证数据的完整性或顺序，适用于需要低延迟的应用场景。

2. 请说出TCP/IP协议栈中链路层和IP层的作用，并给出两值关系
   链路层（Data Link Layer）的作用：链路层将网络层传下来的数据包（IP 数据包）封装成帧，以适应物理介质的传输需求。链路层负责通过 MAC 地址来标识网络接口设备。MAC 地址在同一局域网内唯一，用于确保数据帧送达正确的目标设备。

   IP 层（网络层）的作用：IP 层负责将数据包从源设备传送到目标设备。它通过路由器和交换机来确定最佳路径并转发数据包。IP 层使用 IP 地址来标识网络中每个设备的逻辑地址。IP 地址确保数据包能在网络中找到正确的目标设备。当数据包大于网络的最大传输单元（MTU）时，IP 层会将其分段。接收端的 IP 层负责将这些片段重组为完整的数据包。

  在数据从应用层经过 TCP/UDP 层传到 IP 层时，IP 层将数据封装为 IP 数据包。然后，IP 数据包传递给链路层，链路层进一步将 IP 数据包封装成帧进行传输。IP 层使用 IP 地址进行网络间的路由，而链路层使用 MAC 地址在局域网内识别设备。路由器和交换机会在 IP 层处理数据包的路由和转发，在链路层处理帧的发送和接收。

3. 为何需要把TCP/IP协议栈分为4层（或7层）？结合开放式系统回答

  分层设计不仅方便了协议的开发和实现，还支持了开放系统的互操作性。

4. 客户端调用connect函数向服务器端发送连接请求。服务器端调用那个函数后，客户端可以调用connect函数？

    listen() 和 accept() 函数来准备和接受客户端的连接请求

5. 什么时候创建连接请求等待队列？它有什么作用？与accept有什么关系？

  接请求等待队列是在服务器端调用 listen() 函数时创建的。它是用于存放尚未被 accept() 函数处理的连接请求的队列
  当客户端尝试连接到服务器时，连接请求会被放入等待队列中，直到服务器端的应用程序调用 accept() 函数处理这些请求。
  队列的长度（由 listen() 函数指定）限制了服务器能够同时处理的待接受连接请求的数量。如果队列满了，新到来的连接请求可能会被拒绝，或根据操作系统的实现，客户端可能会收到错误信息。


6. 客户端中为何不需要调用bind函数分配地址？如果不调用bind函数，哪何时、如何向套接字分配IP地址和端口号？
  端口号和IP地址：在客户端调用 connect() 函数时，操作系统会自动为客户端套接字分配一个临时的本地端口号和 IP 地址。这个过程通常在客户端与服务器建立连接之前完成。






